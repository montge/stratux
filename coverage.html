
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>main: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/stratux/stratux/main/ais.go (0.0%)</option>
				
				<option value="file1">github.com/stratux/stratux/main/clientconnection.go (0.0%)</option>
				
				<option value="file2">github.com/stratux/stratux/main/cot-in.go (0.0%)</option>
				
				<option value="file3">github.com/stratux/stratux/main/datalog.go (8.2%)</option>
				
				<option value="file4">github.com/stratux/stratux/main/flarm-nmea.go (18.0%)</option>
				
				<option value="file5">github.com/stratux/stratux/main/gen_gdl90.go (17.7%)</option>
				
				<option value="file6">github.com/stratux/stratux/main/gps.go (5.5%)</option>
				
				<option value="file7">github.com/stratux/stratux/main/logging.go (0.0%)</option>
				
				<option value="file8">github.com/stratux/stratux/main/lowpower_uat.go (0.0%)</option>
				
				<option value="file9">github.com/stratux/stratux/main/managementinterface.go (0.0%)</option>
				
				<option value="file10">github.com/stratux/stratux/main/messagequeue.go (94.8%)</option>
				
				<option value="file11">github.com/stratux/stratux/main/monotonic.go (56.2%)</option>
				
				<option value="file12">github.com/stratux/stratux/main/network.go (0.0%)</option>
				
				<option value="file13">github.com/stratux/stratux/main/networksettings.go (0.0%)</option>
				
				<option value="file14">github.com/stratux/stratux/main/ogn-aprs.go (0.0%)</option>
				
				<option value="file15">github.com/stratux/stratux/main/ogn.go (0.0%)</option>
				
				<option value="file16">github.com/stratux/stratux/main/ping.go (0.0%)</option>
				
				<option value="file17">github.com/stratux/stratux/main/pong.go (0.0%)</option>
				
				<option value="file18">github.com/stratux/stratux/main/sdr.go (0.4%)</option>
				
				<option value="file19">github.com/stratux/stratux/main/sensors.go (0.0%)</option>
				
				<option value="file20">github.com/stratux/stratux/main/trace.go (0.0%)</option>
				
				<option value="file21">github.com/stratux/stratux/main/tracker.go (4.1%)</option>
				
				<option value="file22">github.com/stratux/stratux/main/traffic.go (44.3%)</option>
				
				<option value="file23">github.com/stratux/stratux/main/uibroadcast.go (14.3%)</option>
				
				<option value="file24">github.com/stratux/stratux/main/xplane.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
        Copyright (c) 2021 R. van Twisk
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        ais.go: Routines for reading AIS traffic
*/

package main

import (
        "bufio"
        "encoding/json"
        "fmt"
        "log"
        "net"
        "strings"
        "time"

        "github.com/stratux/stratux/common"

        "github.com/BertoldVdb/go-ais"
        "github.com/BertoldVdb/go-ais/aisnmea"
)

var aisIncomingMsgChan chan string = make(chan string, 100)
var aisExitChan chan bool = make(chan bool, 1)
var aisNmeaParser = aisnmea.NMEACodecNew(ais.CodecNew(false, false))

func aisListen() <span class="cov0" title="0">{
        //go predTest()
        for </span><span class="cov0" title="0">{
                if !globalSettings.AIS_Enabled || AISDev == nil </span><span class="cov0" title="0">{
                        // wait until AIS is enabled
                        time.Sleep(1 * time.Second)
                        continue</span>
                }
                // log.Printf("ais connecting...")
                <span class="cov0" title="0">aisAddr := "127.0.0.1:10110"
                conn, err := net.Dial("tcp", aisAddr)
                if err != nil </span><span class="cov0" title="0">{ // Local connection failed.
                        time.Sleep(3 * time.Second)
                        continue</span>
                }
                <span class="cov0" title="0">log.Printf("ais successfully connected")
                aisReadWriter := bufio.NewReadWriter(bufio.NewReader(conn), bufio.NewWriter(conn))
                globalStatus.AIS_connected = true

                // Make sure the exit channel is empty, so we don't exit immediately
                for len(aisExitChan) &gt; 0 </span><span class="cov0" title="0">{
                        &lt;-aisExitChan
                }</span>

                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        scanner := bufio.NewScanner(aisReadWriter.Reader)
                        for scanner.Scan() </span><span class="cov0" title="0">{
                                aisIncomingMsgChan &lt;- scanner.Text()
                        }</span>
                        <span class="cov0" title="0">if scanner.Err() != nil </span><span class="cov0" title="0">{
                                log.Printf("ais-rx-eu connection lost: " + scanner.Err().Error())
                        }</span>
                        <span class="cov0" title="0">aisExitChan &lt;- true</span>
                }()

        <span class="cov0" title="0">loop:
                for globalSettings.AIS_Enabled </span><span class="cov0" title="0">{
                        select </span>{
                        case data := &lt;-aisIncomingMsgChan:<span class="cov0" title="0">
                                TraceLog.Record(CONTEXT_AIS, []byte(data))
                                parseAisMessage(data)</span>
                        case &lt;-aisExitChan:<span class="cov0" title="0">
                                break loop</span>

                        }
                }
                <span class="cov0" title="0">globalStatus.AIS_connected = false
                conn.Close()
                time.Sleep(3 * time.Second)</span>
        }
}

func parseAisMessage(data string) <span class="cov0" title="0">{
        var thisMsg msg
        thisMsg.MessageClass = MSGCLASS_AIS
        thisMsg.TimeReceived = stratuxClock.Time
        thisMsg.Data = data
        globalStatus.AIS_messages_total++
        msgLogAppend(thisMsg)
        logMsg(thisMsg) // writes to replay logs

        msg, err := aisNmeaParser.ParseSentence(data)
        if err == nil &amp;&amp; msg != nil &amp;&amp; msg.Packet != nil </span><span class="cov0" title="0">{
                importAISTrafficMessage(msg)
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                log.Printf("Invalid Data from AIS: " + err.Error())
        }</span> else <span class="cov0" title="0">{
                // Multiline sentences will have msg as nill without err
        }</span>
}

// Datastructure for AIS parsing
// explanation can be found at https://www.navcen.uscg.gov/?pageName=AISMessages
func importAISTrafficMessage(msg *aisnmea.VdmPacket) <span class="cov0" title="0">{
        var ti TrafficInfo

        var header *ais.Header = msg.Packet.GetHeader()
        var key = header.UserID

        trafficMutex.Lock()
        defer trafficMutex.Unlock()

        if existingTi, ok := traffic[key]; ok </span><span class="cov0" title="0">{
                ti = existingTi
        }</span> else<span class="cov0" title="0"> {
                ti.Reg = fmt.Sprintf("%d", header.UserID)
                ti.Emitter_category = 18 // Ground Vehicle, see also gdl90EmitterCatToNMEA
                ti.TargetType = TARGET_TYPE_AIS
                ti.Last_source = TRAFFIC_SOURCE_AIS
                ti.Alt = 0
                ti.Addr_type = uint8(1) // Non-ICAO Address
                ti.SignalLevel = 0.0
                ti.Squawk = 0
                ti.AltIsGNSS = false
                ti.GnssDiffFromBaroAlt = 0
                ti.NIC = 0
                ti.NACp = 0
                ti.Vvel = 0
                ti.PriorityStatus = 0

                ti.Age = 0
                ti.AgeLastAlt = 0
        }</span>

        <span class="cov0" title="0">ti.Icao_addr = header.UserID
        ti.Timestamp = time.Now().UTC()
        ti.Last_seen = stratuxClock.Time
        ti.Last_alt = stratuxClock.Time

        // Handle ShipStaticData
        if header.MessageID == 5 </span><span class="cov0" title="0">{
                var shipStaticData ais.ShipStaticData = msg.Packet.(ais.ShipStaticData)

                ti.Tail = strings.TrimSpace(shipStaticData.Name)
                ti.Reg = strings.TrimSpace(shipStaticData.CallSign)
                ti.SurfaceVehicleType = uint16(shipStaticData.Type)
                // Store in case this was the first message and we disgard die to GPS not available
                traffic[key] = ti
        }</span>

        // Handle LongRangeAisBroadcastMessage
        <span class="cov0" title="0">if header.MessageID == 27 </span><span class="cov0" title="0">{
                var positionReport ais.LongRangeAisBroadcastMessage = msg.Packet.(ais.LongRangeAisBroadcastMessage)

                ti.Lat = float32(positionReport.Latitude)
                ti.Lng = float32(positionReport.Longitude)

                if positionReport.Cog != 511 </span><span class="cov0" title="0">{
                        cog := float32(positionReport.Cog)
                        ti.Track = cog
                }</span>
                <span class="cov0" title="0">if positionReport.Sog &lt; 63 </span><span class="cov0" title="0">{
                        ti.Speed = uint16(positionReport.Sog)
                        ti.Speed_valid = true
                }</span>
        }

        // Handle MessageID 1,2 &amp; 3 Position reports
        <span class="cov0" title="0">if header.MessageID == 1 || header.MessageID == 2 || header.MessageID == 3 </span><span class="cov0" title="0">{
                var positionReport ais.PositionReport = msg.Packet.(ais.PositionReport)

                ti.OnGround = true
                ti.Position_valid = true
                ti.Lat = float32(positionReport.Latitude)
                ti.Lng = float32(positionReport.Longitude)

                if positionReport.Sog &lt; 102.3 </span><span class="cov0" title="0">{
                        ti.Speed = uint16(positionReport.Sog) // I think Sog is in knt
                        ti.Speed_valid = true
                        ti.Last_speed = ti.Last_seen
                }</span>

                // We assume that when we have speed,
                // we also have a proper course over ground so we take that over heading.
                // Otherwise Track will be heading so boats will orient correctly
                <span class="cov0" title="0">if positionReport.Sog &gt; 0.0 &amp;&amp; positionReport.Sog &lt; 102.3 </span><span class="cov0" title="0">{
                        var cog float32 = 0.0
                        if positionReport.Cog != 360 </span><span class="cov0" title="0">{
                                cog = float32(positionReport.Cog)
                        }</span>
                        <span class="cov0" title="0">ti.Track = cog</span>
                } else<span class="cov0" title="0"> {
                        var heading float32 = 0.0
                        if positionReport.TrueHeading != 511 </span><span class="cov0" title="0">{
                                heading = float32(positionReport.TrueHeading)
                        }</span>
                        <span class="cov0" title="0">ti.Track = heading</span>
                }

                <span class="cov0" title="0">var rot float32 = 0.0
                if positionReport.RateOfTurn != -128 </span><span class="cov0" title="0">{
                        rot = float32(positionReport.RateOfTurn)
                }</span>
                <span class="cov0" title="0">ti.TurnRate = (rot / 4.733) * (rot / 4.733)

                ti.ExtrapolatedPosition = false</span>
        }

        // Prevent wild lat/long coordinates
        <span class="cov0" title="0">if ti.Lat &gt; 360 || ti.Lat &lt; -360 || ti.Lng &gt; 360 || ti.Lng &lt; -360 </span><span class="cov0" title="0">{
                return
        }</span>

        // Validate the position report
        <span class="cov0" title="0">if isGPSValid() &amp;&amp; (ti.Lat != 0 &amp;&amp; ti.Lng != 0) </span><span class="cov0" title="0">{
                ti.Distance, ti.Bearing = common.Distance(float64(mySituation.GPSLatitude), float64(mySituation.GPSLongitude), float64(ti.Lat), float64(ti.Lng))
                ti.BearingDist_valid = true
        }</span>

        // Do not display targets more than 150km
        <span class="cov0" title="0">if ti.BearingDist_valid == false || ti.Distance &gt;= 150000 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">traffic[key] = ti
        postProcessTraffic(&amp;ti)   // This will not estimate distance for non ES sources, pffff
        registerTrafficUpdate(ti) // Sends this one to the web interface
        seenTraffic[key] = true

        if globalSettings.DEBUG </span><span class="cov0" title="0">{
                txt, _ := json.Marshal(ti)
                log.Printf("AIS traffic imported: " + string(txt))
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
        Copyright (c) 2015-2016 Christopher Young
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        network.go: Client networking routines, DHCP lease monitoring, queue management, ICMP monitoring.
*/

package main

import (
        "io"
        "log"
        "math/rand"
        "net"
        "strconv"
        "time"

        "github.com/tarm/serial"
        "tinygo.org/x/bluetooth"
)

// Connection interface where we will write data - no matter if UDP, Serial or TCP
type connection interface {
        GetConnectionKey() string // e.g. "192.168.10.22:12345" for udp, "TCP:192.168.10.22:12345" for TCP, "/dev/serialout0" for serialout
        MessageQueue() *MessageQueue
        Writer() io.Writer
        IsThrottled() bool
        IsSleeping() bool
        Capabilities() uint8
        GetDesiredPacketSize() int
        OnError(error)
        Close()
}

type networkConnection struct {
        Conn       *net.UDPConn
        Ip         string
        Port       uint32
        Capability uint8
        Queue      *MessageQueue `json:"-"` // don't store in settings

        LastPingResponse time.Time // last time the client responded
        LastPongResponse time.Time // last time the client responded
        LastUnreachable  time.Time // Last time the device sent an ICMP Unreachable packet.
        /*
                Sleep mode/throttle variables. "sleep mode" is actually now just a very reduced packet rate, since we don't know positively
                 when a client is ready to accept packets - we just assume so if we don't receive ICMP Unreachable packets in 5 secs.
        */
        SleepFlag bool // Whether or not this client has been marked as sleeping - only used for debugging
}

func (conn *networkConnection) MessageQueue() *MessageQueue <span class="cov0" title="0">{
        if conn.Queue == nil </span><span class="cov0" title="0">{
                conn.Queue = NewMessageQueue(1024)
        }</span>
        <span class="cov0" title="0">return conn.Queue</span>
}
func (conn *networkConnection) Writer() io.Writer <span class="cov0" title="0">{
        return conn.Conn
}</span>

/*
isThrottled().

        Checks if a client identifier 'ip:port' is throttled.
        Throttle mode is for testing port open and giving some start-up time to the app.
        Throttling means that we only send important packets for first 15 seconds (location, status, very close traffic).
*/
func (conn *networkConnection) IsThrottled() bool <span class="cov0" title="0">{
        return (rand.Int()%1000 != 0) &amp;&amp; stratuxClock.Since(conn.LastUnreachable) &lt; (15*time.Second)
}</span>

/*
isSleeping().

        Check if a client identifier 'ip:port' is in either a sleep or active state.
*/
func (conn *networkConnection) IsSleeping() bool <span class="cov0" title="0">{
        // Unable to listen to ICMP without root - send to everything. Just for debugging.
        if isX86DebugMode() || globalSettings.NoSleep == true </span><span class="cov0" title="0">{
                return false
        }</span>
        // No ping response. Assume disconnected/sleeping device.
        <span class="cov0" title="0">if conn.LastPongResponse.IsZero() || stratuxClock.Since(conn.LastPongResponse) &gt; (10*time.Second) </span><span class="cov0" title="0">{
                conn.SleepFlag = true
        }</span> else<span class="cov0" title="0"> if conn.LastPingResponse.IsZero() || stratuxClock.Since(conn.LastPingResponse) &gt; (10*time.Second) </span><span class="cov0" title="0">{
                conn.SleepFlag = true
        }</span> else<span class="cov0" title="0"> if stratuxClock.Since(conn.LastUnreachable) &lt; (5 * time.Second) </span><span class="cov0" title="0">{
                conn.SleepFlag = true
        }</span> else<span class="cov0" title="0"> {
                conn.SleepFlag = false
        }</span>
        <span class="cov0" title="0">return conn.SleepFlag</span>
}

func (conn *networkConnection) Capabilities() uint8 <span class="cov0" title="0">{
        return conn.Capability
}</span>

func (conn *networkConnection) GetDesiredPacketSize() int <span class="cov0" title="0">{
        if conn.Capabilities()&amp;(NETWORK_POSITION_FFSIM|NETWORK_AHRS_FFSIM) &gt; 0 </span><span class="cov0" title="0">{
                // Hack: some software doesn't handle X-Plane as a stream correctly, e.g. SkyDemon, and requires each message in a separate packet, or it will crash.
                return 1
        }</span>
        <span class="cov0" title="0">return 1024</span>
}

func (conn *networkConnection) OnError(err error) {<span class="cov0" title="0">
        // Ignore for UDP. We keep the socket always open and just try to push data
        //log.Printf("UDP Write error: %s", err.Error())
}</span>

func (conn *networkConnection) Close() {<span class="cov0" title="0">
        // Ignore for UDP. We keep the socket always open and just try to push data
}</span>

func (conn *networkConnection) GetConnectionKey() string <span class="cov0" title="0">{
        return conn.Ip + ":" + strconv.Itoa(int(conn.Port))
}</span>

type serialConnection struct {
        DeviceString string
        Baud         int
        Capability   uint8
        serialPort   *serial.Port
        Queue        *MessageQueue `json:"-"` // don't store in settings
}

func (conn *serialConnection) MessageQueue() *MessageQueue <span class="cov0" title="0">{
        if conn.Queue == nil </span><span class="cov0" title="0">{
                conn.Queue = NewMessageQueue(1024)
        }</span>
        <span class="cov0" title="0">return conn.Queue</span>
}

func (conn *serialConnection) Writer() io.Writer <span class="cov0" title="0">{
        return conn.serialPort
}</span>
func (conn *serialConnection) IsThrottled() bool <span class="cov0" title="0">{
        return false
}</span>
func (conn *serialConnection) IsSleeping() bool <span class="cov0" title="0">{
        return conn.serialPort == nil
}</span>

func (conn *serialConnection) Capabilities() uint8 <span class="cov0" title="0">{
        return conn.Capability
}</span>

func (conn *serialConnection) GetDesiredPacketSize() int <span class="cov0" title="0">{
        return 128
}</span>

func (conn *serialConnection) OnError(err error) <span class="cov0" title="0">{
        // Close connection and queue
        log.Printf("Serial connection %s closed: %s", conn.DeviceString, err.Error())
        conn.Close()
}</span>

func (conn *serialConnection) Close() <span class="cov0" title="0">{
        if conn.serialPort != nil </span><span class="cov0" title="0">{
                conn.serialPort.Close()
                log.Printf("Closed serial port %s", conn.DeviceString)
                conn.Queue.Close()
                onConnectionClosed(conn)
        }</span>
}

func (conn *serialConnection) GetConnectionKey() string <span class="cov0" title="0">{
        return conn.DeviceString
}</span>

type tcpConnection struct {
        Conn       *net.TCPConn
        Queue      *MessageQueue `json:"-"`
        Capability uint8
        Key        string
}

func (conn *tcpConnection) MessageQueue() *MessageQueue <span class="cov0" title="0">{
        if conn.Queue == nil </span><span class="cov0" title="0">{
                conn.Queue = NewMessageQueue(1024)
        }</span>
        <span class="cov0" title="0">return conn.Queue</span>
}

func (conn *tcpConnection) Writer() io.Writer <span class="cov0" title="0">{
        return conn.Conn
}</span>
func (conn *tcpConnection) IsThrottled() bool <span class="cov0" title="0">{
        return false
}</span>
func (conn *tcpConnection) IsSleeping() bool <span class="cov0" title="0">{
        return conn.Conn == nil
}</span>
func (conn *tcpConnection) Capabilities() uint8 <span class="cov0" title="0">{
        return conn.Capability
}</span>
func (conn *tcpConnection) GetDesiredPacketSize() int <span class="cov0" title="0">{
        return 512
}</span>

func (conn *tcpConnection) OnError(err error) <span class="cov0" title="0">{
        // Close connection and queue
        if conn.Conn != nil </span><span class="cov0" title="0">{
                log.Printf("TCP connection %s closed: %s", conn.Conn.RemoteAddr(), err.Error())
                conn.Close()
        }</span>
}

func (conn *tcpConnection) Close() <span class="cov0" title="0">{
        // Close connection and queue
        if conn.Conn != nil </span><span class="cov0" title="0">{
                conn.Conn.Close()
                conn.Conn = nil
                conn.Queue.Close()
                onConnectionClosed(conn)
        }</span>
}

func (conn *tcpConnection) GetConnectionKey() string <span class="cov0" title="0">{
        return conn.Key
}</span>

type bleConnection struct {
        Capability     uint8
        UUIDService    string // SoftRF: 0xFFE0
        UUIDGatt       string
        Characteristic bluetooth.Characteristic
        Queue          *MessageQueue `json:"-"` // don't store in settings
}

func (conn *bleConnection) MessageQueue() *MessageQueue <span class="cov0" title="0">{
        if conn.Queue == nil </span><span class="cov0" title="0">{
                conn.Queue = NewMessageQueue(1024)
        }</span>
        <span class="cov0" title="0">return conn.Queue</span>
}

func (conn *bleConnection) Writer() io.Writer <span class="cov0" title="0">{
        return conn
}</span>

func (conn *bleConnection) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        return conn.Characteristic.Write(p)
}</span>

func (conn *bleConnection) IsThrottled() bool <span class="cov0" title="0">{
        return false
}</span>
func (conn *bleConnection) IsSleeping() bool <span class="cov0" title="0">{
        return false
}</span>

func (conn *bleConnection) Capabilities() uint8 <span class="cov0" title="0">{
        return conn.Capability
}</span>

func (conn *bleConnection) GetDesiredPacketSize() int <span class="cov0" title="0">{
        return 20 // TODO
}</span>

func (conn *bleConnection) OnError(err error) <span class="cov0" title="0">{
        // Close connection and queue
        log.Printf("BLE Error %s", err.Error())
}</span>

func (conn *bleConnection) Close() {<span class="cov0" title="0">
}</span>

func (conn *bleConnection) GetConnectionKey() string <span class="cov0" title="0">{
        return conn.UUIDService
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
        Copyright (c) 2024 Adrian Batzill
        Distributable under the terms of The "BSD New"" License
        that can be found in the LICENSE file, herein included
        as part of this header.
        flarm-nmea.go: Functions for generating FLARM-related NMEA sentences
                to communicate traffic bearing / distance to glider computers
                and UK / EU oriented EFBs.
        Accept cursor on target events on UDP port 8087
*/

package main

import (
        "encoding/json"
        "encoding/xml"
        "hash/fnv"
        "log"
        "net"
        "strings"
        "time"
)

type CotEvent struct {
        Version string    `xml:"version,attr"`
        Uid     string    `xml:"uid,attr"`
        Type_   string    `xml:"type,attr"`
        Time    string    `xml:"time,attr"`
        Start   string    `xml:"start,attr"`
        Stale   string    `xml:"stale,attr"`
        Point   CotPoint  `xml:"point"`
        Detail  CotDetail `xml:"detail"`
}

type CotPoint struct {
        Lat float32 `xml:"lat,attr"`
        Lon float32 `xml:"lon,attr"`
        Hae float32 `xml:"hae,attr"`
        //ce float32  `xml:"ce,attr"`
        //ce float32  `xml:"le,attr"`
}

type CotDetail struct {
        Track CotTrack `xml:"track"`
}

type CotTrack struct {
        Speed  float32 `xml:"speed,attr"`
        Course float32 `xml:"course,attr"`
}

func cotListen() <span class="cov0" title="0">{
        server, err := net.ListenPacket("udp", ":8087")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("cotListen() failed to listen on udp:8087. cot support disabled")
                return
        }</span>
        <span class="cov0" title="0">messageBuf := ""
        buf := make([]byte, 2048)
        for </span><span class="cov0" title="0">{
                n, _, err := server.ReadFrom(buf)
                if err != nil || n == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">messageBuf += string(buf[0:n])
                startIndex := strings.Index(messageBuf, "&lt;event")
                endIndex := strings.Index(messageBuf, "&lt;/event&gt;")
                if startIndex &gt;= 0 &amp;&amp; endIndex &gt; 0 </span><span class="cov0" title="0">{
                        msg := messageBuf[startIndex : endIndex+8]
                        processCotMessage(msg)
                        messageBuf = messageBuf[endIndex+8:]
                }</span>

        }
}

func processCotMessage(msg string) <span class="cov0" title="0">{
        var event CotEvent
        err := xml.Unmarshal([]byte(msg), &amp;event)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to parse COT event: " + msg)
                return
        }</span>
        <span class="cov0" title="0">if event.Point.Lat == 0 &amp;&amp; event.Point.Lon == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Ugly.. we just use the lower 24 bit of the hash of the uid to generate an address
        <span class="cov0" title="0">hasher := fnv.New32a()
        hasher.Write([]byte(event.Uid))
        addr := hasher.Sum32()
        addr = addr &amp; 0x00FFFFFF
        key := 1&lt;&lt;24 | addr // mark as non-icao

        var ti TrafficInfo

        trafficMutex.Lock()
        defer trafficMutex.Unlock()

        if existingTi, ok := traffic[key]; ok </span><span class="cov0" title="0">{
                ti = existingTi
        }</span>
        <span class="cov0" title="0">ti.Addr_type = 1
        ti.Icao_addr = addr
        ti.Timestamp = time.Now()
        ti.Lat = event.Point.Lat
        ti.Lng = event.Point.Lon
        ti.Position_valid = true
        ti.Reg = event.Uid
        ti.Tail = event.Uid
        ti.Last_source = TRAFFIC_SOURCE_OGN // TODO: properly implement TRAFFIC_SOURCE_COT
        ti.Age = 0
        ti.AgeLastAlt = 0
        ti.Last_seen = stratuxClock.Time
        ti.Speed = uint16(event.Detail.Track.Speed * 1.94384449) // m/s to kts
        ti.Speed_valid = ti.Speed != 0
        ti.Track = event.Detail.Track.Course

        // convert altitudes..
        alt := event.Point.Hae * 3.28084 // to feet
        if isGPSValid() &amp;&amp; isTempPressValid() </span><span class="cov0" title="0">{
                ti.Alt = int32(alt - mySituation.GPSAltitudeMSL + mySituation.BaroPressureAltitude)
                ti.AltIsGNSS = false
        }</span> else<span class="cov0" title="0"> {
                // Fall back to GNSS alt
                ti.Alt = int32(alt)
                ti.AltIsGNSS = true
        }</span>

        <span class="cov0" title="0">traffic[key] = ti

        postProcessTraffic(&amp;ti)
        registerTrafficUpdate(ti)
        seenTraffic[key] = true

        if globalSettings.DEBUG </span><span class="cov0" title="0">{
                txt, _ := json.Marshal(ti)
                log.Printf("COT traffic imported: " + string(txt))
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
        Copyright (c) 2015-2016 Christopher Young
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        datalog.go: Log stratux data as it is received. Bucket data into timestamp time slots.

*/

package main

import (
        "database/sql"
        "errors"
        "fmt"
        "log"
        "os"
        "reflect"
        "strconv"
        "strings"
        "time"

        _ "github.com/mattn/go-sqlite3"
)

const (
        LOG_TIMESTAMP_RESOLUTION = 250 * time.Millisecond
)

type StratuxTimestamp struct {
        id                   int64
        Time_type_preference int // 0 = stratuxClock, 1 = gpsClock, 2 = gpsClock extrapolated via stratuxClock.
        StratuxClock_value   time.Time
        GPSClock_value       time.Time // The value of this is either from the GPS or extrapolated from the GPS via stratuxClock if pref is 1 or 2. It is time.Time{} if 0.
        PreferredTime_value  time.Time
        StartupID            int64
}

// 'startup' table creates a new entry each time the daemon is started. This keeps track of sequential starts, even if the
//
//        timestamp is ambiguous (units with no GPS). This struct is just a placeholder for an empty table (other than primary key).
type StratuxStartup struct {
        id   int64
        Fill string
}

var dataLogStarted bool
var dataLogReadyToWrite bool

var stratuxStartupID int64
var dataLogTimestamps []StratuxTimestamp
var dataLogCurTimestamp int64 // Current timestamp bucket. This is an index on dataLogTimestamps which is not necessarily the db id.

/*
        checkTimestamp().
                Verify that our current timestamp is within the LOG_TIMESTAMP_RESOLUTION bucket.
                 Returns false if the timestamp was changed, true if it is still valid.
                 This is where GPS timestamps are extrapolated, if the GPS data is currently valid.
*/

func checkTimestamp() bool <span class="cov0" title="0">{
        thisCurTimestamp := dataLogCurTimestamp
        if stratuxClock.Since(dataLogTimestamps[thisCurTimestamp].StratuxClock_value) &gt;= LOG_TIMESTAMP_RESOLUTION </span><span class="cov0" title="0">{
                var ts StratuxTimestamp
                ts.id = 0
                ts.Time_type_preference = 0 // stratuxClock.
                ts.StratuxClock_value = stratuxClock.Time
                ts.GPSClock_value = time.Time{}
                ts.PreferredTime_value = stratuxClock.Time

                // Extrapolate from GPS timestamp, if possible.
                if isGPSClockValid() &amp;&amp; thisCurTimestamp &gt; 0 </span><span class="cov0" title="0">{
                        // Was the last timestamp either extrapolated or GPS time?
                        last_ts := dataLogTimestamps[thisCurTimestamp]
                        if last_ts.Time_type_preference == 1 || last_ts.Time_type_preference == 2 </span><span class="cov0" title="0">{
                                // Extrapolate via stratuxClock.
                                timeSinceLastTS := ts.StratuxClock_value.Sub(last_ts.StratuxClock_value) // stratuxClock ticks since last timestamp.
                                extrapolatedGPSTimestamp := last_ts.PreferredTime_value.Add(timeSinceLastTS)

                                // Re-set the preferred timestamp type to '2' (extrapolated time).
                                ts.Time_type_preference = 2
                                ts.PreferredTime_value = extrapolatedGPSTimestamp
                                ts.GPSClock_value = extrapolatedGPSTimestamp
                        }</span>
                }

                <span class="cov0" title="0">dataLogTimestamps = append(dataLogTimestamps, ts)
                dataLogCurTimestamp = int64(len(dataLogTimestamps) - 1)
                return false</span>
        }
        <span class="cov0" title="0">return true</span>
}

type SQLiteMarshal struct {
        FieldType string
        Marshal   func(v reflect.Value) string
}

func boolMarshal(v reflect.Value) string <span class="cov3" title="3">{
        b := v.Bool()
        if b </span><span class="cov2" title="2">{
                return "1"
        }</span>
        <span class="cov1" title="1">return "0"</span>
}

func intMarshal(v reflect.Value) string <span class="cov6" title="10">{
        return strconv.FormatInt(v.Int(), 10)
}</span>

func uintMarshal(v reflect.Value) string <span class="cov5" title="8">{
        return strconv.FormatUint(v.Uint(), 10)
}</span>

func floatMarshal(v reflect.Value) string <span class="cov5" title="7">{
        return strconv.FormatFloat(v.Float(), 'f', 10, 64)
}</span>

func stringMarshal(v reflect.Value) string <span class="cov5" title="6">{
        return v.String()
}</span>

func notsupportedMarshal(v reflect.Value) string <span class="cov2" title="2">{
        return ""
}</span>

func structCanBeMarshalled(v reflect.Value) bool <span class="cov5" title="7">{
        m := v.MethodByName("String")
        if m.IsValid() &amp;&amp; !m.IsNil() </span><span class="cov4" title="5">{
                return true
        }</span>
        <span class="cov2" title="2">return false</span>
}

func structMarshal(v reflect.Value) string <span class="cov4" title="4">{
        if structCanBeMarshalled(v) </span><span class="cov3" title="3">{
                m := v.MethodByName("String")
                in := make([]reflect.Value, 0)
                ret := m.Call(in)
                if len(ret) &gt; 0 </span><span class="cov3" title="3">{
                        return ret[0].String()
                }</span>
        }
        <span class="cov1" title="1">return ""</span>
}

var sqliteMarshalFunctions = map[string]SQLiteMarshal{
        "bool":         {FieldType: "INTEGER", Marshal: boolMarshal},
        "int":          {FieldType: "INTEGER", Marshal: intMarshal},
        "uint":         {FieldType: "INTEGER", Marshal: uintMarshal},
        "float":        {FieldType: "REAL", Marshal: floatMarshal},
        "string":       {FieldType: "TEXT", Marshal: stringMarshal},
        "struct":       {FieldType: "STRING", Marshal: structMarshal},
        "notsupported": {FieldType: "notsupported", Marshal: notsupportedMarshal},
}

var sqlTypeMap = map[reflect.Kind]string{
        reflect.Bool:          "bool",
        reflect.Int:           "int",
        reflect.Int8:          "int",
        reflect.Int16:         "int",
        reflect.Int32:         "int",
        reflect.Int64:         "int",
        reflect.Uint:          "uint",
        reflect.Uint8:         "uint",
        reflect.Uint16:        "uint",
        reflect.Uint32:        "uint",
        reflect.Uint64:        "uint",
        reflect.Uintptr:       "notsupported",
        reflect.Float32:       "float",
        reflect.Float64:       "float",
        reflect.Complex64:     "notsupported",
        reflect.Complex128:    "notsupported",
        reflect.Array:         "notsupported",
        reflect.Chan:          "notsupported",
        reflect.Func:          "notsupported",
        reflect.Interface:     "notsupported",
        reflect.Map:           "notsupported",
        reflect.Ptr:           "notsupported",
        reflect.Slice:         "notsupported",
        reflect.String:        "string",
        reflect.Struct:        "struct",
        reflect.UnsafePointer: "notsupported",
}

func makeTable(i interface{}, tbl string, db *sql.DB) <span class="cov0" title="0">{
        val := reflect.ValueOf(i)

        fields := make([]string, 0)
        for i := 0; i &lt; val.NumField(); i++ </span><span class="cov0" title="0">{
                kind := val.Field(i).Kind()
                fieldName := val.Type().Field(i).Name
                sqlTypeAlias := sqlTypeMap[kind]

                // Check that if the field is a struct that it can be marshalled.
                if sqlTypeAlias == "struct" &amp;&amp; !structCanBeMarshalled(val.Field(i)) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if sqlTypeAlias == "notsupported" || fieldName == "id" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">sqlType := sqliteMarshalFunctions[sqlTypeAlias].FieldType
                s := fieldName + " " + sqlType
                fields = append(fields, s)</span>
        }

        // Add the timestamp_id field to link up with the timestamp table.
        <span class="cov0" title="0">if tbl != "timestamp" &amp;&amp; tbl != "startup" </span><span class="cov0" title="0">{
                fields = append(fields, "timestamp_id INTEGER")
        }</span>

        <span class="cov0" title="0">tblCreate := fmt.Sprintf("CREATE TABLE %s (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, %s)", tbl, strings.Join(fields, ", "))

        _, err := db.Exec(tblCreate)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("ERROR: %s\n", err.Error())
        }</span>
}

/*
        bulkInsert().
                Reads insertBatch and insertBatchIfs. This is called after a group of insertData() calls.
*/

func bulkInsert(tbl string, db *sql.DB) (res sql.Result, err error) <span class="cov0" title="0">{
        if _, ok := insertString[tbl]; !ok </span><span class="cov0" title="0">{
                return nil, errors.New("no insert statement")
        }</span>

        <span class="cov0" title="0">batchVals := insertBatchIfs[tbl]
        numColsPerRow := len(batchVals[0])
        maxRowBatch := int(999 / numColsPerRow) // SQLITE_MAX_VARIABLE_NUMBER = 999.
        //        log.Printf("table %s. %d cols per row. max batch %d\n", tbl, numColsPerRow, maxRowBatch)
        for len(batchVals) &gt; 0 </span><span class="cov0" title="0">{
                //     timeInit := time.Now()
                i := int(0) // Variable number of rows per INSERT statement.

                stmt := ""
                vals := make([]interface{}, 0)
                querySize := uint64(0)                                            // Size of the query in bytes.
                for len(batchVals) &gt; 0 &amp;&amp; i &lt; maxRowBatch &amp;&amp; querySize &lt; 750000 </span><span class="cov0" title="0">{ // Maximum of 1,000,000 bytes per query.
                        if len(stmt) == 0 </span><span class="cov0" title="0">{ // The first set will be covered by insertString.
                                stmt = insertString[tbl]
                                querySize += uint64(len(insertString[tbl]))
                        }</span> else<span class="cov0" title="0"> {
                                addStr := ", (" + strings.Join(strings.Split(strings.Repeat("?", len(batchVals[0])), ""), ",") + ")"
                                stmt += addStr
                                querySize += uint64(len(addStr))
                        }</span>
                        <span class="cov0" title="0">for _, val := range batchVals[0] </span><span class="cov0" title="0">{
                                querySize += uint64(len(val.(string)))
                        }</span>
                        <span class="cov0" title="0">vals = append(vals, batchVals[0]...)
                        batchVals = batchVals[1:]
                        i++</span>
                }
                //                log.Printf("inserting %d rows to %s. querySize=%d\n", i, tbl, querySize)
                <span class="cov0" title="0">res, err = db.Exec(stmt, vals...)
                //      timeBatch := time.Since(timeInit)                                                                                                                     // debug
                //      log.Printf("SQLite: bulkInserted %d rows to %s. Took %f msec to build and insert query. querySize=%d\n", i, tbl, 1000*timeBatch.Seconds(), querySize) // debug
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("sqlite INSERT error: '%s'\n", err.Error())
                        return
                }</span>
        }

        // Clear the buffers.
        <span class="cov0" title="0">delete(insertString, tbl)
        delete(insertBatchIfs, tbl)

        return</span>
}

/*
        insertData().
                Inserts an arbitrary struct into an SQLite table.
                 Inserts the timestamp first, if its 'id' is 0.

*/

// Cached 'VALUES' statements. Indexed by table name.
var insertString map[string]string // INSERT INTO tbl (col1, col2, ...) VALUES(?, ?, ...). Only for one value.
var insertBatchIfs map[string][][]interface{}

func insertData(i interface{}, tbl string, db *sql.DB, ts_num int64) int64 <span class="cov0" title="0">{
        val := reflect.ValueOf(i)

        keys := make([]string, 0)
        values := make([]string, 0)
        for i := 0; i &lt; val.NumField(); i++ </span><span class="cov0" title="0">{
                kind := val.Field(i).Kind()
                fieldName := val.Type().Field(i).Name
                sqlTypeAlias := sqlTypeMap[kind]

                if sqlTypeAlias == "notsupported" || fieldName == "id" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">v := sqliteMarshalFunctions[sqlTypeAlias].Marshal(val.Field(i))

                keys = append(keys, fieldName)
                values = append(values, v)</span>
        }

        // Add the timestamp_id field to link up with the timestamp table.
        <span class="cov0" title="0">if tbl != "timestamp" &amp;&amp; tbl != "startup" </span><span class="cov0" title="0">{
                keys = append(keys, "timestamp_id")
                if dataLogTimestamps[ts_num].id == 0 </span><span class="cov0" title="0">{
                        //FIXME: This is somewhat convoluted. When insertData() is called for a ts_num that corresponds to a timestamp with no database id,
                        // then it inserts that timestamp via the same interface and the id is updated in the structure via the below lines
                        // (dataLogTimestamps[ts_num].id = id).
                        dataLogTimestamps[ts_num].StartupID = stratuxStartupID
                        insertData(dataLogTimestamps[ts_num], "timestamp", db, ts_num) // Updates dataLogTimestamps[ts_num].id.
                }</span>
                <span class="cov0" title="0">values = append(values, strconv.FormatInt(dataLogTimestamps[ts_num].id, 10))</span>
        }

        <span class="cov0" title="0">if _, ok := insertString[tbl]; !ok </span><span class="cov0" title="0">{
                // Prepare the statement.
                tblInsert := fmt.Sprintf("INSERT INTO %s (%s) VALUES(%s)", tbl, strings.Join(keys, ","),
                        strings.Join(strings.Split(strings.Repeat("?", len(keys)), ""), ","))
                insertString[tbl] = tblInsert
        }</span>

        // Make the values slice into a slice of interface{}.
        <span class="cov0" title="0">ifs := make([]interface{}, len(values))
        for i := 0; i &lt; len(values); i++ </span><span class="cov0" title="0">{
                ifs[i] = values[i]
        }</span>

        <span class="cov0" title="0">insertBatchIfs[tbl] = append(insertBatchIfs[tbl], ifs)

        if tbl == "timestamp" || tbl == "startup" </span><span class="cov0" title="0">{ // Immediate insert always for "timestamp" and "startup" table.
                res, err := bulkInsert(tbl, db) // Bulk insert of 1, always.
                if err == nil </span><span class="cov0" title="0">{
                        id, err := res.LastInsertId()
                        if err == nil &amp;&amp; tbl == "timestamp" </span><span class="cov0" title="0">{ // Special handling for timestamps. Update the timestamp ID.
                                ts := dataLogTimestamps[ts_num]
                                ts.id = id
                                dataLogTimestamps[ts_num] = ts
                        }</span>
                        <span class="cov0" title="0">return id</span>
                }
        }

        <span class="cov0" title="0">return 0</span>
}

type DataLogRow struct {
        tbl    string
        data   interface{}
        ts_num int64
}

var dataLogChan chan DataLogRow
var shutdownDataLog chan bool
var shutdownDataLogWriter chan bool

var dataLogWriteChan chan DataLogRow

func dataLogWriter(db *sql.DB) <span class="cov0" title="0">{
        dataLogWriteChan = make(chan DataLogRow, 10240)
        shutdownDataLogWriter = make(chan bool)
        // The write queue. As data comes in via dataLogChan, it is timestamped and stored.
        //  When writeTicker comes up, the queue is emptied.
        writeTicker := time.NewTicker(10 * time.Second)
        rowsQueuedForWrite := make([]DataLogRow, 0)
        for </span><span class="cov0" title="0">{
                select </span>{
                case r := &lt;-dataLogWriteChan:<span class="cov0" title="0">
                        // Accept timestamped row.
                        rowsQueuedForWrite = append(rowsQueuedForWrite, r)</span>
                case &lt;-writeTicker.C:<span class="cov0" title="0">
                        //                        for i := 0; i &lt; 1000; i++ {
                        //                                logSituation()
                        //                        }
                        timeStart := stratuxClock.Time
                        nRows := len(rowsQueuedForWrite)
                        if globalSettings.DEBUG </span><span class="cov0" title="0">{
                                log.Printf("Writing %d rows\n", nRows)
                        }</span>
                        // Write the buffered rows. This will block while it is writing.
                        // Save the names of the tables affected so that we can run bulkInsert() on after the insertData() calls.
                        <span class="cov0" title="0">tblsAffected := make(map[string]bool)
                        // Start transaction.
                        tx, err := db.Begin()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("db.Begin() error: %s\n", err.Error())
                                break</span> // from select {}
                        }
                        <span class="cov0" title="0">for _, r := range rowsQueuedForWrite </span><span class="cov0" title="0">{
                                tblsAffected[r.tbl] = true
                                insertData(r.data, r.tbl, db, r.ts_num)
                        }</span>
                        // Do the bulk inserts.
                        <span class="cov0" title="0">for tbl, _ := range tblsAffected </span><span class="cov0" title="0">{
                                bulkInsert(tbl, db)
                        }</span>
                        // Close the transaction.
                        <span class="cov0" title="0">tx.Commit()
                        rowsQueuedForWrite = make([]DataLogRow, 0) // Zero the queue.
                        timeElapsed := stratuxClock.Since(timeStart)
                        if globalSettings.DEBUG </span><span class="cov0" title="0">{
                                rowsPerSecond := float64(nRows) / float64(timeElapsed.Seconds())
                                log.Printf("Writing finished. %d rows in %.2f seconds (%.1f rows per second).\n", nRows, float64(timeElapsed.Seconds()), rowsPerSecond)
                        }</span>
                        <span class="cov0" title="0">if timeElapsed.Seconds() &gt; 10.0 </span><span class="cov0" title="0">{
                                log.Printf("WARNING! SQLite logging is behind. Last write took %.1f seconds.\n", float64(timeElapsed.Seconds()))
                                dataLogCriticalErr := fmt.Errorf("WARNING! SQLite logging is behind. Last write took %.1f seconds.\n", float64(timeElapsed.Seconds()))
                                addSystemError(dataLogCriticalErr)
                        }</span>
                case &lt;-shutdownDataLogWriter:<span class="cov0" title="0"> // Received a message on the channel to initiate a graceful shutdown, and to command dataLog() to shut down
                        log.Printf("datalog.go: dataLogWriter() received shutdown message with rowsQueuedForWrite = %d\n", len(rowsQueuedForWrite))
                        shutdownDataLog &lt;- true
                        return</span>
                }
        }
}

func dataLog() <span class="cov0" title="0">{
        dataLogStarted = true
        log.Printf("datalog.go: dataLog() started\n")
        dataLogChan = make(chan DataLogRow, 10240)
        shutdownDataLog = make(chan bool)
        dataLogTimestamps = make([]StratuxTimestamp, 0)
        var ts StratuxTimestamp
        ts.id = 0
        ts.Time_type_preference = 0 // stratuxClock.
        ts.StratuxClock_value = stratuxClock.Time
        ts.GPSClock_value = time.Time{}
        ts.PreferredTime_value = stratuxClock.Time
        dataLogTimestamps = append(dataLogTimestamps, ts)
        dataLogCurTimestamp = 0

        // Check if we need to create a new database.
        createDatabase := false

        if _, err := os.Stat(dataLogFilef); os.IsNotExist(err) </span><span class="cov0" title="0">{
                createDatabase = true
                log.Printf("creating new database '%s'.\n", dataLogFilef)
        }</span>

        <span class="cov0" title="0">db, err := sql.Open("sqlite3", dataLogFilef)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("sql.Open(): %s\n", err.Error())
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                db.Close()
                dataLogStarted = false
                //close(dataLogChan)
                log.Printf("datalog.go: dataLog() has closed DB in %s\n", dataLogFilef)
        }</span>()

        <span class="cov0" title="0">_, err = db.Exec("PRAGMA journal_mode=WAL")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("db.Exec('PRAGMA journal_mode=WAL') err: %s\n", err.Error())
        }</span>
        <span class="cov0" title="0">_, err = db.Exec("PRAGMA synchronous=OFF")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("db.Exec('PRAGMA journal_mode=WAL') err: %s\n", err.Error())
        }</span>

        //log.Printf("Starting dataLogWriter\n") // REMOVE -- DEBUG
        <span class="cov0" title="0">go dataLogWriter(db)

        // Do we need to create the database?
        if createDatabase </span><span class="cov0" title="0">{
                makeTable(StratuxTimestamp{}, "timestamp", db)
                makeTable(mySituation, "mySituation", db)
                makeTable(globalStatus, "status", db)
                makeTable(globalSettings, "settings", db)
                makeTable(TrafficInfo{}, "traffic", db)
                makeTable(msg{}, "messages", db)
                makeTable(esmsg{}, "es_messages", db)
                makeTable(Dump1090TermMessage{}, "dump1090_terminal", db)
                makeTable(gpsPerfStats{}, "gps_attitude", db)
                makeTable(StratuxStartup{}, "startup", db)
        }</span>

        // The first entry to be created is the "startup" entry.
        <span class="cov0" title="0">stratuxStartupID = insertData(StratuxStartup{}, "startup", db, 0)

        dataLogReadyToWrite = true
        //log.Printf("Entering dataLog read loop\n") //REMOVE -- DEBUG
        for </span><span class="cov0" title="0">{
                select </span>{
                case r := &lt;-dataLogChan:<span class="cov0" title="0">
                        // When data is input, the first step is to timestamp it.
                        // Check if our time bucket has expired or has never been entered.
                        checkTimestamp()
                        // Mark the row with the current timestamp ID, in case it gets entered later.
                        r.ts_num = dataLogCurTimestamp
                        // Queue it for the scheduled write.
                        dataLogWriteChan &lt;- r</span>
                case &lt;-shutdownDataLog:<span class="cov0" title="0"> // Received a message on the channel to complete a graceful shutdown (see the 'defer func()...' statement above).
                        log.Printf("datalog.go: dataLog() received shutdown message\n")
                        return</span>
                }
        }
}

/*
        setDataLogTimeWithGPS().
                Create a timestamp entry using GPS time.
*/

func setDataLogTimeWithGPS(sit SituationData) <span class="cov0" title="0">{
        if dataLogStarted &amp;&amp; isGPSClockValid() </span><span class="cov0" title="0">{
                var ts StratuxTimestamp
                // Piggyback a GPS time update from this update.
                ts.id = 0
                ts.Time_type_preference = 1 // gpsClock.
                ts.StratuxClock_value = stratuxClock.Time
                ts.GPSClock_value = sit.GPSTime
                ts.PreferredTime_value = sit.GPSTime

                dataLogTimestamps = append(dataLogTimestamps, ts)
                dataLogCurTimestamp = int64(len(dataLogTimestamps) - 1)
        }</span>
}

/*
        logSituation(), logStatus(), ... pass messages from other functions to the logging
                engine. These are only read into `dataLogChan` if the Replay Log is toggled on,
                and if the log system is ready to accept writes.
*/

func isDataLogReady() bool <span class="cov0" title="0">{
        return dataLogReadyToWrite
}</span>

func logSituation() <span class="cov0" title="0">{
        if globalSettings.ReplayLog &amp;&amp; isDataLogReady() </span><span class="cov0" title="0">{
                dataLogChan &lt;- DataLogRow{tbl: "mySituation", data: mySituation}
        }</span>
}

func logStatus() <span class="cov0" title="0">{
        if globalSettings.ReplayLog &amp;&amp; isDataLogReady() </span><span class="cov0" title="0">{
                dataLogChan &lt;- DataLogRow{tbl: "status", data: globalStatus}
        }</span>
}

func logSettings() <span class="cov0" title="0">{
        if globalSettings.ReplayLog &amp;&amp; isDataLogReady() </span><span class="cov0" title="0">{
                dataLogChan &lt;- DataLogRow{tbl: "settings", data: globalSettings}
        }</span>
}

func logTraffic(ti TrafficInfo) <span class="cov0" title="0">{
        if globalSettings.ReplayLog &amp;&amp; isDataLogReady() </span><span class="cov0" title="0">{
                dataLogChan &lt;- DataLogRow{tbl: "traffic", data: ti}
        }</span>
}

func logMsg(m msg) <span class="cov0" title="0">{
        if globalSettings.ReplayLog &amp;&amp; isDataLogReady() </span><span class="cov0" title="0">{
                dataLogChan &lt;- DataLogRow{tbl: "messages", data: m}
        }</span>
}

func logESMsg(m esmsg) <span class="cov10" title="48">{
        if globalSettings.ReplayLog &amp;&amp; isDataLogReady() </span><span class="cov0" title="0">{
                dataLogChan &lt;- DataLogRow{tbl: "es_messages", data: m}
        }</span>
}

func logGPSAttitude(gpsPerf gpsPerfStats) <span class="cov0" title="0">{
        if globalSettings.ReplayLog &amp;&amp; isDataLogReady() </span><span class="cov0" title="0">{
                dataLogChan &lt;- DataLogRow{tbl: "gps_attitude", data: gpsPerf}
        }</span>
}

func logDump1090TermMessage(m Dump1090TermMessage) <span class="cov0" title="0">{
        if globalSettings.DEBUG &amp;&amp; globalSettings.ReplayLog &amp;&amp; isDataLogReady() </span><span class="cov0" title="0">{
                dataLogChan &lt;- DataLogRow{tbl: "dump1090_terminal", data: m}
        }</span>
}

func logPongTermMessage(m PongTermMessage) <span class="cov0" title="0">{
        if globalSettings.DEBUG &amp;&amp; globalSettings.ReplayLog &amp;&amp; isDataLogReady() </span><span class="cov0" title="0">{
                dataLogChan &lt;- DataLogRow{tbl: "pong_update", data: m}
        }</span>
}

func logAISTermMessage(m AISTermMessage) <span class="cov0" title="0">{
        if globalSettings.DEBUG &amp;&amp; globalSettings.ReplayLog &amp;&amp; isDataLogReady() </span><span class="cov0" title="0">{
                dataLogChan &lt;- DataLogRow{tbl: "ais_message", data: m}
        }</span>
}

func initDataLog() <span class="cov0" title="0">{
        //log.Printf("dataLogStarted = %t. dataLogReadyToWrite = %t\n", dataLogStarted, dataLogReadyToWrite) //REMOVE -- DEBUG
        insertString = make(map[string]string)
        insertBatchIfs = make(map[string][][]interface{})
        go dataLogWatchdog()

        //log.Printf("datalog.go: initDataLog() complete.\n") //REMOVE -- DEBUG
}</span>

/*
        dataLogWatchdog(): Watchdog function to control startup / shutdown of data logging subsystem.
                Called by initDataLog as a goroutine. It iterates once per second to determine if
                globalSettings.ReplayLog has toggled. If logging was switched from off to on, it starts
                datalog() as a goroutine. If the log is running and we want it to stop, it calls
                closeDataLog() to turn off the input channels, close the log, and tear down the dataLog
                and dataLogWriter goroutines.
*/

func dataLogWatchdog() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if !dataLogStarted &amp;&amp; globalSettings.ReplayLog </span><span class="cov0" title="0">{ // case 1: sqlite logging isn't running, and we want to start it
                        log.Printf("datalog.go: Watchdog wants to START logging.\n")
                        go dataLog()
                }</span> else<span class="cov0" title="0"> if dataLogStarted &amp;&amp; !globalSettings.ReplayLog </span><span class="cov0" title="0">{ // case 2:  sqlite logging is running, and we want to shut it down
                        log.Printf("datalog.go: Watchdog wants to STOP logging.\n")
                        closeDataLog()
                }</span>
                //log.Printf("Watchdog iterated.\n") //REMOVE -- DEBUG
                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
                //log.Printf("Watchdog sleep over.\n") //REMOVE -- DEBUG
        }
}

/*
        closeDataLog(): Handler for graceful shutdown of data logging goroutines. It is called by
                by dataLogWatchdog(), gracefulShutdown(), and by any other function (disk space monitor?)
                that needs to be able to shut down sqlite logging without corrupting data or blocking
                execution.

                This function turns off log message reads into the dataLogChan receiver, and sends a
                message to a quit channel ('shutdownDataLogWriter`) in dataLogWriter(). dataLogWriter()
                then sends a message to a quit channel to 'shutdownDataLog` in dataLog() to close *that*
                goroutine. That function sets dataLogStarted=false once the logfile is closed. By waiting
                for that signal, closeDataLog() won't exit until the log is safely written. This prevents
                data loss on shutdown.
*/

func closeDataLog() <span class="cov0" title="0">{
        //log.Printf("closeDataLog(): dataLogStarted = %t\n", dataLogStarted) //REMOVE -- DEBUG
        dataLogReadyToWrite = false // prevent any new messages from being sent down the channels
        log.Printf("datalog.go: Starting data log shutdown\n")
        shutdownDataLogWriter &lt;- true      //
        defer close(shutdownDataLogWriter) // ... and close the channel so subsequent accidental writes don't stall execution
        log.Printf("datalog.go: Waiting for shutdown signal from dataLog()")
        for dataLogStarted </span><span class="cov0" title="0">{
                //log.Printf("closeDataLog(): dataLogStarted = %t\n", dataLogStarted) //REMOVE -- DEBUG
                time.Sleep(50 * time.Millisecond)
        }</span>
        <span class="cov0" title="0">log.Printf("datalog.go: Data log shutdown successful.\n")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
        Copyright (c) 2020 Keith Tschohl, Adrian Batzill
        Distributable under the terms of The "BSD New"" License
        that can be found in the LICENSE file, herein included
        as part of this header.
        flarm-nmea.go: Functions for generating FLARM-related NMEA sentences
                to communicate traffic bearing / distance to glider computers
                and UK / EU oriented EFBs.
        Additional functions to parse NMEA from external Flarm GPS Mouse/SoftRF
*/

package main

import (
        "encoding/binary"
        "encoding/hex"
        "fmt"
        "log"
        "math"
        "strconv"
        "strings"
        "time"

        "github.com/stratux/stratux/common"
)

/*
        sendNetFLARM() is a shortcut to network.go 'sendMsg()', and will send the referenced byte slice to the UDP network port
                defined by NETWORK_FLARM_NMEA in gen_gdl90.go as a non-queueable message to be used in XCSoar. It will also queue
                the message into a channel so it can be        sent out to a TCP server.
*/

// Append checksum and to nmea string
func appendNmeaChecksum(nmea string) string <span class="cov4" title="9">{
        start := 0
        if len(nmea) &gt; 0 &amp;&amp; nmea[0] == '$' </span><span class="cov3" title="4">{
                start = 1
        }</span>
        <span class="cov4" title="9">checksum := byte(0x00)
        for i := start; i &lt; len(nmea); i++ </span><span class="cov10" title="209">{
                checksum = checksum ^ byte(nmea[i])
        }</span>
        <span class="cov4" title="9">return fmt.Sprintf("%s*%02X", nmea, checksum)</span>
}

func makeFlarmPFLAUString(ti TrafficInfo) (msg string) <span class="cov0" title="0">{
        // syntax: PFLAU,&lt;RX&gt;,&lt;TX&gt;,&lt;GPS&gt;,&lt;Power&gt;,&lt;AlarmLevel&gt;,&lt;RelativeBearing&gt;,&lt;AlarmType&gt;,&lt;RelativeVertical&gt;,&lt;RelativeDistance&gt;,&lt;ID&gt;
        gpsStatus := 0
        if isGPSValid() </span><span class="cov0" title="0">{
                gpsStatus = 2
        }</span>

        <span class="cov0" title="0">dist, bearing, _, _ := common.DistRect(float64(mySituation.GPSLatitude), float64(mySituation.GPSLongitude), float64(ti.Lat), float64(ti.Lng))
        relativeVertical := computeRelativeVertical(ti)
        alarmLevel := computeAlarmLevel(dist, relativeVertical)

        // make bearing relative to ground track, with +-180deg
        bearing = bearing - float64(mySituation.GPSTrueCourse)
        if bearing &gt; 180 </span><span class="cov0" title="0">{
                bearing = bearing - 360
        }</span>
        <span class="cov0" title="0">if bearing &lt; -180 </span><span class="cov0" title="0">{
                bearing = bearing + 360
        }</span>

        <span class="cov0" title="0">alarmType := 0
        if alarmLevel &gt; 0 </span><span class="cov0" title="0">{
                alarmType = 2
        }</span>

        <span class="cov0" title="0">idstr := fmt.Sprintf("%.6X", ti.Icao_addr&amp;0xFFFFFF)
        if len(ti.Tail) &gt; 0 </span><span class="cov0" title="0">{
                idstr += "!" + ti.Tail
        }</span>
        // TODO: we are always airbourne for now
        <span class="cov0" title="0">if alarmLevel &gt; 0 </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("$PFLAU,%d,1,%d,1,%d,%d,%d,%d,%d,%s", len(traffic), gpsStatus, alarmLevel, int32(bearing), alarmType, relativeVertical, int32(math.Abs(dist)), idstr)
        }</span> else<span class="cov0" title="0"> {
                msg = fmt.Sprintf("$PFLAU,%d,1,%d,1,0,,0,,,", len(traffic), gpsStatus)
        }</span>
        <span class="cov0" title="0">msg = appendNmeaChecksum(msg)
        msg += "\r\n"
        return</span>
}

// TODO: only very simplistic implementation
func computeAlarmLevel(dist float64, relativeVertical int32) (alarmLevel uint8) <span class="cov6" title="21">{
        if (dist &lt; 926) &amp;&amp; (relativeVertical &lt; 152) &amp;&amp; (relativeVertical &gt; -152) </span><span class="cov4" title="6">{ // 926 m = 0.5 NM; 152m = 500'
                alarmLevel = 3
        }</span> else<span class="cov5" title="15"> if (dist &lt; 1852) &amp;&amp; (relativeVertical &lt; 304) &amp;&amp; (relativeVertical &gt; -304) </span><span class="cov4" title="10">{ // 1852 m = 1.0 NM ; 304 m = 1000'
                alarmLevel = 2
        }</span> else<span class="cov3" title="5"> {
                alarmLevel = 0
        }</span>
        <span class="cov6" title="21">return</span>
}

func computeRelativeVertical(ti TrafficInfo) (relativeVertical int32) <span class="cov0" title="0">{
        altf := mySituation.BaroPressureAltitude
        if !isTempPressValid() &amp;&amp; isGPSValid() </span><span class="cov0" title="0">{ // if no pressure altitude available, use GPS altitude
                altf = mySituation.GPSAltitudeMSL
        }</span>
        <span class="cov0" title="0">if ti.AltIsGNSS &amp;&amp; isGPSValid() </span><span class="cov0" title="0">{
                // Altitude coming from OGN. We set the geoid separation to 0 in the OGN config, so OGN reports ellipsoid alt - we need to compare to that
                altf = mySituation.GPSHeightAboveEllipsoid
        }</span>
        <span class="cov0" title="0">relativeVertical = int32(float32(ti.Alt)*0.3048 - altf*0.3048) // convert to meters
        return</span>
}

func gdl90EmitterCatToNMEA(emitterCat uint8) string <span class="cov5" title="16">{
        acType := "0"
        switch emitterCat </span>{
        case 1, 6:<span class="cov2" title="2">
                acType = "8"</span> // light/"highly maneuverable &gt; 5g" = piston
        case 2, 3, 4, 5:<span class="cov2" title="3">
                acType = "9"</span> // small/large/heavy = jet
        case 7:<span class="cov1" title="1">
                acType = "3"</span> // helicopter = helicopter
        case 9:<span class="cov1" title="1">
                acType = "1"</span> // glider = glider
        case 10:<span class="cov1" title="1">
                acType = "B"</span> // lighter than air = balloon
        case 11:<span class="cov1" title="1">
                acType = "4"</span> // skydiver/parachute = sky diver
        case 12:<span class="cov1" title="1">
                acType = "7"</span> // paraglider, hanglider
        case 14:<span class="cov1" title="1">
                acType = "D"</span> // UAV
        case 17, 18:<span class="cov2" title="2">
                acType = "E"</span> // Surface vehicle-&gt;Ground support (not in dataport spec, but OGN extension?)
        case 19:<span class="cov1" title="1">
                acType = "F"</span> // static object / point obstacle
        }
        <span class="cov5" title="16">return acType</span>
}

func nmeaAircraftTypeToGdl90(actype string) uint8 <span class="cov5" title="17">{
        acTypeInt, err := strconv.ParseInt(actype, 16, 8)
        if err != nil </span><span class="cov1" title="1">{
                return 0
        }</span>
        <span class="cov5" title="16">cat := uint8(0)
        switch acTypeInt </span>{
        case 1:<span class="cov1" title="1">
                cat = 9</span> // glider = glider
        case 2, 5, 8:<span class="cov2" title="3">
                cat = 1</span> // tow, drop, piston = light
        case 3:<span class="cov1" title="1">
                cat = 7</span> // helicopter = helicopter
        case 4:<span class="cov1" title="1">
                cat = 11</span> // skydiver
        case 6, 7:<span class="cov2" title="2">
                cat = 12</span> // hang glider / paraglider
        case 9:<span class="cov1" title="1">
                cat = 3</span> // jet = large
        case 0xB, 0xC:<span class="cov2" title="2">
                cat = 10</span> // Balloon, airship = lighter than air
        case 0xD:<span class="cov2" title="2">
                cat = 14</span> // UAV=UAV
        case 0xE:<span class="cov1" title="1">
                cat = 18</span> // Ground support = surface vehicle (OGN extension?)
        case 0xF:<span class="cov1" title="1">
                cat = 19</span> // point obstacle=static object
        }
        <span class="cov5" title="16">return cat</span>
}

/*
        makeFlarmPFLAAString() creates a NMEA-formatted PFLAA string (FLARM traffic format) with checksum from the referenced
                traffic object.
*/

func makeFlarmPFLAAString(ti TrafficInfo) (msg string, valid bool, alarmLevel uint8) <span class="cov0" title="0">{

        /*        Format: $PFLAA,&lt;AlarmLevel&gt;,&lt;RelativeNorth&gt;,&lt;RelativeEast&gt;,&lt;RelativeVertical&gt;,&lt;IDType&gt;,&lt;ID&gt;,&lt;Track&gt;,&lt;TurnRate&gt;,&lt;GroundSpeed&gt;, &lt;ClimbRate&gt;,&lt;AcftType&gt;*&lt;checksum&gt;
                            $PFLAA,0,-10687,-22561,-10283,1,A4F2EE,136,0,269,0.0,0*4E
                        &lt;AlarmLevel&gt;  Decimal integer value. Range: from 0 to 3.
                                                        Alarm level as assessed by FLARM:
                                                        0 = no alarm (also used for no-alarm traffic information)
                                                        1 = alarm, 13-18 seconds to impact
                                                        2 = alarm, 9-12 seconds to impact
                                                        3 = alarm, 0-8 seconds to impact
                        &lt;RelativeNorth&gt;,&lt;RelativeEast&gt;,&lt;RelativeVertical&gt; are distances in meters. Decimal integer value. Range: from -32768 to 32767.
                                For traffic without known bearing, assign estimated distance to &lt;RelativeNorth&gt; and leave &lt;RelativeEast&gt; empty
                        &lt;IDType&gt;: 1 = official ICAO 24-bit aircraft address; 2 = stable FLARM ID (chosen by FLARM) 3 = anonymous ID, used if stealth mode is activated.
                        For ADS-B traffic, we'll always pick 1.
                        &lt;ID&gt;: 6-digit hexadecimal value (e.g. 5A77B1) as configured in the targets PFLAC,,ID sentence. For ADS-B targets always use reported 24-bit ICAO address.
                                        NOTE: Appending "!CALLSIGN" may allow certain
                        &lt;Track&gt;: Decimal integer value. Range: from 0 to 359. The targets true ground track in degrees.
                        &lt;TurnRate&gt;: Not used. Empty field.
                        &lt;GroundSpeed&gt;: Decimal integer value. Range: from 0 to 32767. The targets ground speed in m/s
                        &lt;ClimbRate&gt;: Decimal fixed point number with one digit after the radix point (dot). Range: from -32.7 to 32.7. The targets climb rate in m/s.
                        Positive values indicate a climbing aircraft.
                        &lt;AcftType&gt;: Hexadecimal value. Range: from 0 to F.
                                                        Aircraft types:
                                                        0 = unknown
                                                        1 = glider / motor glider
                                                        2 = tow / tug plane
                                                        3 = helicopter / rotorcraft
                                                        4 = skydiver
                                                        5 = drop plane for skydivers
                                                        6 = hang glider (hard)
                                                        7 = paraglider (soft)
                                                        8 = aircraft with reciprocating engine(s)
                                                        9 = aircraft with jet/turboprop engine(s)
                                                        A = unknown
                                                        B = balloon
                                                        C = airship
                                                        D = unmanned aerial vehicle (UAV)
                                                        E = unknown
                                                        F = static object
        */

        var idType uint8
        var relativeNorth, relativeEast, relativeVertical, groundSpeed int32

        // Addr type "NON-ICAO" mapped to Flarm ID, rest mapped to ICAO.
        // Especially SkyDemon is picky and only accepts NMEA messages with 0-2, but nothing else.
        if ti.Addr_type == 1 </span><span class="cov0" title="0">{
                idType = 2
        }</span> else<span class="cov0" title="0"> {
                idType = 1
        }</span>

        // determine distance and bearing to target
        <span class="cov0" title="0">dist, bearing, distN, distE := common.DistRect(float64(mySituation.GPSLatitude), float64(mySituation.GPSLongitude), float64(ti.Lat), float64(ti.Lng))
        if !ti.Position_valid </span><span class="cov0" title="0">{
                dist = ti.DistanceEstimated
                distN = ti.DistanceEstimated
        }</span>
        <span class="cov0" title="0">if globalSettings.DEBUG </span><span class="cov0" title="0">{
                log.Printf("FLARM - ICAO target %X (%s) is %.1f meters away at %.1f degrees\n", ti.Icao_addr, ti.Tail, dist, bearing)
        }</span>

        // TODO: Estimate distance for bearingless / distanceless Mode S (1090) aircraft targets

        //if distN &gt; 200000 || distN &lt; -200000 || distE &gt; 200000 || distE &lt; -200000 {
        //        msg = ""
        //        valid = false
        //        return
        //} else {
        <span class="cov0" title="0">relativeNorth = int32(distN)
        relativeEast = int32(distE)
        //}

        relativeVertical = computeRelativeVertical(ti)
        alarmLevel = computeAlarmLevel(dist, relativeVertical)

        if ti.Speed_valid </span><span class="cov0" title="0">{
                groundSpeed = int32(float32(ti.Speed) * 0.5144) // convert to m/s
        }</span>

        <span class="cov0" title="0">acType := gdl90EmitterCatToNMEA(ti.Emitter_category)

        climbRate := float32(ti.Vvel) * 0.3048 / 60 // convert to m/s

        idstr := fmt.Sprintf("%.6X", ti.Icao_addr&amp;0xFFFFFF)
        if len(ti.Tail) &gt; 0 </span><span class="cov0" title="0">{
                idstr += "!" + ti.Tail
        }</span>

        <span class="cov0" title="0">if ti.Position_valid </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("$PFLAA,%d,%d,%d,%d,%d,%s,%d,%d,%d,%0.1f,%s", alarmLevel, relativeNorth, relativeEast, relativeVertical, idType, idstr, uint16(ti.Track), uint16(ti.TurnRate), groundSpeed, climbRate, acType)
        }</span> else<span class="cov0" title="0"> {
                msg = fmt.Sprintf("$PFLAA,%d,%d,,%d,%d,%s,,,,%0.1f,%s", alarmLevel, int32(math.Abs(dist)), relativeVertical, idType, idstr, climbRate, acType) // prototype for bearingless traffic
        }</span>
        //msg = fmt.Sprintf("PFLAA,%d,%d,%d,%d,%d,%X!%s,%d,,%d,%0.1f,%d", alarmLevel, relativeNorth, relativeEast, relativeVertical, idType, ti.Icao_addr, ti.Tail, ti.Track, groundSpeed, climbRate, acType)
        <span class="cov0" title="0">msg = appendNmeaChecksum(msg)
        msg += "\r\n"

        valid = true
        return</span>
}

/*
        makeGPRMCString() creates a NMEA-formatted GPRMC string (GPS recommended minimum data) with checksum from the current GPS position.
                If current position is invalid, the GPRMC string will indicate no-fix.
*/

func makeGPRMCString() string <span class="cov0" title="0">{
        /*
                                 RMC          Recommended Minimum sentence C
                             123519       Fix taken at 12:35:19 UTC
                             A            Status A=active or V=Void.
                             4807.038,N   Latitude 48 deg 07.038' N
                             01131.000,E  Longitude 11 deg 31.000' E
                             022.4        Speed over the ground in knots
                             084.4        Track angle in degrees True
                             230394       Date - 23rd of March 1994
                             003.1,W      Magnetic Variation
                             D                                mode field (nmea 2.3 and higher)
                             *6A          The checksum data, always begins with *
                LastFixSinceMidnightUTC uint32
                Lat                     float32
                Lng                     float32
                Quality                 uint8
                GeoidSep                float32 // geoid separation, ft, MSL minus HAE (used in altitude calculation)
                Satellites              uint16  // satellites used in solution
                SatellitesTracked       uint16  // satellites tracked (almanac data received)
                SatellitesSeen          uint16  // satellites seen (signal received)
                Accuracy                float32 // 95% confidence for horizontal position, meters.
                NACp                    uint8   // NACp categories are defined in AC 20-165A
                Alt                     float32 // Feet MSL
                AccuracyVert            float32 // 95% confidence for vertical position, meters
                GPSVertVel              float32 // GPS vertical velocity, feet per second
                LastFixLocalTime        time.Time
                TrueCourse              uint16
                GroundSpeed             uint16
                LastGroundTrackTime     time.Time
        */

        lastFix := float64(mySituation.GPSLastFixSinceMidnightUTC)
        hr := math.Floor(lastFix / 3600)
        lastFix -= 3600 * hr
        mins := math.Floor(lastFix / 60)
        sec := lastFix - mins*60

        status := "V"
        if isGPSValid() &amp;&amp; mySituation.GPSFixQuality &gt; 0 </span><span class="cov0" title="0">{
                status = "A"
        }</span>

        <span class="cov0" title="0">lat := float64(mySituation.GPSLatitude)
        ns := "N"
        if lat &lt; 0 </span><span class="cov0" title="0">{
                lat = -lat
                ns = "S"
        }</span>

        <span class="cov0" title="0">deg := math.Floor(lat)
        min := (lat - deg) * 60
        lat = deg*100 + min

        ew := "E"
        lng := float64(mySituation.GPSLongitude)
        if lng &lt; 0 </span><span class="cov0" title="0">{
                lng = -lng
                ew = "W"
        }</span>

        <span class="cov0" title="0">deg = math.Floor(lng)
        min = (lng - deg) * 60
        lng = deg*100 + min

        gs := float32(mySituation.GPSGroundSpeed)
        trueCourse := float32(mySituation.GPSTrueCourse)
        yy, mm, dd := time.Now().UTC().Date()
        yy = yy % 100
        var magVar, mvEW string
        mode := "N"
        if mySituation.GPSFixQuality == 1 </span><span class="cov0" title="0">{
                mode = "A"
        }</span> else<span class="cov0" title="0"> if mySituation.GPSFixQuality == 2 </span><span class="cov0" title="0">{
                mode = "D"
        }</span>

        <span class="cov0" title="0">var msg string

        if isGPSValid() </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("$GPRMC,%02.f%02.f%05.2f,%s,%010.5f,%s,%011.5f,%s,%.1f,%.1f,%02d%02d%02d,%s,%s,%s", hr, mins, sec, status, lat, ns, lng, ew, gs, trueCourse, dd, mm, yy, magVar, mvEW, mode)
        }</span> else<span class="cov0" title="0"> {
                msg = fmt.Sprintf("$GPRMC,,%s,,,,,,,%02d%02d%02d,%s,%s,%s", status, dd, mm, yy, magVar, mvEW, mode) // return null lat-lng and velocity if invalid GPS
        }</span>
        <span class="cov0" title="0">msg = appendNmeaChecksum(msg)
        msg += "\r\n"
        return msg</span>
}

func makeGPGGAString() string <span class="cov0" title="0">{
        /*
         xxGGA
         time
         lat (degmin.mmm)
         NS
         long (degmin.mmm)
         EW
         quality
         numSV
         HDOP
         alt
         ualt
         sep
         uSep
         diffAge
         diffStation
        */

        thisSituation := mySituation
        lastFix := float64(thisSituation.GPSLastFixSinceMidnightUTC)
        hr := math.Floor(lastFix / 3600)
        lastFix -= 3600 * hr
        mins := math.Floor(lastFix / 60)
        sec := lastFix - mins*60

        lat := float64(mySituation.GPSLatitude)
        ns := "N"
        if lat &lt; 0 </span><span class="cov0" title="0">{
                lat = -lat
                ns = "S"
        }</span>

        <span class="cov0" title="0">deg := math.Floor(lat)
        min := (lat - deg) * 60
        lat = deg*100 + min

        ew := "E"
        lng := float64(mySituation.GPSLongitude)
        if lng &lt; 0 </span><span class="cov0" title="0">{
                lng = -lng
                ew = "W"
        }</span>

        <span class="cov0" title="0">deg = math.Floor(lng)
        min = (lng - deg) * 60
        lng = deg*100 + min

        numSV := thisSituation.GPSSatellites
        //if numSV &gt; 12 {
        //        numSV = 12
        //}

        //hdop := float32(thisSituation.Accuracy / 4.0)
        //if hdop &lt; 0.7 {hdop = 0.7}
        hdop := 1.0

        alt := thisSituation.GPSAltitudeMSL / 3.28084
        geoidSep := thisSituation.GPSGeoidSep / 3.28084

        var msg string

        if isGPSValid() </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("$GPGGA,%02.f%02.f%05.2f,%010.5f,%s,%011.5f,%s,%d,%d,%.2f,%.1f,M,%.1f,M,,", hr, mins, sec, lat, ns, lng, ew, thisSituation.GPSFixQuality, numSV, hdop, alt, geoidSep)
        }</span> else<span class="cov0" title="0"> {
                msg = fmt.Sprintf("$GPGGA,,,,,,0,%d,,,,,,,", numSV)
        }</span>

        <span class="cov0" title="0">msg = appendNmeaChecksum(msg)
        msg += "\r\n"
        return msg</span>

}

func makePGRMZString() string <span class="cov0" title="0">{
        msg := fmt.Sprintf("$PGRMZ,%d,f,3", int(mySituation.BaroPressureAltitude))
        msg = appendNmeaChecksum(msg)
        msg += "\r\n"
        return msg
}</span>

func makeAHRSLevilReport() <span class="cov0" title="0">{
        if !globalStatus.IMUConnected || !isAHRSValid() </span><span class="cov0" title="0">{
                return
        }</span>
        // Values if invalid
        <span class="cov0" title="0">roll := int16(0)
        pitch := int16(0)
        hdg := int16(mySituation.GPSTrueCourse) // TODO: not really correct, but XCSoar doesn't accept empty string
        slip_skid := int16(0)
        yaw_rate := int16(mySituation.GPSTurnRate) // TODO: not really correct, but XCSoar doesn't accept empty string
        g := int16(0)
        if !isAHRSInvalidValue(mySituation.AHRSRoll) </span><span class="cov0" title="0">{
                roll = common.RoundToInt16(mySituation.AHRSRoll * 10)
        }</span>
        <span class="cov0" title="0">if !isAHRSInvalidValue(mySituation.AHRSPitch) </span><span class="cov0" title="0">{
                pitch = common.RoundToInt16(mySituation.AHRSPitch * 10)
        }</span>
        <span class="cov0" title="0">if !isAHRSInvalidValue(mySituation.AHRSGyroHeading) </span><span class="cov0" title="0">{
                hdg = common.RoundToInt16(mySituation.AHRSGyroHeading * 10)
        }</span>
        <span class="cov0" title="0">if !isAHRSInvalidValue(mySituation.AHRSSlipSkid) </span><span class="cov0" title="0">{
                slip_skid = common.RoundToInt16(-mySituation.AHRSSlipSkid * 10)
        }</span>
        <span class="cov0" title="0">if !isAHRSInvalidValue(mySituation.AHRSTurnRate) </span><span class="cov0" title="0">{
                yaw_rate = common.RoundToInt16(mySituation.AHRSTurnRate * 10)
        }</span>
        <span class="cov0" title="0">if !isAHRSInvalidValue(mySituation.AHRSGLoad) </span><span class="cov0" title="0">{
                g = common.RoundToInt16(mySituation.AHRSGLoad * 1000)
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("$RPYL,%d,%d,%d,%d,%d,%d,0", roll, pitch, hdg, slip_skid, yaw_rate, g)
        appendNmeaChecksum(msg)
        sendNetFLARM(msg+"\r\n", 100*time.Millisecond, 4)</span>
}

func atof32(val string) float32 <span class="cov5" title="13">{
        res, _ := strconv.ParseFloat(val, 32)
        return float32(res)
}</span>

// Read data from a raw $PFLAU/$PFLAA message (i.e. when serial flarm device is connected)
func parseFlarmNmeaMessage(message []string) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing NMEA " + strings.Join(message, ","))
                }</span>
        }()

        <span class="cov0" title="0">if message[0] == "PFLAU" </span><span class="cov0" title="0">{
                parseFlarmPFLAU(message)
        }</span> else<span class="cov0" title="0"> if message[0] == "PFLAA" </span><span class="cov0" title="0">{
                parseFlarmPFLAA(message)
        }</span>
}

func relativeGpsAltToBaro(relVert float32) (alt int32, altIsGnss bool) <span class="cov0" title="0">{
        if isTempPressValid() </span><span class="cov0" title="0">{
                return int32(mySituation.BaroPressureAltitude + relVert*3.28084), false
        }</span> else<span class="cov0" title="0"> if isGPSValid() </span><span class="cov0" title="0">{
                return int32(mySituation.GPSAltitudeMSL + relVert*3.28084), true
        }</span>
        <span class="cov0" title="0">return 0, false</span>
}

func getIdTail(idReceived string) (idStr string, tail string, address uint32) <span class="cov5" title="17">{
        ognIDAndTail := strings.Split(idReceived, "!")
        idStr = ognIDAndTail[0]
        if len(idStr) &gt; 6 </span><span class="cov2" title="3">{
                // OGN Tracker sometimes encodes address type in the address.. strip that
                idStr = idStr[len(idStr)-6:]
        }</span>
        <span class="cov5" title="17">tail = ""
        if len(ognIDAndTail) == 2 </span><span class="cov4" title="8">{
                tail = ognIDAndTail[1]
        }</span>
        // Some devices report ID as tail number, with a respective prefix. E.g. OGN_AAAAAA, FLR_BBBBBB, ....
        // Ignore that - it's not useful for us and we would rather check OGN DDB for a real tail number
        <span class="cov5" title="17">if len(tail) &gt; 4 &amp;&amp; tail[3] == '_' </span><span class="cov2" title="3">{
                tail = ""
        }</span>

        // Pad hex string with leading 0 if odd length (hex.DecodeString needs even length)
        <span class="cov5" title="17">hexStr := idStr
        if len(hexStr)%2 != 0 </span><span class="cov2" title="2">{
                hexStr = "0" + hexStr
        }</span>
        <span class="cov5" title="17">addressBytes, _ := hex.DecodeString(hexStr)
        // Pad to exactly 4 bytes by prepending zeros
        for len(addressBytes) &lt; 4 </span><span class="cov6" title="25">{
                addressBytes = append([]byte{0}, addressBytes...)
        }</span>
        <span class="cov5" title="17">address = binary.BigEndian.Uint32(addressBytes)

        return</span>
}

func parseFlarmPFLAU(message []string) <span class="cov0" title="0">{
        // $PFLAU,&lt;RX&gt;,&lt;TX&gt;,&lt;GPS&gt;,&lt;Power&gt;,&lt;AlarmLevel&gt;,&lt;RelativeBearing&gt;,&lt;AlarmType&gt;,&lt;RelativeVertical&gt;,&lt;RelativeDistance&gt;,&lt;ID&gt;
        if len(message) &lt; 11 </span><span class="cov0" title="0">{
                // PFLAU without ID is valid FLARM
                // log.Printf("Discarding invalid NMEA: " + strings.Join(message, ","))
                return
        }</span>
        <span class="cov0" title="0">if len(message[10]) == 0 || len(message[9]) == 0 || len(message[8]) == 0 || len(message[6]) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var thisMsg msg
        thisMsg.MessageClass = MSGCLASS_OGN
        thisMsg.TimeReceived = stratuxClock.Time
        msgLogAppend(thisMsg)

        if !isGPSValid() </span><span class="cov0" title="0">{
                return // can't convert relative to absolute without GPS
        }</span>

        <span class="cov0" title="0">ognID, tail, address := getIdTail(message[10])

        trafficBearing := int32(mySituation.GPSTrueCourse+atof32(message[6])) % 360
        if trafficBearing &lt; 0 </span><span class="cov0" title="0">{
                trafficBearing += 360
        }</span>
        <span class="cov0" title="0">relVertical := atof32(message[8])
        relDist := atof32(message[9])

        var ti TrafficInfo
        trafficMutex.Lock()
        defer trafficMutex.Unlock()

        // We don't know idType any more in PFLAU message.. just use anything we have.. Not optimal, but better than having multiple targets
        key := address
        existingTi, ok := traffic[key]
        key = 1&lt;&lt;24 | address
        if !ok </span><span class="cov0" title="0">{
                existingTi, ok = traffic[key]
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                if existingTi.Last_source == TRAFFIC_SOURCE_1090ES &amp;&amp; existingTi.Age &lt; 5 </span><span class="cov0" title="0">{
                        // traffic has FLARM and 1090ES and was seen via 1090ES recently?
                        // -&gt; ignore the flarm message. 1090ES has much less delay, so we prefer that.
                        return
                }</span>
                <span class="cov0" title="0">ti = existingTi</span>
        }
        <span class="cov0" title="0">ti.Icao_addr = address
        if len(ti.Tail) &lt;= 3 </span><span class="cov0" title="0">{
                if len(tail) != 0 </span><span class="cov0" title="0">{
                        // Tail provided via NMEA (IDIDID!TAIL syntax)
                        ti.Tail = tail
                }</span> else<span class="cov0" title="0"> {
                        // OGN DDB fallback
                        ti.Tail = getTailNumber(ognID, "FLR") // Might have better tail from ADS-B. Don't overwrite.
                }</span>
        }
        <span class="cov0" title="0">ti.Timestamp = time.Now().UTC()
        ti.Last_source = TRAFFIC_SOURCE_OGN
        ti.Alt, ti.AltIsGNSS = relativeGpsAltToBaro(relVertical)

        lat, lng := calcLocationForBearingDistance(float64(mySituation.GPSLatitude), float64(mySituation.GPSLongitude), float64(trafficBearing), float64(relDist/1852.0))
        ti.Lat = float32(lat)
        ti.Lng = float32(lng)
        ti.Distance = float64(relDist)
        ti.Bearing = float64(trafficBearing)
        ti.BearingDist_valid = true
        ti.Position_valid = true
        ti.ExtrapolatedPosition = false
        ti.Last_seen = stratuxClock.Time
        ti.Last_alt = stratuxClock.Time
        // update traffic database
        traffic[key] = ti

        // notify
        registerTrafficUpdate(ti)

        // mark traffic as seen
        seenTraffic[key] = true</span>
}

func parseFlarmPFLAA(message []string) <span class="cov0" title="0">{
        // $PFLAA,&lt;AlarmLevel&gt;,&lt;RelativeNorth&gt;,&lt;RelativeEast&gt;,&lt;RelativeVertical&gt;,&lt;IDType&gt;,&lt;ID&gt;,&lt;Track&gt;,&lt;TurnRate&gt;,&lt;GroundSpeed&gt;, &lt;ClimbRate&gt;,&lt;AcftType&gt;
        // Append flarm message to message log
        if len(message) &lt; 12 </span><span class="cov0" title="0">{
                log.Printf("Discarding invalid NMEA: " + strings.Join(message, ","))
                return
        }</span>
        <span class="cov0" title="0">var thisMsg msg
        thisMsg.MessageClass = MSGCLASS_OGN
        thisMsg.TimeReceived = stratuxClock.Time
        // thisMsg.Data = ...?
        msgLogAppend(thisMsg)

        relNorth := atof32(message[2])
        relEast := atof32(message[3])
        relVert := atof32(message[4])

        ognID, tail, address := getIdTail(message[6])
        idType, _ := strconv.ParseInt(message[5], 10, 8)
        if idType == 1 </span><span class="cov0" title="0">{
                idType = 0 // ICAO ID
        }</span> else<span class="cov0" title="0"> {
                idType = 1 // non-ICAO ID
        }</span>

        <span class="cov0" title="0">track := atof32(message[7])
        turn := atof32(message[8])
        speed := atof32(message[9])
        vspeed := atof32(message[10])
        acType := message[11]

        var ti TrafficInfo

        trafficMutex.Lock()
        defer trafficMutex.Unlock()

        // check if traffic is already known
        key := uint32(idType)&lt;&lt;24 | address
        if existingTi, ok := traffic[key]; ok </span><span class="cov0" title="0">{
                if existingTi.Last_source == TRAFFIC_SOURCE_1090ES &amp;&amp; existingTi.Age &lt; 5 </span><span class="cov0" title="0">{
                        // traffic has FLARM and 1090ES and was seen via 1090ES recently?
                        // -&gt; ignore the flarm message. 1090ES has much less delay, so we prefer that.
                        return
                }</span>

                <span class="cov0" title="0">ti = existingTi</span>
        }
        <span class="cov0" title="0">ti.Icao_addr = address
        // idType 1=ICAO, 2=Flarm ID, 3=anonymous ID. 0 is valid but not documented.
        // For us: 0=ICAO, 1=Non ICAO
        ti.Addr_type = uint8(idType)

        if len(ti.Tail) &lt;= 3 </span><span class="cov0" title="0">{
                if len(tail) != 0 </span><span class="cov0" title="0">{
                        // Tail provided via NMEA (IDIDID!TAIL syntax)
                        ti.Tail = tail
                }</span> else<span class="cov0" title="0"> {
                        // OGN DDB fallback
                        ti.Tail = getTailNumber(ognID, "FLR") // Might have better tail from ADS-B. Don't overwrite.
                }</span>
        }
        <span class="cov0" title="0">ti.Timestamp = time.Now().UTC()
        ti.Last_source = TRAFFIC_SOURCE_OGN
        ti.Alt, ti.AltIsGNSS = relativeGpsAltToBaro(relVert)

        // lat dist = 60nm = 111,12km
        ti.Lat = mySituation.GPSLatitude + (relNorth / 111120.0)
        avgLat := ti.Lat/2.0 + mySituation.GPSLatitude/2.0
        lngFactor := float32(111120.0 * math.Cos(common.Radians(float64(avgLat))))
        ti.Lng = mySituation.GPSLongitude + (relEast / lngFactor)

        if isGPSValid() </span><span class="cov0" title="0">{
                ti.Distance, ti.Bearing = common.Distance(float64(mySituation.GPSLatitude), float64(mySituation.GPSLongitude), float64(ti.Lat), float64(ti.Lng))
                ti.BearingDist_valid = true
        }</span>

        <span class="cov0" title="0">ti.Track = track
        ti.TurnRate = turn
        ti.Speed = uint16(speed * 1.94384) // m/s to knots
        ti.Speed_valid = true
        ti.Vvel = int16(vspeed * 196.85) // m/s to feet/min

        ti.Position_valid = true
        ti.ExtrapolatedPosition = false
        ti.Last_seen = stratuxClock.Time
        ti.Last_alt = stratuxClock.Time

        ti.Emitter_category = nmeaAircraftTypeToGdl90(acType)

        // update traffic database
        traffic[key] = ti

        // notify
        registerTrafficUpdate(ti)

        // mark traffic as seen
        seenTraffic[key] = true</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
        Copyright (c) 2015-2016 Christopher Young
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        gen_gdl90.go: Input demodulated UAT and 1090ES information, output GDL90. Heartbeat,
         ownship, status messages, stats collection.
*/

package main

import (
        "bufio"
        "compress/gzip"
        "encoding/hex"
        "encoding/json"
        "flag"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "math"
        "os"
        "os/exec"
        "os/signal"
        "path/filepath"
        "runtime"
        "runtime/pprof"
        "strconv"
        "strings"
        "sync"
        "syscall"
        "time"

        humanize "github.com/dustin/go-humanize"
        "github.com/ricochet2200/go-disk-usage/du"
        "github.com/stratux/stratux/common"
        "github.com/stratux/stratux/uatparse"
)

// https://www.faa.gov/nextgen/programs/adsb/Archival/
// https://www.faa.gov/nextgen/programs/adsb/Archival/media/GDL90_Public_ICD_RevA.PDF

var logDirf string      // Directory for all logging
var dataLogFilef string // Set according to OS config.

const (
        STRATUX_HOME          = "/opt/stratux"
        defaultManagementAddr = 80
        logDir                = "/var/log/"
        dataLogFile           = "stratux.sqlite"
        //FlightBox: log to /root.
        logDir_FB           = "/root/"
        maxDatagramSize     = 8192
        maxUserMsgQueueSize = 25000 // About 10MB per port per connected client.

        UPLINK_BLOCK_DATA_BITS  = 576
        UPLINK_BLOCK_BITS       = (UPLINK_BLOCK_DATA_BITS + 160)
        UPLINK_BLOCK_DATA_BYTES = (UPLINK_BLOCK_DATA_BITS / 8)
        UPLINK_BLOCK_BYTES      = (UPLINK_BLOCK_BITS / 8)

        UPLINK_FRAME_BLOCKS     = 6
        UPLINK_FRAME_DATA_BITS  = (UPLINK_FRAME_BLOCKS * UPLINK_BLOCK_DATA_BITS)
        UPLINK_FRAME_BITS       = (UPLINK_FRAME_BLOCKS * UPLINK_BLOCK_BITS)
        UPLINK_FRAME_DATA_BYTES = (UPLINK_FRAME_DATA_BITS / 8)
        UPLINK_FRAME_BYTES      = (UPLINK_FRAME_BITS / 8)

        // assume 6 byte frames: 2 header bytes, 4 byte payload
        // (TIS-B heartbeat with one address, or empty FIS-B APDU)
        UPLINK_MAX_INFO_FRAMES = (424 / 6)

        MSGTYPE_UPLINK       = 0x07
        MSGTYPE_BASIC_REPORT = 0x1E
        MSGTYPE_LONG_REPORT  = 0x1F

        MSGCLASS_UAT = 0
        MSGCLASS_ES  = 1
        MSGCLASS_OGN = 2
        MSGCLASS_AIS = 3

        LON_LAT_RESOLUTION = float32(180.0 / 8388608.0)
        TRACK_RESOLUTION   = float32(360.0 / 256.0)

        /*
                GPS_TYPE_NMEA     = 0x01
                GPS_TYPE_UBX      = 0x02
                GPS_TYPE_SIRF     = 0x03
                GPS_TYPE_MEDIATEK = 0x04
                GPS_TYPE_FLARM    = 0x05
                GPS_TYPE_GARMIN   = 0x06
        */

        // for historical reasons lower nibbe contains gps type, upper nibble containsprotocol type.
        // Additionally this enumeration has a javascript duplicte in web/plates/js/status.js, they have to be kept in sync manually
        // This is somewhat ugly but difficult to change without breaking backward compatibility

        // lower nibble gps type   (dont forget to use only numbers form 0 to 15)

        GPS_TYPE_ANY        = 1 // Any generic GPS - no reconfiguring applied
        GPS_TYPE_PROLIFIC   = 2
        GPS_TYPE_OGNTRACKER = 3
        GPS_TYPE_UBX_GEN    = 4
        GPS_TYPE_UBX10      = 5
        //GPS_TYPE_UBX6             = 6
        GPS_TYPE_UBX6or7       = 7
        GPS_TYPE_UBX8          = 8
        GPS_TYPE_UBX9          = 9
        GPS_TYPE_SERIAL        = 10 // 0x0A
        GPS_TYPE_SOFTRF_DONGLE = 11 // 0x0B
        GPS_TYPE_NETWORK       = 12 // 0x0C
        GPS_TYPE_SOFTRF        = 13
        GPS_TYPE_GXAIRCOM      = 15 // 0x0F

        // upper nibble is used for the protocol
        GPS_PROTOCOL_NMEA = 0x10
)

var STRATUX_WWW_DIR = STRATUX_HOME + "/www/"
var configLocation = "/boot/firmware/stratux.conf"
var configLocationDefault = "/opt/stratux/cfg/stratux.conf.default"

var maxSignalStrength int

var stratuxBuild string
var stratuxVersion string
var ManagementAddr = 0

var product_name_map = map[int]string{
        0:   "METAR",
        1:   "TAF",
        2:   "SIGMET",
        3:   "Conv SIGMET",
        4:   "AIRMET",
        5:   "PIREP",
        6:   "Severe Wx",
        7:   "Winds Aloft",
        8:   "NOTAM",           //"NOTAM (Including TFRs) and Service Status";
        9:   "D-ATIS",          //"Aerodrome and Airspace  D-ATIS";
        10:  "Terminal Wx",     //"Aerodrome and Airspace - TWIP";
        11:  "AIRMET",          //"Aerodrome and Airspace - AIRMET";
        12:  "SIGMET",          //"Aerodrome and Airspace - SIGMET/Convective SIGMET";
        13:  "SUA",             //"Aerodrome and Airspace - SUA Status";
        20:  "METAR",           //"METAR and SPECI";
        21:  "TAF",             //"TAF and Amended TAF";
        22:  "SIGMET",          //"SIGMET";
        23:  "Conv SIGMET",     //"Convective SIGMET";
        24:  "AIRMET",          //"AIRMET";
        25:  "PIREP",           //"PIREP";
        26:  "Severe Wx",       //"AWW";
        27:  "Winds Aloft",     //"Winds and Temperatures Aloft";
        51:  "NEXRAD",          //"National NEXRAD, Type 0 - 4 level";
        52:  "NEXRAD",          //"National NEXRAD, Type 1 - 8 level (quasi 6-level VIP)";
        53:  "NEXRAD",          //"National NEXRAD, Type 2 - 8 level";
        54:  "NEXRAD",          //"National NEXRAD, Type 3 - 16 level";
        55:  "NEXRAD",          //"Regional NEXRAD, Type 0 - low dynamic range";
        56:  "NEXRAD",          //"Regional NEXRAD, Type 1 - 8 level (quasi 6-level VIP)";
        57:  "NEXRAD",          //"Regional NEXRAD, Type 2 - 8 level";
        58:  "NEXRAD",          //"Regional NEXRAD, Type 3 - 16 level";
        59:  "NEXRAD",          //"Individual NEXRAD, Type 0 - low dynamic range";
        60:  "NEXRAD",          //"Individual NEXRAD, Type 1 - 8 level (quasi 6-level VIP)";
        61:  "NEXRAD",          //"Individual NEXRAD, Type 2 - 8 level";
        62:  "NEXRAD",          //"Individual NEXRAD, Type 3 - 16 level";
        63:  "NEXRAD Regional", //"Global Block Representation - Regional NEXRAD, Type 4  8 level";
        64:  "NEXRAD CONUS",    //"Global Block Representation - CONUS NEXRAD, Type 4 - 8 level";
        81:  "Tops",            //"Radar echo tops graphic, scheme 1: 16-level";
        82:  "Tops",            //"Radar echo tops graphic, scheme 2: 8-level";
        83:  "Tops",            //"Storm tops and velocity";
        101: "Lightning",       //"Lightning strike type 1 (pixel level)";
        102: "Lightning",       //"Lightning strike type 2 (grid element level)";
        151: "Lightning",       //"Point phenomena, vector format";
        201: "Surface",         //"Surface conditions/winter precipitation graphic";
        202: "Surface",         //"Surface weather systems";
        254: "G-AIRMET",        //"AIRMET, SIGMET: Bitmap encoding";
        351: "Time",            //"System Time";
        352: "Status",          //"Operational Status";
        353: "Status",          //"Ground Station Status";
        401: "Imagery",         //"Generic Raster Scan Data Product APDU Payload Format Type 1";
        402: "Text",
        403: "Vector Imagery", //"Generic Vector Data Product APDU Payload Format Type 1";
        404: "Symbols",
        405: "Text",
        411: "Text",    //"Generic Textual Data Product APDU Payload Format Type 1";
        412: "Symbols", //"Generic Symbolic Product APDU Payload Format Type 1";
        413: "Text",    //"Generic Textual Data Product APDU Payload Format Type 2";
}

// CRC16 table generated to use to work with GDL90 messages.
var Crc16Table [256]uint16

// Current AHRS, pressure altitude, etc.
var mySituation SituationData

type WriteCloser interface {
        io.Writer
        io.Closer
}

type ReadCloser interface {
        io.Reader
        io.Closer
}

type msg struct {
        MessageClass     uint
        TimeReceived     time.Time
        Data             string
        Products         []uint32
        Signal_amplitude int
        Signal_strength  float64
        ADSBTowerID      string // Index in the 'ADSBTowers' map, if this is a parseable uplink message.
        uatMsg           *uatparse.UATMsg
}

// Raw inputs.
var msgLog []msg
var msgLogMutex sync.Mutex

// Time stratuxrun was started.
var timeStarted time.Time

type RegionInfo struct {
        IsSet  bool
        Region string
}

var RegionSettings RegionInfo

type ADSBTower struct {
        Lat                         float64
        Lng                         float64
        Signal_strength_now         float64 // Current RSSI (dB)
        Signal_strength_max         float64 // all-time peak RSSI (dB) observed for this tower
        Energy_last_minute          uint64  // Summation of power observed for this tower across all messages last minute
        Signal_strength_last_minute float64 // Average RSSI (dB) observed for this tower last minute
        Messages_last_minute        uint64
}

var ADSBTowers map[string]ADSBTower // Running list of all towers seen. (lat,lng) -&gt; ADSBTower
var ADSBTowerMutex *sync.Mutex

// Construct the CRC table. Adapted from FAA ref above.
func crcInit() <span class="cov3" title="9">{
        var i uint16
        var bitctr uint16
        var crc uint16
        for i = 0; i &lt; 256; i++ </span><span class="cov8" title="2304">{
                crc = (i &lt;&lt; 8)
                for bitctr = 0; bitctr &lt; 8; bitctr++ </span><span class="cov10" title="18432">{
                        z := uint16(0)
                        if (crc &amp; 0x8000) != 0 </span><span class="cov9" title="9216">{
                                z = 0x1021
                        }</span>
                        <span class="cov10" title="18432">crc = (crc &lt;&lt; 1) ^ z</span>
                }
                <span class="cov8" title="2304">Crc16Table[i] = crc</span>
        }
}

// Compute CRC. Adapted from FAA ref above.
func crcCompute(data []byte) uint16 <span class="cov4" title="38">{
        ret := uint16(0)
        for i := 0; i &lt; len(data); i++ </span><span class="cov6" title="664">{
                ret = Crc16Table[ret&gt;&gt;8] ^ (ret &lt;&lt; 8) ^ uint16(data[i])
        }</span>
        <span class="cov4" title="38">return ret</span>
}

func prepareMessage(data []byte) []byte <span class="cov4" title="33">{
        // Compute CRC before modifying the message.
        crc := crcCompute(data)
        // Add the two CRC16 bytes before replacing control characters.
        data = append(data, byte(crc&amp;0xFF))
        data = append(data, byte(crc&gt;&gt;8))

        tmp := []byte{0x7E} // Flag start.

        // Copy the message over, escaping 0x7E (Flag Byte) and 0x7D (Control-Escape).
        for i := 0; i &lt; len(data); i++ </span><span class="cov7" title="714">{
                mv := data[i]
                if (mv == 0x7E) || (mv == 0x7D) </span><span class="cov3" title="12">{
                        mv = mv ^ 0x20
                        tmp = append(tmp, 0x7D)
                }</span>
                <span class="cov7" title="714">tmp = append(tmp, mv)</span>
        }

        <span class="cov4" title="33">tmp = append(tmp, 0x7E) // Flag end.

        return tmp</span>
}

func makeLatLng(v float32) []byte <span class="cov4" title="49">{
        ret := make([]byte, 3)

        v = v / LON_LAT_RESOLUTION
        wk := int32(v)

        ret[0] = byte((wk &amp; 0xFF0000) &gt;&gt; 16)
        ret[1] = byte((wk &amp; 0x00FF00) &gt;&gt; 8)
        ret[2] = byte((wk &amp; 0x0000FF))

        return ret
}</span>

func isDetectedOwnshipValid() bool <span class="cov1" title="2">{
        return stratuxClock.Since(OwnshipTrafficInfo.Last_seen).Seconds() &lt; 10
}</span>

func makeOwnshipReport() bool <span class="cov0" title="0">{
        gpsValid := isGPSValid()
        selfOwnshipValid := isDetectedOwnshipValid()
        if !gpsValid &amp;&amp; !selfOwnshipValid </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">curOwnship := OwnshipTrafficInfo
        useReceivedOwnshipInfo := !gpsValid &amp;&amp; selfOwnshipValid

        msg := make([]byte, 28)
        // See p.16.
        msg[0] = 0x0A // Message type "Ownship".

        // Retrieve ICAO code from settings
        code, _ := hex.DecodeString(globalSettings.OwnshipModeS)

        // Ownship Target Identify (see 3.5.1.2 of GDL-90 Specifications)
        // First half of byte is 0 for Alert type of 'No Traffic Alert'
        // Second half of byte is 0 for traffic type 'ADS-B with ICAO'
        // Send 0x01 by default, unless ICAO is set, send 0x00
        if len(code) == 3 &amp;&amp; code[0] != 0xF0 &amp;&amp; code[0] != 0x00 </span><span class="cov0" title="0">{
                msg[1] = 0x00    // ADS-B Out with ICAO
                msg[2] = code[0] // Mode S address.
                msg[3] = code[1] // Mode S address.
                msg[4] = code[2] // Mode S address.
        }</span> else<span class="cov0" title="0"> {
                msg[1] = 0x01 // ADS-B Out with self-assigned code
                // Reserved dummy code.
                msg[2] = 0xF0
                msg[3] = 0x00
                msg[4] = 0x00
        }</span>

        <span class="cov0" title="0">var tmp []byte
        var lat, lon float32
        if useReceivedOwnshipInfo </span><span class="cov0" title="0">{
                lat = curOwnship.Lat
                lon = curOwnship.Lng
        }</span> else<span class="cov0" title="0"> {
                lat = mySituation.GPSLatitude
                lon = mySituation.GPSLongitude
        }</span>

        <span class="cov0" title="0">tmp = makeLatLng(lat)
        msg[5] = tmp[0] // Latitude.
        msg[6] = tmp[1] // Latitude.
        msg[7] = tmp[2] // Latitude.
        tmp = makeLatLng(lon)
        msg[8] = tmp[0]  // Longitude.
        msg[9] = tmp[1]  // Longitude.
        msg[10] = tmp[2] // Longitude.

        // This is **PRESSURE ALTITUDE**
        alt := uint16(0xFFF) // 0xFFF "invalid altitude."
        validAltf := false

        var altf float64

        if useReceivedOwnshipInfo </span><span class="cov0" title="0">{
                altf = float64(curOwnship.Alt)
                validAltf = true
        }</span> else<span class="cov0" title="0"> if isTempPressValid() </span><span class="cov0" title="0">{
                altf = float64(mySituation.BaroPressureAltitude)
                validAltf = true
        }</span> else<span class="cov0" title="0"> if isGPSValid() </span><span class="cov0" title="0">{
                altf = float64(mySituation.GPSAltitudeMSL)
                validAltf = true
        }</span>

        <span class="cov0" title="0">if validAltf </span><span class="cov0" title="0">{
                altf = (altf + 1000) / 25
                alt = uint16(altf) &amp; 0xFFF // Should fit in 12 bits.
        }</span>

        <span class="cov0" title="0">msg[11] = byte((alt &amp; 0xFF0) &gt;&gt; 4) // Altitude.
        msg[12] = byte((alt &amp; 0x00F) &lt;&lt; 4)
        if selfOwnshipValid || isGPSGroundTrackValid() </span><span class="cov0" title="0">{
                msg[12] = msg[12] | 0x09 // "Airborne" + "True Track"
        }</span>

        <span class="cov0" title="0">msg[13] = byte(0x80 | (mySituation.GPSNACp &amp; 0x0F)) //Set NIC = 8 and use NACp from gps.go.

        gdSpeed := uint16(0) // 1kt resolution.
        if useReceivedOwnshipInfo &amp;&amp; curOwnship.Speed_valid </span><span class="cov0" title="0">{
                gdSpeed = curOwnship.Speed
        }</span> else<span class="cov0" title="0"> if isGPSGroundTrackValid() </span><span class="cov0" title="0">{
                gdSpeed = uint16(mySituation.GPSGroundSpeed + 0.5)
        }</span>

        // gdSpeed should fit in 12 bits.
        <span class="cov0" title="0">msg[14] = byte((gdSpeed &amp; 0xFF0) &gt;&gt; 4)
        msg[15] = byte((gdSpeed &amp; 0x00F) &lt;&lt; 4)

        verticalVelocity := int16(0x800) // ft/min. 64 ft/min resolution.
        //TODO: 0x800 = no information available.
        // verticalVelocity should fit in 12 bits.
        msg[15] = msg[15] | byte((verticalVelocity&amp;0x0F00)&gt;&gt;8)
        msg[16] = byte(verticalVelocity &amp; 0xFF)

        // Track is degrees true, set from GPS true course.
        groundTrack := float32(0)
        if useReceivedOwnshipInfo </span><span class="cov0" title="0">{
                groundTrack = float32(curOwnship.Track)
        }</span> else<span class="cov0" title="0"> if isGPSGroundTrackValid() </span><span class="cov0" title="0">{
                groundTrack = mySituation.GPSTrueCourse
        }</span>

        <span class="cov0" title="0">tempTrack := groundTrack + TRACK_RESOLUTION/2 // offset by half the 8-bit resolution to minimize binning error

        for tempTrack &gt; 360 </span><span class="cov0" title="0">{
                tempTrack -= 360
        }</span>
        <span class="cov0" title="0">for tempTrack &lt; 0 </span><span class="cov0" title="0">{
                tempTrack += 360
        }</span>

        <span class="cov0" title="0">trk := uint8(tempTrack / TRACK_RESOLUTION) // Resolution is ~1.4 degrees.

        //log.Printf("For groundTrack = %.2f, tempTrack= %.2f, trk = %d (%f)\n",groundTrack,tempTrack,trk,float32(trk)*TRACK_RESOLUTION)

        msg[17] = byte(trk)

        msg[18] = 0x01 // "Light (ICAO) &lt; 15,500 lbs"

        if selfOwnshipValid </span><span class="cov0" title="0">{
                // Limit tail number to 7 characters.
                tail := curOwnship.Tail
                if len(tail) &gt; 7 </span><span class="cov0" title="0">{
                        tail = tail[:7]
                }</span>
                // Copy tail number into message.
                <span class="cov0" title="0">for i := 0; i &lt; len(tail); i++ </span><span class="cov0" title="0">{
                        msg[19+i] = tail[i]
                }</span>
        }

        <span class="cov0" title="0">myReg := "Stratux" // Default callsign.
        // Use icao2reg() results for ownship tail number, if available.
        if len(code) == 3 </span><span class="cov0" title="0">{
                uintIcao := uint32(code[0])&lt;&lt;16 | uint32(code[1])&lt;&lt;8 | uint32(code[2])
                regFromIcao, regFromIcaoValid := icao2reg(uintIcao)
                if regFromIcaoValid </span><span class="cov0" title="0">{
                        // Valid "decoded" registration. Use this for the reg.
                        myReg = regFromIcao
                }</span>
        }

        // Truncate registration to 8 characters.
        <span class="cov0" title="0">if len(myReg) &gt; 8 </span><span class="cov0" title="0">{
                myReg = myReg[:8]
        }</span>

        // Write the callsign.
        <span class="cov0" title="0">for i := 0; i &lt; len(myReg); i++ </span><span class="cov0" title="0">{
                msg[19+i] = myReg[i]
        }</span>

        <span class="cov0" title="0">sendGDL90(prepareMessage(msg), time.Second, -1)
        sendXPlane(createXPlaneGpsMsg(lat, lon, mySituation.GPSAltitudeMSL, groundTrack, float32(gdSpeed)), time.Second, -1)

        return true</span>
}

func makeOwnshipGeometricAltitudeReport() bool <span class="cov0" title="0">{
        if !isGPSValid() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">msg := make([]byte, 5)
        // See p.28.
        msg[0] = 0x0B // Message type "Ownship Geo Alt".

        var GPSalt float32
        GPSalt = mySituation.GPSHeightAboveEllipsoid
        encodedAlt := int16(GPSalt / 5)    // GPS Altitude, encoded to 16-bit int using 5-foot resolution
        msg[1] = byte(encodedAlt &gt;&gt; 8)     // Altitude.
        msg[2] = byte(encodedAlt &amp; 0x00FF) // Altitude.

        //TODO: "Figure of Merit". 0x7FFF "Not available".
        msg[3] = 0x00
        msg[4] = 0x0A

        sendGDL90(prepareMessage(msg), time.Second, -1)
        return true</span>
}

/*

        "SX" Stratux GDL90 message.
        http://hiltonsoftware.com/stratux/ for latest version (currently using V104)

*/

func makeStratuxStatus() []byte <span class="cov1" title="1">{
        msg := make([]byte, 29)
        msg[0] = 'S'
        msg[1] = 'X'
        msg[2] = 1

        msg[3] = 1 // "message version".

        // Version code. Messy parsing to fit into four bytes.
        thisVers := stratuxVersion[1:]                       // Skip first character, should be 'v'.
        m_str := thisVers[0:strings.Index(thisVers, ".")]    // Major version.
        mib_str := thisVers[strings.Index(thisVers, ".")+1:] // Minor and build version.

        tp := 0 // Build "type".
        mi_str := ""
        b_str := ""
        if strings.Index(mib_str, "rc") != -1 </span><span class="cov1" title="1">{
                tp = 3
                mi_str = mib_str[0:strings.Index(mib_str, "rc")]
                b_str = mib_str[strings.Index(mib_str, "rc")+2:]
        }</span> else<span class="cov0" title="0"> if strings.Index(mib_str, "r") != -1 </span><span class="cov0" title="0">{
                tp = 2
                mi_str = mib_str[0:strings.Index(mib_str, "r")]
                b_str = mib_str[strings.Index(mib_str, "r")+1:]
        }</span> else<span class="cov0" title="0"> if strings.Index(mib_str, "b") != -1 </span><span class="cov0" title="0">{
                tp = 1
                mi_str = mib_str[0:strings.Index(mib_str, "b")]
                b_str = mib_str[strings.Index(mib_str, "b")+1:]
        }</span>

        // Convert to strings.
        <span class="cov1" title="1">m, _ := strconv.Atoi(m_str)
        mi, _ := strconv.Atoi(mi_str)
        b, _ := strconv.Atoi(b_str)

        msg[4] = byte(m)
        msg[5] = byte(mi)
        msg[6] = byte(tp)
        msg[7] = byte(b)

        //TODO: Hardware revision.
        msg[8] = 0xFF
        msg[9] = 0xFF
        msg[10] = 0xFF
        msg[11] = 0xFF

        // Valid and enabled flags.
        // Valid/Enabled: GPS portion.
        if isGPSValid() </span><span class="cov0" title="0">{
                switch mySituation.GPSFixQuality </span>{
                case 1:<span class="cov0" title="0"> // 1 = 3D GPS.
                        msg[13] = 1</span>
                case 2:<span class="cov0" title="0"> // 2 = DGPS (SBAS /WAAS).
                        msg[13] = 2</span>
                default:<span class="cov0" title="0"></span> // Zero.
                }
        }

        // Valid/Enabled: AHRS portion.
        <span class="cov1" title="1">if isAHRSValid() </span><span class="cov0" title="0">{
                msg[13] = msg[13] | (1 &lt;&lt; 2)
        }</span>

        // Valid/Enabled: Pressure altitude portion.
        <span class="cov1" title="1">if isTempPressValid() </span><span class="cov1" title="1">{
                msg[13] = msg[13] | (1 &lt;&lt; 3)
        }</span>

        // Valid/Enabled: CPU temperature portion.
        <span class="cov1" title="1">if common.IsCPUTempValid(globalStatus.CPUTemp) </span><span class="cov1" title="1">{
                msg[13] = msg[13] | (1 &lt;&lt; 4)
        }</span>

        // Valid/Enabled: UAT portion.
        <span class="cov1" title="1">if globalSettings.UAT_Enabled </span><span class="cov0" title="0">{
                msg[13] = msg[13] | (1 &lt;&lt; 5)
        }</span>

        // Valid/Enabled: ES portion.
        <span class="cov1" title="1">if globalSettings.ES_Enabled </span><span class="cov0" title="0">{
                msg[13] = msg[13] | (1 &lt;&lt; 6)
        }</span>

        // Ping provides ES and UAT
        <span class="cov1" title="1">if globalSettings.Ping_Enabled </span><span class="cov0" title="0">{
                msg[13] = msg[13] | (1 &lt;&lt; 5) | (1 &lt;&lt; 6)
        }</span>

        // Pong provides ES and UAT
        <span class="cov1" title="1">if globalSettings.Pong_Enabled </span><span class="cov0" title="0">{
                msg[13] = msg[13] | (1 &lt;&lt; 5) | (1 &lt;&lt; 6)
        }</span>

        // Valid/Enabled: GPS Enabled portion.
        <span class="cov1" title="1">if globalSettings.GPS_Enabled </span><span class="cov0" title="0">{
                msg[13] = msg[13] | (1 &lt;&lt; 7)
        }</span>

        // Valid/Enabled: AHRS Enabled portion.
        <span class="cov1" title="1">if globalSettings.IMU_Sensor_Enabled </span><span class="cov0" title="0">{
                msg[12] = 1 &lt;&lt; 0
        }</span>

        // Valid/Enabled: last bit unused.

        // Connected hardware: number of radios.
        <span class="cov1" title="1">msg[15] = msg[15] | (byte(globalStatus.Devices) &amp; 0x3)

        // Connected hardware: IMU (spec really says just RY835AI, could revise for other IMUs
        if globalStatus.IMUConnected </span><span class="cov0" title="0">{
                msg[15] = msg[15] | (1 &lt;&lt; 2)
        }</span>

        // Number of GPS satellites locked.
        <span class="cov1" title="1">msg[16] = byte(globalStatus.GPS_satellites_locked)

        // Number of satellites tracked
        msg[17] = byte(globalStatus.GPS_satellites_tracked)

        // Number of UAT traffic targets.
        msg[18] = byte((globalStatus.UAT_traffic_targets_tracking &amp; 0xFF00) &gt;&gt; 8)
        msg[19] = byte(globalStatus.UAT_traffic_targets_tracking &amp; 0xFF)
        // Number of 1090ES traffic targets.
        msg[20] = byte((globalStatus.ES_traffic_targets_tracking &amp; 0xFF00) &gt;&gt; 8)
        msg[21] = byte(globalStatus.ES_traffic_targets_tracking &amp; 0xFF)

        // Number of UAT messages per minute.
        msg[22] = byte((globalStatus.UAT_messages_last_minute &amp; 0xFF00) &gt;&gt; 8)
        msg[23] = byte(globalStatus.UAT_messages_last_minute &amp; 0xFF)
        // Number of 1090ES messages per minute.
        msg[24] = byte((globalStatus.ES_messages_last_minute &amp; 0xFF00) &gt;&gt; 8)
        msg[25] = byte(globalStatus.ES_messages_last_minute &amp; 0xFF)

        // CPU temperature.
        v := uint16(float32(10.0) * globalStatus.CPUTemp)

        msg[26] = byte((v &amp; 0xFF00) &gt;&gt; 8)
        msg[27] = byte(v &amp; 0xFF)

        // Number of ADS-B towers. Map structure is protected by ADSBTowerMutex.
        ADSBTowerMutex.Lock()
        num_towers := uint8(len(ADSBTowers))

        msg[28] = byte(num_towers)

        // List of ADS-B towers (lat, lng).
        for _, tower := range ADSBTowers </span><span class="cov1" title="2">{
                tmp := makeLatLng(float32(tower.Lat))
                msg = append(msg, tmp[0]) // Latitude.
                msg = append(msg, tmp[1]) // Latitude.
                msg = append(msg, tmp[2]) // Latitude.

                tmp = makeLatLng(float32(tower.Lng))
                msg = append(msg, tmp[0]) // Longitude.
                msg = append(msg, tmp[1]) // Longitude.
                msg = append(msg, tmp[2]) // Longitude.
        }</span>
        <span class="cov1" title="1">ADSBTowerMutex.Unlock()
        return prepareMessage(msg)</span>
}

/*

        "Stratux" GDL90 message.

        Message ID 0xCC.
        Byte1: p p p p p p GPS AHRS
        First 6 bytes are protocol version codes.
        Protocol 1: GPS on/off | AHRS on/off.
*/

func makeStratuxHeartbeat() []byte <span class="cov1" title="2">{
        msg := make([]byte, 2)
        msg[0] = 0xCC // Message type "Stratux".
        msg[1] = 0
        if isGPSValid() </span><span class="cov0" title="0">{
                msg[1] = 0x02
        }</span>
        <span class="cov1" title="2">if isAHRSValid() </span><span class="cov0" title="0">{
                msg[1] = msg[1] | 0x01
        }</span>

        <span class="cov1" title="2">protocolVers := int8(1)
        msg[1] = msg[1] | byte(protocolVers&lt;&lt;2)

        return prepareMessage(msg)</span>
}

/*
ForeFlight "ID Message".

Sends device information to ForeFlight.
*/
func makeFFIDMessage() []byte <span class="cov1" title="1">{
        msg := make([]byte, 39)
        msg[0] = 0x65 // Message type "ForeFlight".
        msg[1] = 0    // ID message identifier.
        msg[2] = 1    // Message version.
        // Serial number. Set to "invalid" for now.
        for i := 3; i &lt;= 10; i++ </span><span class="cov2" title="8">{
                msg[i] = 0xFF
        }</span>
        <span class="cov1" title="1">devShortName := "Stratux" // Temporary. Will be populated in the future with other names.
        if len(devShortName) &gt; 8 </span><span class="cov0" title="0">{
                devShortName = devShortName[:8] // 8 chars.
        }</span>
        <span class="cov1" title="1">copy(msg[11:], devShortName)

        devLongName := fmt.Sprintf("%s-%s", stratuxVersion, stratuxBuild)
        if len(devLongName) &gt; 16 </span><span class="cov0" title="0">{
                devLongName = devLongName[:16] // 16 chars.
        }</span>
        <span class="cov1" title="1">copy(msg[19:], devLongName)

        //if globalSettings.GDL90MSLAlt_Enabled {
        msg[38] = 0x00 // Capabilities mask. MSL altitude for Ownship Geometric report. We only support HAE as in spec.
        //}

        return prepareMessage(msg)</span>
}

func makeHeartbeat() []byte <span class="cov1" title="2">{
        msg := make([]byte, 7)
        // See p.10.
        msg[0] = 0x00 // Message type "Heartbeat".
        msg[1] = 0x01 // "UAT Initialized".
        if isGPSValid() </span><span class="cov0" title="0">{
                msg[1] = msg[1] | 0x80
        }</span>
        <span class="cov1" title="2">msg[1] = msg[1] | 0x10 //FIXME: Addr talkback.

        // "Maintenance Req'd". Add flag if there are any current critical system errors.
        if len(globalStatus.Errors) &gt; 0 </span><span class="cov0" title="0">{
                msg[1] = msg[1] | 0x40
        }</span>

        <span class="cov1" title="2">nowUTC := time.Now().UTC()
        // Seconds since 0000Z.
        midnightUTC := time.Date(nowUTC.Year(), nowUTC.Month(), nowUTC.Day(), 0, 0, 0, 0, time.UTC)
        secondsSinceMidnightUTC := uint32(nowUTC.Sub(midnightUTC).Seconds())

        msg[2] = byte(((secondsSinceMidnightUTC &gt;&gt; 16) &lt;&lt; 7) | 0x1) // UTC OK.
        msg[3] = byte((secondsSinceMidnightUTC &amp; 0xFF))
        msg[4] = byte((secondsSinceMidnightUTC &amp; 0xFFFF) &gt;&gt; 8)

        // TODO. Number of uplink messages. See p.12.
        // msg[5]
        // msg[6]

        return prepareMessage(msg)</span>
}

func relayMessage(msgtype uint16, msg []byte) <span class="cov0" title="0">{
        ret := make([]byte, len(msg)+4)
        // See p.15.
        ret[0] = byte(msgtype) // Uplink message ID.
        ret[1] = 0x00          //TODO: Time.
        ret[2] = 0x00          //TODO: Time.
        ret[3] = 0x00          //TODO: Time.

        for i := 0; i &lt; len(msg); i++ </span><span class="cov0" title="0">{
                ret[i+4] = msg[i]
        }</span>

        <span class="cov0" title="0">durability := 1 * time.Second
        if msgtype == MSGTYPE_UPLINK </span><span class="cov0" title="0">{
                durability = 15 * time.Minute // queue weather messages
        }</span>
        <span class="cov0" title="0">sendGDL90(prepareMessage(ret), durability, 4)</span>
}

func blinkStatusLED() <span class="cov0" title="0">{
        timer := time.NewTicker(100 * time.Millisecond)
        ledON := false
        for </span><span class="cov0" title="0">{
                &lt;-timer.C
                ledON = !ledON
                setActLed(ledON)

                if ledON != globalStatus.NightMode &amp;&amp; len(globalStatus.Errors) == 0 </span><span class="cov0" title="0">{ // System error was cleared - leave it on again
                        return
                }</span>

        }
}

func sendAllOwnshipInfo() <span class="cov0" title="0">{
        //log.Printf("Sending ownship info")
        sendGDL90(makeHeartbeat(), time.Second, -20) // Highest priority, always needs to be send because we use it to detect when a client becomes available
        sendGDL90(makeStratuxHeartbeat(), time.Second, 0)
        sendGDL90(makeStratuxStatus(), time.Second, 0)
        sendGDL90(makeFFIDMessage(), time.Second, 0)
        makeOwnshipReport()
        makeOwnshipGeometricAltitudeReport()
}</span>

func heartBeatSender() <span class="cov0" title="0">{
        timer := time.NewTicker(1 * time.Second)
        timerMessageStats := time.NewTicker(2 * time.Second)
        ledBlinking := false
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-timer.C:<span class="cov0" title="0">
                        // Green LED - always on during normal operation.
                        //  Blinking when there is a critical system error (and Stratux is still running).

                        if len(globalStatus.Errors) == 0 </span><span class="cov0" title="0">{ // Any system errors?
                                if !globalStatus.NightMode </span><span class="cov0" title="0">{ // LED is off by default (/boot/config.txt.)
                                        // Turn on green ACT LED on the Pi.
                                        setActLed(true)
                                }</span>
                        } else<span class="cov0" title="0"> if !ledBlinking </span><span class="cov0" title="0">{
                                // This assumes that system errors do not disappear until restart.
                                go blinkStatusLED()
                                ledBlinking = true
                        }</span>

                        <span class="cov0" title="0">sendAllOwnshipInfo()

                        sendNetFLARM(makeGPRMCString(), time.Second, -1)
                        sendNetFLARM(makeGPGGAString(), time.Second, 0)
                        if isTempPressValid() &amp;&amp; mySituation.BaroSourceType != BARO_TYPE_NONE &amp;&amp; mySituation.BaroSourceType != BARO_TYPE_ADSBESTIMATE </span><span class="cov0" title="0">{
                                sendNetFLARM(makePGRMZString(), time.Second, 0)
                        }</span>
                        <span class="cov0" title="0">sendNetFLARM("$GPGSA,A,3,,,,,,,,,,,,,1.0,1.0,1.0*33\r\n", time.Second, 1)

                        // --- debug code: traffic demo ---
                        // Uncomment and compile to display large number of artificial traffic targets
                        /*
                                numTargets := uint32(36)
                                hexCode := uint32(0xFF0000)

                                for i := uint32(0); i &lt; numTargets; i++ {
                                        tail := fmt.Sprintf("DEMO%d", i)
                                        alt := float32((i*117%2000)*25 + 2000)
                                        hdg := int32((i * 149) % 360)
                                        spd := float64(50 + ((i*23)%13)*37)

                                        updateDemoTraffic(i|hexCode, tail, alt, spd, hdg)

                                }
                        */

                        // ---end traffic demo code ---
                        sendTrafficUpdates()
                        updateStatus()</span>
                case &lt;-timerMessageStats.C:<span class="cov0" title="0">
                        // Save a bit of CPU by not pruning the message log every 1 second.
                        updateMessageStats()</span>
                }
        }
}

func msgLogAppend(m msg) <span class="cov4" title="48">{
        msgLogMutex.Lock()
        defer msgLogMutex.Unlock()
        msgLog = append(msgLog, m)
}</span>

func updateMessageStats() <span class="cov0" title="0">{
        ADSBTowerMutex.Lock()
        defer ADSBTowerMutex.Unlock()

        msgLogMutex.Lock()
        defer msgLogMutex.Unlock()

        m := len(msgLog)
        t := make([]msg, 0)
        UAT_messages_last_minute := uint(0)
        ES_messages_last_minute := uint(0)
        OGN_messages_last_minute := uint(0)
        AIS_messages_last_minute := uint(0)

        // Clear out ADSBTowers stats.
        for t, tinf := range ADSBTowers </span><span class="cov0" title="0">{
                tinf.Messages_last_minute = 0
                tinf.Energy_last_minute = 0
                ADSBTowers[t] = tinf
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; m; i++ </span><span class="cov0" title="0">{
                if stratuxClock.Since(msgLog[i].TimeReceived).Minutes() &lt; 1 </span><span class="cov0" title="0">{
                        t = append(t, msgLog[i])
                        if msgLog[i].MessageClass == MSGCLASS_UAT </span><span class="cov0" title="0">{
                                UAT_messages_last_minute++
                                if len(msgLog[i].ADSBTowerID) &gt; 0 </span><span class="cov0" title="0">{ // Update tower stats.
                                        tid := msgLog[i].ADSBTowerID

                                        if _, ok := ADSBTowers[tid]; !ok </span><span class="cov0" title="0">{ // First time we've seen the tower? Start tracking.
                                                var newTower ADSBTower
                                                newTower.Lat = msgLog[i].uatMsg.Lat
                                                newTower.Lng = msgLog[i].uatMsg.Lon
                                                newTower.Signal_strength_max = -999 // dBmax = 0, so this needs to initialize below scale ( &lt;&lt; -48 dB)
                                                ADSBTowers[tid] = newTower
                                        }</span>

                                        <span class="cov0" title="0">twr := ADSBTowers[tid]
                                        twr.Signal_strength_now = msgLog[i].Signal_strength

                                        twr.Energy_last_minute += uint64((msgLog[i].Signal_amplitude) * (msgLog[i].Signal_amplitude))
                                        twr.Messages_last_minute++
                                        if msgLog[i].Signal_strength &gt; twr.Signal_strength_max </span><span class="cov0" title="0">{ // Update alltime max signal strength.
                                                twr.Signal_strength_max = msgLog[i].Signal_strength
                                        }</span>
                                        <span class="cov0" title="0">ADSBTowers[tid] = twr</span>
                                }
                        } else<span class="cov0" title="0"> if msgLog[i].MessageClass == MSGCLASS_ES </span><span class="cov0" title="0">{
                                ES_messages_last_minute++
                        }</span> else<span class="cov0" title="0"> if msgLog[i].MessageClass == MSGCLASS_OGN </span><span class="cov0" title="0">{
                                OGN_messages_last_minute++
                        }</span> else<span class="cov0" title="0"> if msgLog[i].MessageClass == MSGCLASS_AIS </span><span class="cov0" title="0">{
                                AIS_messages_last_minute++
                        }</span>
                }
        }
        <span class="cov0" title="0">msgLog = t
        globalStatus.UAT_messages_last_minute = UAT_messages_last_minute
        globalStatus.ES_messages_last_minute = ES_messages_last_minute
        globalStatus.OGN_messages_last_minute = OGN_messages_last_minute
        globalStatus.AIS_messages_last_minute = AIS_messages_last_minute

        // Update "max messages/min" counters.
        if globalStatus.UAT_messages_max &lt; UAT_messages_last_minute </span><span class="cov0" title="0">{
                globalStatus.UAT_messages_max = UAT_messages_last_minute
        }</span>
        <span class="cov0" title="0">if globalStatus.ES_messages_max &lt; ES_messages_last_minute </span><span class="cov0" title="0">{
                globalStatus.ES_messages_max = ES_messages_last_minute
        }</span>
        <span class="cov0" title="0">if globalStatus.OGN_messages_max &lt; OGN_messages_last_minute </span><span class="cov0" title="0">{
                globalStatus.OGN_messages_max = OGN_messages_last_minute
        }</span>
        <span class="cov0" title="0">if globalStatus.AIS_messages_max &lt; AIS_messages_last_minute </span><span class="cov0" title="0">{
                globalStatus.AIS_messages_max = AIS_messages_last_minute
        }</span>

        // Update average signal strength over last minute for all ADSB towers.
        <span class="cov0" title="0">for t, tinf := range ADSBTowers </span><span class="cov0" title="0">{
                if tinf.Messages_last_minute == 0 || tinf.Energy_last_minute == 0 </span><span class="cov0" title="0">{
                        tinf.Signal_strength_last_minute = -999
                }</span> else<span class="cov0" title="0"> {
                        tinf.Signal_strength_last_minute = 10 * (math.Log10(float64((tinf.Energy_last_minute / tinf.Messages_last_minute))) - 6)
                }</span>
                <span class="cov0" title="0">ADSBTowers[t] = tinf</span>
        }

}

func updateStatus() <span class="cov0" title="0">{
        if mySituation.GPSFixQuality == 2 </span><span class="cov0" title="0">{
                globalStatus.GPS_solution = "3D GPS + SBAS"
        }</span> else<span class="cov0" title="0"> if mySituation.GPSFixQuality == 1 </span><span class="cov0" title="0">{
                globalStatus.GPS_solution = "3D GPS"
        }</span> else<span class="cov0" title="0"> if mySituation.GPSFixQuality == 6 </span><span class="cov0" title="0">{
                globalStatus.GPS_solution = "Dead Reckoning"
        }</span> else<span class="cov0" title="0"> if mySituation.GPSFixQuality == 0 </span><span class="cov0" title="0">{
                globalStatus.GPS_solution = "No Fix"
        }</span> else<span class="cov0" title="0"> {
                globalStatus.GPS_solution = "Unknown"
        }</span>

        <span class="cov0" title="0">if !(globalStatus.GPS_connected) || !(isGPSConnected()) </span><span class="cov0" title="0">{ // isGPSConnected looks for valid NMEA messages. GPS_connected is set by gpsSerialReader and will immediately fail on disconnected USB devices, or in a few seconds after "blocked" comms on ttyAMA0.

                mySituation.muSatellite.Lock()
                Satellites = make(map[string]SatelliteInfo)
                mySituation.muSatellite.Unlock()

                mySituation.GPSSatellites = 0
                mySituation.GPSSatellitesSeen = 0
                mySituation.GPSSatellitesTracked = 0
                mySituation.GPSFixQuality = 0
                globalStatus.GPS_solution = "Disconnected"
                globalStatus.GPS_connected = false
        }</span>

        <span class="cov0" title="0">globalStatus.GPS_satellites_locked = mySituation.GPSSatellites
        globalStatus.GPS_satellites_seen = mySituation.GPSSatellitesSeen
        globalStatus.GPS_satellites_tracked = mySituation.GPSSatellitesTracked
        globalStatus.GPS_position_accuracy = mySituation.GPSHorizontalAccuracy

        // Update Uptime value
        globalStatus.Uptime = int64(stratuxClock.Milliseconds)
        globalStatus.UptimeClock = stratuxClock.Time

        usage := du.NewDiskUsage("/")
        globalStatus.DiskBytesFree = usage.Free()
        globalStatus.Logfile_Size = logFileSize()

        var ahrsLogSize int64
        ahrsLogFiles, _ := ioutil.ReadDir("/var/log")
        for _, f := range ahrsLogFiles </span><span class="cov0" title="0">{
                if v, _ := filepath.Match("sensors_*.csv", f.Name()); v </span><span class="cov0" title="0">{
                        ahrsLogSize += f.Size()
                }</span>
        }
        <span class="cov0" title="0">globalStatus.AHRS_LogFiles_Size = ahrsLogSize</span>
}

type WeatherMessage struct {
        Type              string
        Location          string
        Time              string
        Data              string
        LocaltimeReceived time.Time
}

// Send update to connected websockets.
func registerADSBTextMessageReceived(msg string, uatMsg *uatparse.UATMsg) <span class="cov0" title="0">{
        x := strings.Split(msg, " ")
        if len(x) &lt; 5 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var wm WeatherMessage

        if (x[0] == "METAR") || (x[0] == "SPECI") </span><span class="cov0" title="0">{
                globalStatus.UAT_METAR_total++
        }</span>
        <span class="cov0" title="0">if (x[0] == "TAF") || (x[0] == "TAF.AMD") </span><span class="cov0" title="0">{
                globalStatus.UAT_TAF_total++
        }</span>
        <span class="cov0" title="0">if x[0] == "WINDS" </span><span class="cov0" title="0">{
                globalStatus.UAT_TAF_total++
        }</span>
        <span class="cov0" title="0">if x[0] == "PIREP" </span><span class="cov0" title="0">{
                globalStatus.UAT_PIREP_total++
        }</span>
        <span class="cov0" title="0">wm.Type = x[0]
        wm.Location = x[1]
        wm.Time = x[2]
        wm.Data = strings.Join(x[3:], " ")
        wm.LocaltimeReceived = stratuxClock.Time

        // Send to weatherUpdate channel for any connected clients.
        weatherUpdate.SendJSON(wm)</span>
}

func UpdateUATStats(ProductID uint32) <span class="cov0" title="0">{
        switch ProductID </span>{
        case 0, 20:<span class="cov0" title="0">
                globalStatus.UAT_METAR_total++</span>
        case 1, 21:<span class="cov0" title="0">
                globalStatus.UAT_TAF_total++</span>
        case 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 81, 82, 83:<span class="cov0" title="0">
                globalStatus.UAT_NEXRAD_total++</span>
        // AIRMET and SIGMETS
        case 2, 3, 4, 6, 11, 12, 22, 23, 24, 26, 254:<span class="cov0" title="0">
                globalStatus.UAT_SIGMET_total++</span>
        case 5, 25:<span class="cov0" title="0">
                globalStatus.UAT_PIREP_total++</span>
        case 8:<span class="cov0" title="0">
                globalStatus.UAT_NOTAM_total++</span>
        case 413:<span class="cov0" title="0">
                // Do nothing in the case since text is recorded elsewhere
                return</span>
        default:<span class="cov0" title="0">
                globalStatus.UAT_OTHER_total++</span>
        }
}

func parseInput(buf string) ([]byte, uint16) <span class="cov0" title="0">{
        //FIXME: We're ignoring all invalid format UAT messages (not sending to datalog).
        x := strings.Split(buf, ";") // Discard everything after the first ';'.
        s := x[0]
        if len(s) == 0 </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        <span class="cov0" title="0">globalStatus.UAT_messages_total++
        msgtype := uint16(0)
        isUplink := false

        if s[0] == '+' </span><span class="cov0" title="0">{
                isUplink = true
        }</span>

        <span class="cov0" title="0">var thisSignalStrength int

        if /*isUplink &amp;&amp;*/ len(x) &gt;= 3 </span><span class="cov0" title="0">{
                // See if we can parse out the signal strength.
                ss := x[2]
                //log.Printf("x[2] = %s\n",ss)
                if strings.HasPrefix(ss, "ss=") </span><span class="cov0" title="0">{
                        ssStr := ss[3:]
                        if ssInt, err := strconv.Atoi(ssStr); err == nil </span><span class="cov0" title="0">{
                                thisSignalStrength = ssInt
                                if isUplink &amp;&amp; (ssInt &gt; maxSignalStrength) </span><span class="cov0" title="0">{ // only look at uplinks; ignore ADS-B and TIS-B/ADS-R messages
                                        maxSignalStrength = ssInt
                                }</span>
                        } else <span class="cov0" title="0">{
                                //log.Printf("Error was %s\n",err.Error())
                        }</span>
                }
        }

        <span class="cov0" title="0">if s[0] == '-' </span><span class="cov0" title="0">{
                parseDownlinkReport(s, int(thisSignalStrength))
        }</span>
        <span class="cov0" title="0">s = s[1:]
        msglen := len(s) / 2
        if msglen != UPLINK_FRAME_DATA_BYTES &amp;&amp; isUplink </span><span class="cov0" title="0">{
                difference := UPLINK_FRAME_DATA_BYTES - msglen
                //s = append(s,strings.Repeat("00",difference))
                s = s + strings.Repeat("00", difference)
                msglen = len(s) / 2
        }</span>
        <span class="cov0" title="0">if len(s)%2 != 0 </span><span class="cov0" title="0">{ // Bad format.
                return nil, 0
        }</span>

        <span class="cov0" title="0">if isUplink &amp;&amp; msglen == UPLINK_FRAME_DATA_BYTES </span><span class="cov0" title="0">{
                msgtype = MSGTYPE_UPLINK
        }</span> else<span class="cov0" title="0"> if msglen == 48 </span><span class="cov0" title="0">{
                // With Reed Solomon appended
                msgtype = MSGTYPE_LONG_REPORT
        }</span> else<span class="cov0" title="0"> if msglen == 34 </span><span class="cov0" title="0">{
                msgtype = MSGTYPE_LONG_REPORT
        }</span> else<span class="cov0" title="0"> if msglen == 18 </span><span class="cov0" title="0">{
                msgtype = MSGTYPE_BASIC_REPORT
        }</span> else<span class="cov0" title="0"> {
                msgtype = 0
        }</span>

        <span class="cov0" title="0">if msgtype == 0 </span><span class="cov0" title="0">{
                log.Printf("UNKNOWN MESSAGE TYPE: %s - msglen=%d\n", s, msglen)
        }</span>

        // Now, begin converting the string into a byte array.
        <span class="cov0" title="0">frame := make([]byte, UPLINK_FRAME_DATA_BYTES)
        hex.Decode(frame, []byte(s))

        var thisMsg msg
        thisMsg.MessageClass = MSGCLASS_UAT
        thisMsg.TimeReceived = stratuxClock.Time
        thisMsg.Data = buf
        thisMsg.Signal_amplitude = thisSignalStrength
        if thisSignalStrength &gt; 0 </span><span class="cov0" title="0">{
                thisMsg.Signal_strength = 20 * math.Log10((float64(thisSignalStrength))/1000)
        }</span> else<span class="cov0" title="0"> {
                thisMsg.Signal_strength = -999
        }</span>
        <span class="cov0" title="0">thisMsg.Products = make([]uint32, 0)
        if msgtype == MSGTYPE_UPLINK </span><span class="cov0" title="0">{
                // Parse the UAT message.
                uatMsg, err := uatparse.New(buf)
                if err == nil </span><span class="cov0" title="0">{
                        uatMsg.DecodeUplink()
                        towerid := fmt.Sprintf("(%f,%f)", uatMsg.Lat, uatMsg.Lon)
                        thisMsg.ADSBTowerID = towerid
                        // Get all of the "product ids".
                        for _, f := range uatMsg.Frames </span><span class="cov0" title="0">{
                                thisMsg.Products = append(thisMsg.Products, f.Product_id)
                                UpdateUATStats(f.Product_id)
                                weatherRawUpdate.SendJSON(f)
                        }</span>
                        // Get all of the text reports.
                        <span class="cov0" title="0">textReports, _ := uatMsg.GetTextReports()
                        for _, r := range textReports </span><span class="cov0" title="0">{
                                registerADSBTextMessageReceived(r, uatMsg)
                        }</span>
                        <span class="cov0" title="0">thisMsg.uatMsg = uatMsg</span>
                }
        }

        <span class="cov0" title="0">msgLogAppend(thisMsg)
        logMsg(thisMsg)

        return frame, msgtype</span>
}

func getProductNameFromId(product_id int) string <span class="cov3" title="23">{
        name, present := product_name_map[product_id]
        if present </span><span class="cov2" title="7">{
                return name
        }</span>

        <span class="cov3" title="16">if product_id == 600 || (product_id &gt;= 2000 &amp;&amp; product_id &lt;= 2005) </span><span class="cov3" title="9">{
                return "Custom/Test"
        }</span>

        <span class="cov2" title="7">return fmt.Sprintf("Unknown (%d)", product_id)</span>
}

type settings struct {
        DarkMode             bool
        UAT_Enabled          bool
        ES_Enabled           bool
        OGN_Enabled          bool
        APRS_Enabled         bool
        AIS_Enabled          bool
        Ping_Enabled         bool
        Pong_Enabled         bool
        GPS_Enabled          bool
        BMP_Sensor_Enabled   bool
        IMU_Sensor_Enabled   bool
        NetworkOutputs       []networkConnection
        SerialOutputs        map[string]serialConnection
        BleOutputs           []bleConnection
        DisplayTrafficSource bool
        DEBUG                bool
        ReplayLog            bool
        TraceLog             bool
        AHRSLog              bool
        PersistentLogging    bool
        ClearLogOnStart      bool
        IMUMapping           [2]int     // Map from aircraft axis to sensor axis: accelerometer
        SensorQuaternion     [4]float64 // Quaternion mapping from sensor frame to aircraft frame
        C, D                 [3]float64 // IMU Accel, Gyro zero bias
        PPM                  int
        Dump1090Gain         float64 // SDR RTL ES Gain
        AltitudeOffset       int
        OwnshipModeS         string
        WatchList            string
        DeveloperMode        bool
        GLimits              string
        StaticIps            []string
        WiFiCountry          string
        WiFiSSID             string
        WiFiChannel          int
        WiFiSecurityEnabled  bool
        WiFiPassphrase       string
        NoSleep              bool

        WiFiMode                       int
        WiFiDirectPin                  string
        WiFiIPAddress                  string
        WiFiClientNetworks             []wifiClientNetwork
        WiFiInternetPassThroughEnabled bool

        EstimateBearinglessDist bool
        RadarLimits             int
        RadarRange              int

        OGNI2CTXEnabled bool

        // External Tracker config (OGN Tracker/GXAirCom/SoftRF)
        OGNAddr     string
        OGNAddrType int // 0=random, 1=ICAO, 2=Flarm, 3=OGN
        OGNAcftType int
        OGNPilot    string
        OGNReg      string
        OGNTxPower  int

        PWMDutyMin int

        // manual GPS config  (versus autodetect)
        GpsManualConfig     bool
        GpsManualDevice     string // default: /dev/ttyAMA0
        GpsManualChip       string // ublox8, ublox9, ublox
        GpsManualTargetBaud int    // default: 115200
        RegionSelected      int    // 0 - none, 1 = US, 2 = EU
}

type status struct {
        Version                        string
        Build                          string
        HardwareBuild                  string
        Devices                        uint32
        Connected_Users                uint
        DiskBytesFree                  uint64
        UAT_messages_last_minute       uint
        UAT_messages_max               uint
        UAT_messages_total             uint64
        ES_messages_last_minute        uint
        ES_messages_max                uint
        ES_messages_total              uint64
        OGN_messages_last_minute       uint
        OGN_messages_max               uint
        OGN_messages_total             uint64
        OGN_connected                  bool
        APRS_connected                 bool
        AIS_messages_last_minute       uint
        AIS_messages_max               uint
        AIS_messages_total             uint64
        AIS_connected                  bool
        UAT_traffic_targets_tracking   uint16
        ES_traffic_targets_tracking    uint16
        Ping_connected                 bool
        Pong_connected                 bool
        UATRadio_connected             bool
        GPS_satellites_locked          uint16
        GPS_satellites_seen            uint16
        GPS_satellites_tracked         uint16
        GPS_position_accuracy          float32
        GPS_connected                  bool
        GPS_solution                   string
        GPS_detected_type              uint
        GPS_NetworkRemoteIp            string // for NMEA via TCP from OGN tracker: display remote IP to configure the OGN tracker
        Uptime                         int64
        UptimeClock                    time.Time
        CPUTemp                        float32
        CPUTempMin                     float32
        CPUTempMax                     float32
        NetworkDataMessagesSent        uint64
        NetworkDataBytesSent           uint64
        NetworkDataMessagesSentLastSec uint64
        NetworkDataBytesSentLastSec    uint64
        UAT_METAR_total                uint32
        UAT_TAF_total                  uint32
        UAT_NEXRAD_total               uint32
        UAT_SIGMET_total               uint32
        UAT_PIREP_total                uint32
        UAT_NOTAM_total                uint32
        UAT_OTHER_total                uint32
        Errors                         []string
        Logfile_Size                   int64
        AHRS_LogFiles_Size             int64
        BMPConnected                   bool
        IMUConnected                   bool
        NightMode                      bool // For turning off LEDs.
        OGN_noise_db                   float32
        OGN_gain_db                    float32
        OGN_tx_enabled                 bool // If ogn-rx-eu uses a local tx module for transmission

        OGNPrevRandomAddr string // when OGN is in random stealth mode, it's ID changes randomly - keep the previous one so we can filter properly
        Pong_Heartbeats   int64  // Pong heartbeat counter
}

var globalSettings settings
var globalStatus status
var noConfigFound bool

func defaultSettings() <span class="cov0" title="0">{
        // Region is none if not specified, default to US settings
        globalSettings.RegionSelected = 0
        globalSettings.DarkMode = false
        globalSettings.UAT_Enabled = true
        globalSettings.ES_Enabled = true
        globalSettings.OGN_Enabled = false
        globalSettings.Dump1090Gain = 37.2
        globalSettings.APRS_Enabled = true
        globalSettings.GPS_Enabled = true
        globalSettings.IMU_Sensor_Enabled = true
        globalSettings.BMP_Sensor_Enabled = true
        //FIXME: Need to change format below.
        globalSettings.NetworkOutputs = []networkConnection{
                {Conn: nil, Ip: "", Port: 4000, Capability: NETWORK_GDL90_STANDARD | NETWORK_AHRS_GDL90},
                {Conn: nil, Ip: "", Port: 2000, Capability: NETWORK_FLARM_NMEA},
                {Conn: nil, Ip: "", Port: 49002, Capability: NETWORK_POSITION_FFSIM | NETWORK_AHRS_FFSIM},
        }
        globalSettings.BleOutputs = []bleConnection{
                { // SoftRF style service
                        Capability:  NETWORK_FLARM_NMEA,
                        UUIDService: "FFE0",
                        UUIDGatt:    "FFE1",
                },
                { // "standard" nRF UART/Serial emulation
                        Capability:  NETWORK_FLARM_NMEA,
                        UUIDService: "6E400001-B5A3-F393-E0A9-E50E24DCCA9E",
                        UUIDGatt:    "6E400003-B5A3-F393-E0A9-E50E24DCCA9E",
                },
        }
        globalSettings.DEBUG = false
        globalSettings.DisplayTrafficSource = false
        globalSettings.ReplayLog = false //TODO: 'true' for debug builds.
        globalSettings.AHRSLog = false
        globalSettings.IMUMapping = [2]int{-1, 0}
        globalSettings.OwnshipModeS = "F00000"
        globalSettings.DeveloperMode = false
        globalSettings.StaticIps = make([]string, 0)
        globalSettings.NoSleep = false
        globalSettings.EstimateBearinglessDist = false

        globalSettings.WiFiChannel = 1
        globalSettings.WiFiIPAddress = "192.168.10.1"
        globalSettings.WiFiPassphrase = ""
        globalSettings.WiFiSSID = "Stratux"
        globalSettings.WiFiSecurityEnabled = false
        globalSettings.WiFiClientNetworks = make([]wifiClientNetwork, 0)

        globalSettings.RadarLimits = 2000
        globalSettings.RadarRange = 10
        globalSettings.AltitudeOffset = 0

        globalSettings.PWMDutyMin = 0

        globalSettings.OGNI2CTXEnabled = true

        globalSettings.ClearLogOnStart = false

        globalSettings.GpsManualConfig = false
        globalSettings.GpsManualDevice = "/dev/ttyAMA0"
        globalSettings.GpsManualTargetBaud = 115200
        globalSettings.GpsManualChip = "ublox"
}</span>

func readSettings() <span class="cov0" title="0">{
        defaultSettings()

        fd, err := os.Open(configLocation)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("can't read settings %s: %s\n", configLocation, err.Error())
                return
        }</span>
        <span class="cov0" title="0">defer fd.Close()
        buf := make([]byte, 10000)
        count, err := fd.Read(buf)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("can't read settings %s: %s\n", configLocation, err.Error())
                return
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(buf[0:count], &amp;globalSettings)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("can't read settings %s: %s\n", configLocation, err.Error())
                return
        }</span>
        <span class="cov0" title="0">log.Printf("read in settings.\n")</span>
}

func addSystemError(err error) <span class="cov0" title="0">{
        globalStatus.Errors = append(globalStatus.Errors, err.Error())
}</span>

var systemErrsMutex *sync.Mutex
var systemErrs map[string]string

func removeSingleSystemError(ident string) <span class="cov0" title="0">{
        systemErrsMutex.Lock()
        if oldMsg, ok := systemErrs[ident]; ok </span><span class="cov0" title="0">{
                for i, v := range globalStatus.Errors </span><span class="cov0" title="0">{
                        if v == oldMsg </span><span class="cov0" title="0">{
                                globalStatus.Errors = append(globalStatus.Errors[:i], globalStatus.Errors[i+1:]...)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">delete(systemErrs, ident)
        systemErrsMutex.Unlock()</span>
}

func addSingleSystemErrorf(ident string, format string, a ...interface{}) <span class="cov0" title="0">{
        systemErrsMutex.Lock()
        if _, ok := systemErrs[ident]; !ok </span><span class="cov0" title="0">{
                // Error hasn't been thrown yet.
                systemErrs[ident] = fmt.Sprintf(format, a...)
                globalStatus.Errors = append(globalStatus.Errors, systemErrs[ident])
                log.Printf("Added critical system error: %s\n", systemErrs[ident])
        }</span>
        // Do nothing on this call if the error has already been thrown.
        <span class="cov0" title="0">systemErrsMutex.Unlock()</span>
}

func overlayctl(cmd string) <span class="cov0" title="0">{
        out, err := exec.Command("/bin/sh", "/sbin/overlayctl", cmd).Output()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("overlayctl error: %s\n%s", err.Error(), out)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("overlayctl: %s\n", out)
        }</span>
}

func saveSettings() <span class="cov0" title="0">{
        fd, err := os.OpenFile(configLocation, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.FileMode(0644))
        if err != nil </span><span class="cov0" title="0">{
                addSingleSystemErrorf("save-settings", "can't save settings %s: %s", configLocation, err.Error())
                return
        }</span>
        <span class="cov0" title="0">defer fd.Close()
        jsonSettings, _ := json.MarshalIndent(&amp;globalSettings, "", "  ")
        fd.Write(jsonSettings)
        fd.Sync()
        log.Printf("wrote settings.\n")</span>
}

func changeRegionSettings() <span class="cov0" title="0">{
        // The region has been updated by the UI. Decide what to do with that information

        switch globalSettings.RegionSelected </span>{
        case 1:<span class="cov0" title="0"> // US settings
                globalSettings.UAT_Enabled = true
                globalSettings.OGN_Enabled = false
                globalSettings.DeveloperMode = false</span>
        case 2:<span class="cov0" title="0"> // EU settings
                globalSettings.UAT_Enabled = false
                globalSettings.OGN_Enabled = true
                globalSettings.DeveloperMode = true</span>
        default:<span class="cov0" title="0"></span> // Nothing selected

        }
        <span class="cov0" title="0">saveSettings()</span>
}

func openReplay(fn string, compressed bool) (WriteCloser, error) <span class="cov0" title="0">{
        fp, err := os.OpenFile(fn, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to open log file '%s': %s\n", fn, err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">var ret WriteCloser
        if compressed </span><span class="cov0" title="0">{
                ret = gzip.NewWriter(fp) //FIXME: Close() on the gzip.Writer will not close the underlying file.
        }</span> else<span class="cov0" title="0"> {
                ret = fp
        }</span>

        <span class="cov0" title="0">timeFmt := "Mon Jan 2 15:04:05 -0700 MST 2006"
        s := fmt.Sprintf("START,%s,%s\n", timeStarted.Format(timeFmt), time.Now().Format(timeFmt)) // Start time marker.

        ret.Write([]byte(s))
        return ret, err</span>
}

/*
        fsWriteTest().
         Makes a temporary file in 'dir', checks for error. Deletes the file.
*/

func fsWriteTest(dir string) error <span class="cov0" title="0">{
        fn := dir + "/.write_test"
        err := ioutil.WriteFile(fn, []byte("test\n"), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = os.Remove(fn)
        return err</span>
}

func printStats() <span class="cov0" title="0">{
        statTimer := time.NewTicker(30 * time.Second)
        for </span><span class="cov0" title="0">{
                &lt;-statTimer.C
                var memstats runtime.MemStats
                runtime.ReadMemStats(&amp;memstats)
                usage := du.NewDiskUsage("/")

                log.Printf("stats [started: %s]\n", humanize.RelTime(time.Time{}, stratuxClock.Time, "ago", "from now"))
                log.Printf(" - Disk bytes used = %s (%.1f %%), Disk bytes free = %s (%.1f %%)\n", humanize.Bytes(usage.Used()), 100*usage.Usage(), humanize.Bytes(usage.Free()), 100*(1-usage.Usage()))
                log.Printf(" - CPUTemp=%.02f [%.02f - %.02f] deg C, MemStats.Alloc=%s, MemStats.Sys=%s, totalNetworkMessagesSent=%s\n", globalStatus.CPUTemp, globalStatus.CPUTempMin, globalStatus.CPUTempMax, humanize.Bytes(uint64(memstats.Alloc)), humanize.Bytes(uint64(memstats.Sys)), humanize.Comma(int64(totalNetworkMessagesSent)))
                log.Printf(" - UAT/min/total %s/%s/%s [maxSS=%.02f%%], ES/min/total %s/%s/%s, Total traffic targets tracked=%s", humanize.Comma(int64(globalStatus.UAT_messages_last_minute)), humanize.Comma(int64(globalStatus.UAT_messages_max)), humanize.Comma(int64(globalStatus.UAT_messages_total)), float64(maxSignalStrength)/10.0, humanize.Comma(int64(globalStatus.ES_messages_last_minute)), humanize.Comma(int64(globalStatus.ES_messages_max)), humanize.Comma(int64(globalStatus.ES_messages_total)), humanize.Comma(int64(len(seenTraffic))))
                log.Printf(" - Network data messages sent: %d total.  Network data bytes sent: %d total.\n", globalStatus.NetworkDataMessagesSent, globalStatus.NetworkDataBytesSent)
                if globalSettings.GPS_Enabled </span><span class="cov0" title="0">{
                        log.Printf(" - Last GPS fix: %s, GPS solution type: %d using %d satellites (%d/%d seen/tracked), NACp: %d, est accuracy %.02f m\n", stratuxClock.HumanizeTime(mySituation.GPSLastFixLocalTime), mySituation.GPSFixQuality, mySituation.GPSSatellites, mySituation.GPSSatellitesSeen, mySituation.GPSSatellitesTracked, mySituation.GPSNACp, mySituation.GPSHorizontalAccuracy)
                        log.Printf(" - GPS vertical velocity: %.02f ft/sec; GPS vertical accuracy: %v m\n", mySituation.GPSVerticalSpeed, mySituation.GPSVerticalAccuracy)
                }</span>
                <span class="cov0" title="0">log.Printf(" - Mode-S Distance factors (&lt;5000, &lt;10000, &gt;10000): %f, %f, %f", estimatedDistFactors[0], estimatedDistFactors[1], estimatedDistFactors[2])
                sensorsOutput := make([]string, 0)
                if globalSettings.IMU_Sensor_Enabled </span><span class="cov0" title="0">{
                        sensorsOutput = append(sensorsOutput, fmt.Sprintf("Last IMU read: %s", stratuxClock.HumanizeTime(mySituation.AHRSLastAttitudeTime)))
                }</span>
                <span class="cov0" title="0">if globalSettings.BMP_Sensor_Enabled </span><span class="cov0" title="0">{
                        sensorsOutput = append(sensorsOutput, fmt.Sprintf("Last BMP read: %s", stratuxClock.HumanizeTime(mySituation.BaroLastMeasurementTime)))
                }</span>
                <span class="cov0" title="0">if len(sensorsOutput) &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("- " + strings.Join(sensorsOutput, ", ") + "\n")
                }</span>
                // Check if we're using more than 95% of the free space. If so, throw a warning (only once).
                <span class="cov0" title="0">if usage.Usage() &gt; 0.95 </span><span class="cov0" title="0">{
                        addSingleSystemErrorf("disk-space", "Disk bytes used = %s (%.1f %%), Disk bytes free = %s (%.1f %%)", humanize.Bytes(usage.Used()), 100*usage.Usage(), humanize.Bytes(usage.Free()), 100*(1-usage.Usage()))
                }</span>
                <span class="cov0" title="0">logStatus()</span>
        }
}

var uatReplayDone bool

func uatReplay(f ReadCloser, replaySpeed uint64) <span class="cov0" title="0">{
        defer f.Close()
        rdr := bufio.NewReader(f)
        curTick := int64(0)
        for </span><span class="cov0" title="0">{
                buf, err := rdr.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">linesplit := strings.Split(buf, ",")
                if len(linesplit) &lt; 2 </span><span class="cov0" title="0">{ // Blank line or invalid.
                        continue</span>
                }
                <span class="cov0" title="0">if linesplit[0] == "START" </span><span class="cov0" title="0">{ // Reset ticker, new start.
                        curTick = 0
                }</span> else<span class="cov0" title="0"> { // If it's not "START", then it's a tick count.
                        i, err := strconv.ParseInt(linesplit[0], 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("invalid tick: '%s'\n", linesplit[0])
                                continue</span>
                        }
                        <span class="cov0" title="0">thisWait := (i - curTick) / int64(replaySpeed)

                        if thisWait &gt;= 120000000000 </span><span class="cov0" title="0">{ // More than 2 minutes wait, skip ahead.
                                log.Printf("UAT skipahead - %d seconds.\n", thisWait/1000000000)
                        }</span> else<span class="cov0" title="0"> {
                                time.Sleep(time.Duration(thisWait) * time.Nanosecond) // Just in case the units change.
                        }</span>

                        <span class="cov0" title="0">p := strings.Trim(linesplit[1], " ;\r\n")
                        buf := fmt.Sprintf("%s;\n", p)
                        o, msgtype := parseInput(buf)
                        if o != nil &amp;&amp; msgtype != 0 </span><span class="cov0" title="0">{
                                relayMessage(msgtype, o)
                        }</span>
                        <span class="cov0" title="0">curTick = i</span>
                }
        }
        <span class="cov0" title="0">uatReplayDone = true</span>
}

func openReplayFile(fn string) ReadCloser <span class="cov0" title="0">{
        fp, err := os.Open(fn)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error opening '%s': %s\n", fn, err.Error())
                os.Exit(1)
                return nil
        }</span>

        <span class="cov0" title="0">var ret ReadCloser
        if strings.HasSuffix(fn, ".gz") </span><span class="cov0" title="0">{ // Open as a compressed replay log, depending on the suffix.
                ret, err = gzip.NewReader(fp)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("error opening compressed log '%s': %s\n", fn, err.Error())
                        os.Exit(1)
                        return nil
                }</span>
        } else<span class="cov0" title="0"> {
                ret = fp
        }</span>

        <span class="cov0" title="0">return ret</span>
}

var stratuxClock *monotonic
var sigs = make(chan os.Signal, 1) // Signal catch channel (shutdown).

// Graceful shutdown. Do everything except for kill the process.
func gracefulShutdown() <span class="cov0" title="0">{
        // Shut down SDRs.
        sdrKill()
        pingKill()
        pongKill()

        // Shut down data logging.
        if dataLogStarted </span><span class="cov0" title="0">{
                closeDataLog()
        }</span>

        <span class="cov0" title="0">pprof.StopCPUProfile()

        //TODO: Any other graceful shutdown functions.

        // Turn off green ACT LED on the Pi. Path changed around kernel 6.1.21-v8
        setActLed(false)</span>
}

// Turn off green ACT LED on the Pi. Path changed to leds/ACT/brighgtness around kernel 6.1.21-v8
func setActLed(state bool) <span class="cov0" title="0">{
        ledPath := "/sys/class/leds/led0/brightness"
        if _, err := os.Stat(ledPath); err != nil </span><span class="cov0" title="0">{
                ledPath = "/sys/class/leds/ACT/brightness"
        }</span>
        <span class="cov0" title="0">data := []byte("0\n")
        if state </span><span class="cov0" title="0">{
                data = []byte("1\n")
        }</span>
        <span class="cov0" title="0">ioutil.WriteFile(ledPath, data, 0644)</span>
}

func signalWatcher() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                sig := &lt;-sigs

                log.Printf("signal caught: %s - shutting down.\n", sig.String())
                gracefulShutdown()
                os.Exit(1)
        }</span>
}

func isX86DebugMode() bool <span class="cov0" title="0">{
        return runtime.GOARCH == "i386" || runtime.GOARCH == "amd64"
}</span>

func main() <span class="cov0" title="0">{
        // Catch signals for graceful shutdown.
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
        go signalWatcher()

        stratuxClock = NewMonotonic() // Start our "stratux clock".

        if !common.IsRunningAsRoot() </span><span class="cov0" title="0">{
                // mount web server to dev directory..
                ex, err := os.Executable()
                if err == nil </span><span class="cov0" title="0">{
                        ex = filepath.Dir(ex)
                        STRATUX_WWW_DIR = ex + "/web/"
                }</span>
                <span class="cov0" title="0">configLocation = os.Getenv("HOME") + "/.stratux.conf"
                log.Printf("Not running as root, remapping STRATUX_WWW_DIR to %s and configLocation to %s\n",
                        STRATUX_WWW_DIR, configLocation)</span>
        }

        // Set up mySituation, do it here so logging JSON doesn't panic
        <span class="cov0" title="0">mySituation.muGPS = &amp;sync.Mutex{}
        mySituation.muGPSPerformance = &amp;sync.Mutex{}
        mySituation.muAttitude = &amp;sync.Mutex{}
        mySituation.muBaro = &amp;sync.Mutex{}
        mySituation.muSatellite = &amp;sync.Mutex{}

        // Set up system error tracking.
        systemErrsMutex = &amp;sync.Mutex{}
        systemErrs = make(map[string]string)

        // Set up status.
        if stratuxVersion == "" </span><span class="cov0" title="0">{
                stratuxVersion = "v0.0"
        }</span>
        <span class="cov0" title="0">globalStatus.Version = stratuxVersion

        globalStatus.Build = stratuxBuild
        globalStatus.Errors = make([]string, 0)
        //FlightBox: detect via presence of /etc/FlightBox file.
        if _, err := os.Stat("/etc/FlightBox"); !os.IsNotExist(err) </span><span class="cov0" title="0">{
                globalStatus.HardwareBuild = "FlightBox"
                logDirf = logDir_FB
        }</span> else<span class="cov0" title="0"> { // if not using the FlightBox config, use "normal" log file locations
                logDirf = logDir
        }</span>
        //Merlin: detect presence of /etc/Merlin file.
        <span class="cov0" title="0">if _, err := os.Stat("/etc/Merlin"); !os.IsNotExist(err) </span><span class="cov0" title="0">{
                globalStatus.HardwareBuild = "Merlin"
        }</span>
        <span class="cov0" title="0">dataLogFilef = filepath.Join(logDirf, dataLogFile)

        //        replayESFilename := flag.String("eslog", "none", "ES Log filename")
        replayUATFilename := flag.String("uatlog", "none", "UAT Log filename")
        replayFlag := flag.Bool("replay", false, "Replay file flag")
        replaySpeed := flag.Int("speed", 1, "Replay speed multiplier")
        stdinFlag := flag.Bool("uatin", false, "Process UAT messages piped to stdin")
        writeNetworkConfig := flag.Bool("write-network-config", false, "Only write network configuration files as configured in stratux.conf and exit")

        traceReplay := flag.String("trace", "", "Replay previously recorded trace file and exit")
        traceReplaySpeed := flag.Float64("traceSpeed", 1.0, "Trace replay speed multiplier")
        traceReplayFilter := flag.String("traceFilter", "", "Filter trace data by context. Comma separated list of: ais,nmea,aprs,ogn-rx,dump1090,godump978,lowpower_uat")
        traceSkip := flag.Int64("traceSkip", 0, "Minutes to skip forward in recorded trace")
        ManagementAddrTmp := flag.Int("port", defaultManagementAddr, "Specify the port to use")

        cpuprofile := flag.String("cpuprofile", "", "write cpu profile to file")

        flag.Parse()

        ManagementAddr = *ManagementAddrTmp
        isTraceReplayMode := *traceReplay != ""

        timeStarted = time.Now()
        runtime.GOMAXPROCS(runtime.NumCPU()) // redundant with Go v1.5+ compiler

        // Start CPU profile, if requested.
        if *cpuprofile != "" </span><span class="cov0" title="0">{
                f, err := os.Create(*cpuprofile)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">log.Printf("Writing CPU profile to: %s\n", *cpuprofile)
                pprof.StartCPUProfile(f)</span>
        }

        <span class="cov0" title="0">initLogging()

        // Read settings.
        readSettings()

        // Clear the logfile on startup
        if globalSettings.ClearLogOnStart </span><span class="cov0" title="0">{
                clearDebugLogFile()
        }</span>

        <span class="cov0" title="0">log.Printf("Stratux %s (%s) starting.\n", stratuxVersion, stratuxBuild)
        if *writeNetworkConfig </span><span class="cov0" title="0">{
                log.Printf("Only writing network settings...")
                applyNetworkSettings(true, true)
                return
        }</span>

        <span class="cov0" title="0">ADSBTowers = make(map[string]ADSBTower)
        ADSBTowerMutex = &amp;sync.Mutex{}
        msgLog = make([]msg, 0)

        // Start the management interface.
        go managementInterface()
        go traceLoggerWatchdog()

        crcInit() // Initialize CRC16 table.

        if !isTraceReplayMode </span><span class="cov0" title="0">{
                sdrInit()
                pingInit()
                pongInit()
        }</span>
        <span class="cov0" title="0">initTraffic(isTraceReplayMode)

        // Disable replay logs when replaying - so that messages replay data isn't copied into the logs.
        // Override after reading in the settings.
        if *replayFlag == true </span><span class="cov0" title="0">{
                log.Printf("Replay file %s\n", *replayUATFilename)
                globalSettings.ReplayLog = false
        }</span>

        <span class="cov0" title="0">if globalSettings.DeveloperMode == true </span><span class="cov0" title="0">{
                log.Printf("Developer mode set\n")
        }</span>

        <span class="cov0" title="0">if !isTraceReplayMode </span><span class="cov0" title="0">{
                //FIXME: Only do this if data logging is enabled.
                initDataLog()

                // Start the AHRS sensor monitoring.
                initI2CSensors()
        }</span>

        // Start the GPS external sensor monitoring.
        <span class="cov0" title="0">initGPS(isTraceReplayMode)

        // Start the heartbeat message loop in the background, once per second.
        go heartBeatSender()

        // Initialize the (out) network handler.
        initNetwork()

        // Start printing stats periodically to the logfiles.
        go printStats()

        // Extrapolate traffic when no signal is received.
        go trafficInfoExtrapolator()

        // Guesses barometric altitude if we don't have our own baro source by using GnssBaroDiff from other traffic at similar altitude
        go baroAltGuesser()
        go cotListen()

        // Monitor RPi CPU temp.
        globalStatus.CPUTempMin = common.InvalidCpuTemp
        globalStatus.CPUTempMax = common.InvalidCpuTemp
        go common.CpuTempMonitor(func(cpuTemp float32) </span><span class="cov0" title="0">{
                globalStatus.CPUTemp = cpuTemp
                if common.IsCPUTempValid(cpuTemp) &amp;&amp; ((cpuTemp &lt; globalStatus.CPUTempMin) || !common.IsCPUTempValid(globalStatus.CPUTempMin)) </span><span class="cov0" title="0">{
                        globalStatus.CPUTempMin = cpuTemp
                }</span>
                <span class="cov0" title="0">if common.IsCPUTempValid(cpuTemp) &amp;&amp; ((cpuTemp &gt; globalStatus.CPUTempMax) || !common.IsCPUTempValid(globalStatus.CPUTempMax)) </span><span class="cov0" title="0">{
                        globalStatus.CPUTempMax = cpuTemp
                }</span>
        })

        // Start reading from serial UAT radio.
        <span class="cov0" title="0">initUATRadioSerial(isTraceReplayMode)

        if isTraceReplayMode </span><span class="cov0" title="0">{
                msgTypes := []string{}
                if len(*traceReplayFilter) &gt; 0 </span><span class="cov0" title="0">{
                        msgTypes = strings.Split(*traceReplayFilter, ",")
                }</span>
                <span class="cov0" title="0">TraceLog.Replay(*traceReplay, *traceReplaySpeed, *traceSkip, msgTypes)
                return</span>
        }

        <span class="cov0" title="0">reader := bufio.NewReader(os.Stdin)

        if *replayFlag == true </span><span class="cov0" title="0">{
                fp := openReplayFile(*replayUATFilename)

                playSpeed := uint64(*replaySpeed)
                log.Printf("Replay speed: %dx\n", playSpeed)
                go uatReplay(fp, playSpeed)

                for </span><span class="cov0" title="0">{
                        time.Sleep(1 * time.Second)
                        if uatReplayDone </span><span class="cov0" title="0">{
                                //&amp;&amp; esDone {
                                return
                        }</span>
                }

        } else<span class="cov0" title="0"> if *stdinFlag == true </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        buf, err := reader.ReadString('\n')
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("lost stdin.\n")
                                break</span>
                        }
                        <span class="cov0" title="0">o, msgtype := parseInput(buf)
                        if o != nil &amp;&amp; msgtype != 0 </span><span class="cov0" title="0">{
                                relayMessage(msgtype, o)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // wait indefinitely
                select </span>{}
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
        Copyright (c) 2015-2016 Christopher Young
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        ---
        gps.go: GPS functions, GPS init, AHRS status messages, other external sensor monitoring.
        compile and install: clear &amp;&amp; make www &amp;&amp; make stratuxrun &amp;&amp; mv stratuxrun /opt/stratux/bin/ &amp;&amp; stxrestart
*/

package main

import (
        "errors"
        "fmt"
        "log"
        "math"
        "strconv"
        "strings"
        "sync"
        "time"

        "bufio"

        "github.com/tarm/serial"

        "os"
        "os/exec"

        "github.com/stratux/stratux/common"
)

const (
        SAT_TYPE_UNKNOWN = 0  // default type
        SAT_TYPE_GPS     = 1  // GPxxx; NMEA IDs 1-32
        SAT_TYPE_GLONASS = 2  // GLxxx; NMEA IDs 65-96
        SAT_TYPE_GALILEO = 3  // GAxxx; NMEA IDs
        SAT_TYPE_BEIDOU  = 4  // GBxxx; NMEA IDs 201-235
        SAT_TYPE_QZSS    = 5  // QZSS
        SAT_TYPE_SBAS    = 10 // NMEA IDs 33-54
)

const (
        BARO_TYPE_NONE         = 0 // No baro present
        BARO_TYPE_BMP280       = 1 // Stratux AHRS module or similar internal baro
        BARO_TYPE_OGNTRACKER   = 2 // OGN Tracker with baro pressure
        BARO_TYPE_NMEA         = 3 // Other NMEA provider that reports $PGRMZ (SoftRF)
        BARO_TYPE_ADSBESTIMATE = 4 // If we have no baro, we will try to estimate baro pressure from ADS-B targets reporting GnssDiffFromBaroAlt (HAE&lt;-&gt;Baro difference)
)

type SatelliteInfo struct {
        SatelliteNMEA    uint8     // NMEA ID of the satellite. 1-32 is GPS, 33-54 is SBAS, 65-88 is Glonass.
        SatelliteID      string    // Formatted code indicating source and PRN code. e.g. S138==WAAS satellite 138, G2==GPS satellites 2
        Elevation        int16     // Angle above local horizon, -xx to +90
        Azimuth          int16     // Bearing (degrees true), 0-359
        Signal           int8      // Signal strength, 0 - 99; -99 indicates no reception
        Type             uint8     // Type of satellite (GPS, GLONASS, Galileo, SBAS)
        TimeLastSolution time.Time // Time (system ticker) a solution was last calculated using this satellite
        TimeLastSeen     time.Time // Time (system ticker) a signal was last received from this satellite
        TimeLastTracked  time.Time // Time (system ticker) this satellite was tracked (almanac data)
        InSolution       bool      // True if satellite is used in the position solution (reported by GSA message or PUBX,03)
}

type SituationData struct {
        // From GPS.
        muGPS                       *sync.Mutex
        muGPSPerformance            *sync.Mutex
        muSatellite                 *sync.Mutex
        GPSLastFixSinceMidnightUTC  float32
        GPSLatitude                 float32
        GPSLongitude                float32
        GPSFixQuality               uint8
        GPSHeightAboveEllipsoid     float32 // GPS height above WGS84 ellipsoid, ft. This is specified by the GDL90 protocol, but most EFBs use MSL altitude instead. HAE is about 70-100 ft below GPS MSL altitude over most of the US.
        GPSGeoidSep                 float32 // geoid separation, ft, MSL minus HAE (used in altitude calculation)
        GPSSatellites               uint16  // satellites used in solution
        GPSSatellitesTracked        uint16  // satellites tracked (almanac data received)
        GPSSatellitesSeen           uint16  // satellites seen (signal received)
        GPSHorizontalAccuracy       float32 // 95% confidence for horizontal position, meters.
        GPSNACp                     uint8   // NACp categories are defined in AC 20-165A
        GPSAltitudeMSL              float32 // Feet MSL
        GPSVerticalAccuracy         float32 // 95% confidence for vertical position, meters
        GPSVerticalSpeed            float32 // GPS vertical velocity, feet per second
        GPSLastFixLocalTime         time.Time
        GPSTrueCourse               float32
        GPSTurnRate                 float64 // calculated GPS rate of turn, degrees per second
        GPSGroundSpeed              float64
        GPSLastGroundTrackTime      time.Time
        GPSTime                     time.Time
        GPSLastGPSTimeStratuxTime   time.Time // stratuxClock time since last GPS time received.
        GPSLastValidNMEAMessageTime time.Time // time valid NMEA message last seen
        GPSLastValidNMEAMessage     string    // last NMEA message processed.
        GPSLastAccuracyTime         time.Time // time of last GNGST
        GPSPositionSampleRate       float64   // calculated sample rate of GPS positions

        // From pressure sensor.
        muBaro                  *sync.Mutex
        BaroTemperature         float32
        BaroPressureAltitude    float32
        BaroVerticalSpeed       float32
        BaroLastMeasurementTime time.Time
        BaroSourceType          uint8

        // From AHRS source.
        muAttitude           *sync.Mutex
        AHRSPitch            float64
        AHRSRoll             float64
        AHRSGyroHeading      float64
        AHRSMagHeading       float64
        AHRSSlipSkid         float64
        AHRSTurnRate         float64
        AHRSGLoad            float64
        AHRSGLoadMin         float64
        AHRSGLoadMax         float64
        AHRSLastAttitudeTime time.Time
        AHRSStatus           uint8
}

/*
myGPSPerfStats used to track short-term position / velocity trends, used to feed dynamic AHRS model. Use floats for better resolution of calculated data.
*/
type gpsPerfStats struct {
        stratuxTime   uint64  // time since Stratux start, msec
        nmeaTime      float32 // timestamp from NMEA message
        msgType       string  // NMEA message type
        gsf           float32 // knots
        coursef       float32 // true course [degrees]
        alt           float32 // gps altitude, ft msl
        vv            float32 // vertical velocity, ft/sec
        gpsTurnRate   float64 // calculated turn rate, deg/sec. Right turn is positive.
        gpsPitch      float64 // estimated pitch angle, deg. Calculated from gps ground speed and VV. Equal to flight path angle.
        gpsRoll       float64 // estimated roll angle from turn rate and groundspeed, deg. Assumes airplane in coordinated turns.
        gpsLoadFactor float64 // estimated load factor from turn rate and groundspeed, "gee". Assumes airplane in coordinated turns.
        //TODO: valid/invalid flag.
}

var gpsPerf gpsPerfStats
var myGPSPerfStats []gpsPerfStats
var gpsTimeOffsetPpsMs = 100.0 * time.Millisecond

var serialConfig *serial.Config
var serialPort *serial.Port

var readyToInitGPS bool //TODO: replace with channel control to terminate goroutine when complete

var Satellites map[string]SatelliteInfo

var trackerDrivers []Tracker = []Tracker{&amp;OgnTracker{}, &amp;GxAirCom{}, &amp;SoftRF{}}
var detectedTracker Tracker

/*
u-blox5_Referenzmanual.pdf
Platform settings
Airborne &lt;2g Recommended for typical airborne environment. No 2D position fixes supported.
p.91 - CFG-MSG
Navigation/Measurement Rate Settings
Header 0xB5 0x62
ID 0x06 0x08
0x0064 (100 ms)
0x0001
0x0001 (GPS time)
{0xB5, 0x62, 0x06, 0x08, 0x00, 0x64, 0x00, 0x01, 0x00, 0x01}
p.109 CFG-NAV5 (0x06 0x24)
Poll Navigation Engine Settings
*/

/*
        chksumUBX()
                returns the two-byte Fletcher algorithm checksum of byte array msg.
                This is used in configuration messages for the u-blox GPS. See p. 97 of the
                u-blox M8 Receiver Description.
*/

func chksumUBX(msg []byte) []byte <span class="cov4" title="13">{
        ret := make([]byte, 2)
        for i := 0; i &lt; len(msg); i++ </span><span class="cov10" title="659">{
                ret[0] = ret[0] + msg[i]
                ret[1] = ret[1] + ret[0]
        }</span>
        <span class="cov4" title="13">return ret</span>
}

/*
makeUBXCFG()

        creates a UBX-formatted package consisting of two sync characters,
        class, ID, payload length in bytes (2-byte little endian), payload, and checksum.
        See p. 95 of the u-blox M8 Receiver Description.
*/
func makeUBXCFG(class, id byte, msglen uint16, msg []byte) []byte <span class="cov2" title="3">{
        ret := make([]byte, 6)
        ret[0] = 0xB5
        ret[1] = 0x62
        ret[2] = class
        ret[3] = id
        ret[4] = byte(msglen &amp; 0xFF)
        ret[5] = byte((msglen &gt;&gt; 8) &amp; 0xFF)
        ret = append(ret, msg...)
        chk := chksumUBX(ret[2:])
        ret = append(ret, chk[0])
        ret = append(ret, chk[1])
        return ret
}</span>

func makeNMEACmd(cmd string) []byte <span class="cov2" title="3">{
        chk_sum := byte(0)
        for i := range cmd </span><span class="cov6" title="46">{
                chk_sum = chk_sum ^ byte(cmd[i])
        }</span>
        <span class="cov2" title="3">return []byte(fmt.Sprintf("$%s*%02x\x0d\x0a", cmd, chk_sum))</span>
}

func logChipConfig(line1 string, chip string, device string, baudrate int, append string) <span class="cov0" title="0">{
        if line1 == "auto" </span><span class="cov0" title="0">{
                logInf("Gps - autodected gps, using following parameters:")
        }</span> else<span class="cov0" title="0"> if line1 == "man" </span><span class="cov0" title="0">{
                logInf("GPS - manual configuration with following parameters from /boot/firmware/stratux.conf:")
        }</span>
        <span class="cov0" title="0">msg := "GPS - chip: %s, device: %s, baudrate: %d"
        if append != "" </span><span class="cov0" title="0">{
                msg += ", " + append
        }</span>
        <span class="cov0" title="0">logInf(msg, chip, device, baudrate)</span>
}

func initGPSSerial() bool <span class="cov0" title="0">{
        var device string
        var targetBaudRate int = 115200
        if (globalStatus.GPS_detected_type &amp; 0x0f) == GPS_TYPE_NETWORK </span><span class="cov0" title="0">{
                return true
        }</span>
        // Possible baud rates for this device. We will try to auto detect the correct one
        <span class="cov0" title="0">baudrates := []int{int(9600)}
        isSirfIV := bool(false)
        globalStatus.GPS_detected_type = 0 // reset detected type on each initialization
        detectedTracker = nil

        if globalSettings.GpsManualConfig </span><span class="cov0" title="0">{
                //logInf("GPS - manual configuration with parameters from /boot/firmware/stratux.conf:")

                var chip string = globalSettings.GpsManualChip
                device = globalSettings.GpsManualDevice
                targetBaudRate = globalSettings.GpsManualTargetBaud
                baudrates = []int{115200, 38400, 9600, 230400, 500000, 1000000, 2000000}

                switch chip </span>{
                case "ublox6":<span class="cov0" title="0"></span>
                case "ublox7":<span class="cov0" title="0">
                        globalStatus.GPS_detected_type = GPS_TYPE_UBX6or7
                        logChipConfig("man", "ublox 6 or 7", device, targetBaudRate, "")
                        break</span>
                case "ublox8":<span class="cov0" title="0">
                        globalStatus.GPS_detected_type = GPS_TYPE_UBX8
                        logChipConfig("man", "ublox 8", device, targetBaudRate, "")
                        break</span>
                case "ublox9":<span class="cov0" title="0">
                        globalStatus.GPS_detected_type = GPS_TYPE_UBX9
                        logChipConfig("man", "ublox 9", device, targetBaudRate, "")
                        break</span>
                case "ublox10":<span class="cov0" title="0">
                        globalStatus.GPS_detected_type = GPS_TYPE_UBX10
                        logChipConfig("man", "ublox 10", device, targetBaudRate, "")
                        break</span>
                case "ublox":<span class="cov0" title="0">
                        globalStatus.GPS_detected_type = GPS_TYPE_UBX_GEN
                        logChipConfig("man", "generic ublox", device, targetBaudRate, "")
                        break</span>
                default:<span class="cov0" title="0">
                        globalStatus.GPS_detected_type = GPS_TYPE_ANY
                        logInf("GPS - configuring gps chip as other -&gt; no further configuration will be done, use gps as it is")</span>
                }

        } else<span class="cov0" title="0"> if _, err := os.Stat("/dev/ublox9"); err == nil </span><span class="cov0" title="0">{
                device = "/dev/ublox9"
                globalStatus.GPS_detected_type = GPS_TYPE_UBX9
                logChipConfig("auto", "ublox 9", device, targetBaudRate, "")

        }</span> else<span class="cov0" title="0"> if _, err := os.Stat("/dev/ublox8"); err == nil </span><span class="cov0" title="0">{ // u-blox 8 (RY83xAI or GPYes 2.0).
                device = "/dev/ublox8"
                globalStatus.GPS_detected_type = GPS_TYPE_UBX8
                gpsTimeOffsetPpsMs = 80 * time.Millisecond // Ublox 8 seems to have higher delay
                logChipConfig("auto", "ublox 8", device, targetBaudRate, "")

        }</span> else<span class="cov0" title="0"> if _, err := os.Stat("/dev/ublox7"); err == nil </span><span class="cov0" title="0">{ // u-blox 7 (VK-172, VK-162 Rev 2, GPYes, RY725AI over USB).
                device = "/dev/ublox7"
                globalStatus.GPS_detected_type = GPS_TYPE_UBX6or7
                logChipConfig("auto", "ublox 7", device, targetBaudRate, "")

        }</span> else<span class="cov0" title="0"> if _, err := os.Stat("/dev/ublox6"); err == nil </span><span class="cov0" title="0">{ // u-blox 6 (VK-162 Rev 1).
                device = "/dev/ublox6"
                globalStatus.GPS_detected_type = GPS_TYPE_UBX6or7
                logChipConfig("auto", "ublox 6", device, targetBaudRate, "")

        }</span> else<span class="cov0" title="0"> if _, err := os.Stat("/dev/prolific0"); err == nil </span><span class="cov0" title="0">{ // Assume it's a BU-353-S4 SIRF IV.
                //TODO: Check a "serialout" flag and/or deal with multiple prolific devices.
                isSirfIV = true
                // default to 4800 for SiRFStar config port, we then change and detect it with 38400.
                // We also try 9600 just in case this is something else, as this is the most popular value
                baudrates = []int{4800, 38400, 9600}
                device = "/dev/prolific0"
                globalStatus.GPS_detected_type = GPS_TYPE_PROLIFIC
        }</span> else<span class="cov0" title="0"> if _, err := os.Stat("/dev/serialin"); err == nil </span><span class="cov0" title="0">{
                device = "/dev/serialin"
                globalStatus.GPS_detected_type = GPS_TYPE_SERIAL
                // OGN Tracker uses 115200, SoftRF 38400
                baudrates = []int{115200, 38400, 9600}
        }</span> else<span class="cov0" title="0"> if _, err := os.Stat("/dev/softrf_dongle"); err == nil </span><span class="cov0" title="0">{
                device = "/dev/softrf_dongle"
                globalStatus.GPS_detected_type = GPS_TYPE_SOFTRF_DONGLE
                baudrates[0] = 115200
        }</span> else<span class="cov0" title="0"> if _, err := os.Stat("/dev/serial0"); err == nil </span><span class="cov0" title="0">{
                // ttyS0 is PL011 UART (GPIO pins 8 and 10) on all RPi.
                // assume that any GPS connected to serial GPIO is ublox
                device = "/dev/serial0"
                globalStatus.GPS_detected_type = GPS_TYPE_UBX_GEN
                baudrates = []int{115200, 38400, 9600}
                logInf("GPS - device detected at serial port /dev/serial0, assuming this is an ublox device, configuring as generic ublox:")
                logChipConfig("", "generic ublox", device, targetBaudRate, "")
                logInf("GPS - consider to configure this device manually in /boot/firmware/stratux.conf for optimal performance")
        }</span> else<span class="cov0" title="0"> {
                logDbg("GPS - no gps device found.\n")
                return false
        }</span>

        <span class="cov0" title="0">logDbg("GPS - using device: %s", device)

        // try to open port with previously defined baud rate
        // port remains opend if detectOpenSerialPort finds matching baurate parameter
        // and will be closed after reprogramming.

        p, err := detectOpenSerialPort(device, baudrates)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("GPS - serial port/baudrate detection err: %s\n", err.Error())
                return false
        }</span>
        <span class="cov0" title="0">baudChanged := false

        if isSirfIV </span><span class="cov0" title="0">{
                log.Printf("Using SiRFIV config.\n")

                // Enable 5Hz. (To switch back to 1Hz: $PSRF103,00,7,00,0*22)
                p.Write(makeNMEACmd("PSRF103,00,6,00,0"))
                // Enable GGA.
                p.Write(makeNMEACmd("PSRF103,00,00,01,01"))
                // Enable GSA.
                p.Write(makeNMEACmd("PSRF103,02,00,01,01"))
                // Enable RMC.
                p.Write(makeNMEACmd("PSRF103,04,00,01,01"))
                // Enable VTG.
                p.Write(makeNMEACmd("PSRF103,05,00,01,01"))
                // Enable GSV (once every 5 position updates)
                p.Write(makeNMEACmd("PSRF103,03,00,05,01"))
                // Enable 38400 baud.
                p.Write(makeNMEACmd("PSRF100,1,38400,8,1,0"))
                baudChanged = true

                if globalSettings.DEBUG </span><span class="cov0" title="0">{
                        log.Printf("Finished writing SiRF GPS config to %s. Opening port to test connection.\n", device)
                }</span>
        } else<span class="cov0" title="0"> if globalStatus.GPS_detected_type == GPS_TYPE_UBX6or7 ||
                globalStatus.GPS_detected_type == GPS_TYPE_UBX8 ||
                globalStatus.GPS_detected_type == GPS_TYPE_UBX9 ||
                globalStatus.GPS_detected_type == GPS_TYPE_UBX10 ||
                globalStatus.GPS_detected_type == GPS_TYPE_UBX_GEN </span><span class="cov0" title="0">{

                // Byte order for UBX configuration is little endian.

                // GNSS configuration CFG-GNSS for ublox 7 and higher, p. 125 (v8)

                // Notes: ublox8 is multi-GNSS capable (simultaneous decoding of GPS and GLONASS, or
                // GPS and Galileo) if SBAS (e.g. WAAS) is unavailable. This may provide robustness
                // against jamming / interference on one set of frequencies. However, this will drop the
                // position reporting rate to 5 Hz during times multi-GNSS is in use. This shouldn't affect
                // gpsattitude too much --  without WAAS corrections, the algorithm could get jumpy at higher
                // sampling rates.

                // load default configuration             |      clearMask     |  |     saveMask       |  |     loadMask       |  deviceMask
                //p.Write(makeUBXCFG(0x06, 0x09, 13, []byte{0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x03}))
                //time.Sleep(100* time.Millisecond) // pause and wait for the GPS to finish configuring itself before closing / reopening the port

                if globalStatus.GPS_detected_type == GPS_TYPE_UBX9 </span><span class="cov0" title="0">{
                        logDbg("GPS - configuring as ublox 9\n")
                        // ublox 9
                        writeUblox9ConfigCommands(p)
                }</span> else<span class="cov0" title="0"> if globalStatus.GPS_detected_type == GPS_TYPE_UBX8 </span><span class="cov0" title="0">{
                        logDbg("GPS - configuring as ublox 8\n")
                        // ublox 8
                        writeUblox8ConfigCommands(p)
                }</span> else<span class="cov0" title="0"> if globalStatus.GPS_detected_type == GPS_TYPE_UBX6or7 </span><span class="cov0" title="0">{
                        logDbg("GPS - configuring as ublox 6 or 7\n")
                        // ublox 6,7
                        cfgGnss := []byte{0x00, 0x00, 0xFF, 0x04}                         // numTrkChUse=0xFF: number of tracking channels to use will be set to number of tracking channels available in hardware
                        gps := []byte{0x00, 0x04, 0xFF, 0x00, 0x01, 0x00, 0x01, 0x01}     // enable GPS with 4-255 channels (ublox default)
                        sbas := []byte{0x01, 0x01, 0x03, 0x00, 0x01, 0x00, 0x01, 0x01}    // enable SBAS with 1-3 channels (ublox default)
                        qzss := []byte{0x05, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x01}    // enable QZSS with 0-3 channel (ublox default)
                        glonass := []byte{0x06, 0x08, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x01} // disable GLONASS (ublox default)
                        cfgGnss = append(cfgGnss, gps...)
                        cfgGnss = append(cfgGnss, sbas...)
                        cfgGnss = append(cfgGnss, qzss...)
                        cfgGnss = append(cfgGnss, glonass...)
                        p.Write(makeUBXCFG(0x06, 0x3E, uint16(len(cfgGnss)), cfgGnss))
                }</span>

                <span class="cov0" title="0">writeUbloxGenericCommands(10, p)

                // Reconfigure serial port.
                cfg := make([]byte, 20)
                cfg[0] = 0x01 // portID.
                cfg[1] = 0x00 // res0.
                cfg[2] = 0x00 // res1.
                cfg[3] = 0x00 // res1.

                //      [   7   ] [   6   ] [   5   ] [   4   ]
                //        0000 0000 0000 0000 0000 10x0 1100 0000
                // UART mode. 0 stop bits, no parity, 8 data bits. Little endian order.
                cfg[4] = 0xC0
                cfg[5] = 0x08
                cfg[6] = 0x00
                cfg[7] = 0x00

                // Baud rate. Little endian order.
                bdrt := uint32(targetBaudRate)
                cfg[11] = byte((bdrt &gt;&gt; 24) &amp; 0xFF)
                cfg[10] = byte((bdrt &gt;&gt; 16) &amp; 0xFF)
                cfg[9] = byte((bdrt &gt;&gt; 8) &amp; 0xFF)
                cfg[8] = byte(bdrt &amp; 0xFF)

                // inProtoMask. NMEA and UBX. Little endian.
                cfg[12] = 0x03
                cfg[13] = 0x00

                // outProtoMask. NMEA. Little endian.
                cfg[14] = 0x02
                cfg[15] = 0x00

                cfg[16] = 0x00 // flags.
                cfg[17] = 0x00 // flags.

                cfg[18] = 0x00 //pad.
                cfg[19] = 0x00 //pad.

                // UBX-CFG-PRT (Port Configuration for UART)
                p.Write(makeUBXCFG(0x06, 0x00, 20, cfg))

                //baudrates[0] = int(bdrt)   // replaced by line below -&gt; insert at pos 0 instead of overwriting ...
                baudrates = append([]int{targetBaudRate}, baudrates...)
                baudChanged = true
                logDbg("GPS - finished writing u-blox GPS config to %s. Opening port to test connection.\n", device)</span>
        } else<span class="cov0" title="0"> if globalStatus.GPS_detected_type == GPS_TYPE_SOFTRF_DONGLE </span><span class="cov0" title="0">{
                p.Write([]byte("@GNS 0x7\r\n"))    // enable SBAS
                time.Sleep(250 * time.Millisecond) // Otherwise second command doesn't seem to work?
                p.Write([]byte("@BSSL 0x2D\r\n"))  // enable GNGSV
        }</span>

        <span class="cov0" title="0">if baudChanged </span><span class="cov0" title="0">{
                p.Close()

                time.Sleep(250 * time.Millisecond)

                // Re-open port at newly configured baud so we can read messages. ReadTimeout is set to keep from blocking the gpsSerialReader() on misconfigures or ttyAMA disconnects
                p, err = detectOpenSerialPort(device, baudrates)
                if err != nil </span><span class="cov0" title="0">{
                        logErr("GPS - serial port err: %s\n", err.Error())
                        return false
                }</span>
        }

        <span class="cov0" title="0">serialPort = p

        for _, tracker := range trackerDrivers </span><span class="cov0" title="0">{
                tracker.initNewConnection(serialPort)
        }</span>
        <span class="cov0" title="0">return true</span>

}

func detectOpenSerialPort(device string, baudrates []int) (*(serial.Port), error) <span class="cov0" title="0">{
        if len(baudrates) == 1 </span><span class="cov0" title="0">{
                serialConfig := &amp;serial.Config{Name: device, Baud: baudrates[0], ReadTimeout: time.Millisecond * 2500}
                return serial.OpenPort(serialConfig)
        }</span> else<span class="cov0" title="0"> {
                for _, baud := range baudrates </span><span class="cov0" title="0">{
                        logDbg("GPS - trying to open serial with %d baud ...", baud)
                        serialConfig := &amp;serial.Config{Name: device, Baud: baud, ReadTimeout: time.Millisecond * 2500}
                        p, err := serial.OpenPort(serialConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                return p, err
                        }</span>
                        <span class="cov0" title="0">p.Flush() // make sure input buffer is clean..

                        // Check if we get any data...
                        time.Sleep(3 * time.Second)
                        buffer := make([]byte, 10000)
                        p.Read(buffer)
                        splitted := strings.Split(string(buffer), "\n")
                        for _, line := range splitted </span><span class="cov0" title="0">{
                                _, validNMEAcs := validateNMEAChecksum(line)
                                if validNMEAcs </span><span class="cov0" title="0">{
                                        // looks a lot like NMEA.. use it
                                        logInf("GPS - successfully opened serial port %s with baud %d   (Valid NMEA msg received)", device, baud)
                                        // Make sure the NMEA is immediately parsed once, so updateStatus() doesn't see the GPS as disconnected before
                                        // first msg arrives
                                        processNMEALine(line)
                                        return p, nil
                                }</span>
                        }
                        <span class="cov0" title="0">logDbg("GPS - could not open serial port with %d baud, no valid NMea received ...", baud)
                        p.Close()
                        time.Sleep(250 * time.Millisecond)</span>
                }
                <span class="cov0" title="0">logErr("GPS - none of the baud rates worked, gps not connected ...")
                return nil, errors.New("GPS - Failed to detect gps serial baud rate")</span>
        }
}

func writeUblox8ConfigCommands(p *serial.Port) <span class="cov0" title="0">{
        cfgGnss := []byte{0x00, 0x00, 0xFF, 0x05}                         // numTrkChUse=0xFF: number of tracking channels to use will be set to number of tracking channels available in hardware
        gps := []byte{0x00, 0x08, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01}     // enable GPS with 8-16 channels (ublox default)
        sbas := []byte{0x01, 0x01, 0x03, 0x00, 0x01, 0x00, 0x01, 0x01}    // enable SBAS with 1-3 channels (ublox default)
        galileo := []byte{0x02, 0x08, 0x08, 0x00, 0x01, 0x00, 0x01, 0x01} // enable Galileo with 8-8 channels (ublox default: disabled and 4-8 channels)
        beidou := []byte{0x03, 0x08, 0x10, 0x00, 0x00, 0x00, 0x01, 0x01}  // disable BEIDOU
        qzss := []byte{0x05, 0x01, 0x03, 0x00, 0x01, 0x00, 0x01, 0x01}    // enable QZSS 1-3 channels, L1C/A (ublox default: 0-3 channels)
        glonass := []byte{0x06, 0x08, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01} // enable GLONASS with 8-16 channels (ublox default: 8-14 channels)

        cfgGnss = append(cfgGnss, gps...)
        cfgGnss = append(cfgGnss, sbas...)
        cfgGnss = append(cfgGnss, beidou...)
        cfgGnss = append(cfgGnss, qzss...)
        cfgGnss = append(cfgGnss, glonass...)
        p.Write(makeUBXCFG(0x06, 0x3E, uint16(len(cfgGnss)), cfgGnss)) // Succeeds on all chips supporting GPS+GLO

        cfgGnss[3] = 0x06
        cfgGnss = append(cfgGnss, galileo...)
        p.Write(makeUBXCFG(0x06, 0x3E, uint16(len(cfgGnss)), cfgGnss)) // Succeeds only on chips that support GPS+GLO+GAL
}</span>

func writeUblox9ConfigCommands(p *serial.Port) <span class="cov0" title="0">{
        cfgGnss := []byte{0x00, 0x00, 0xFF, 0x06}                         // numTrkChUse=0xFF: number of tracking channels to use will be set to number of tracking channels available in hardware
        gps := []byte{0x00, 0x08, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01}     // enable GPS with 8-16 channels (ublox default)
        sbas := []byte{0x01, 0x03, 0x03, 0x00, 0x01, 0x00, 0x01, 0x01}    // enable SBAS with 3-3 channels (ublox default)
        galileo := []byte{0x02, 0x08, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01} // enable Galileo with 8-16 channels (ublox default: 8-12 channels)
        beidou := []byte{0x03, 0x08, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01}  // enable BEIDOU with 8-16 channels (ublox default: 2-5 channels)
        qzss := []byte{0x05, 0x03, 0x04, 0x00, 0x01, 0x00, 0x05, 0x01}    // enable QZSS 3-4 channels, L1C/A &amp; L1S (ublox default)
        glonass := []byte{0x06, 0x08, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01} // enable GLONASS with 8-16 tracking channels (ublox default: 8-12 channels)

        cfgGnss = append(cfgGnss, gps...)
        cfgGnss = append(cfgGnss, sbas...)
        cfgGnss = append(cfgGnss, beidou...)
        cfgGnss = append(cfgGnss, qzss...)
        cfgGnss = append(cfgGnss, glonass...)
        cfgGnss = append(cfgGnss, galileo...)
        p.Write(makeUBXCFG(0x06, 0x3E, uint16(len(cfgGnss)), cfgGnss))
}</span>

func writeUbloxGenericCommands(navrate uint16, p *serial.Port) <span class="cov0" title="0">{
        // UBX-CFG-TP5 (turn off "time pulse" which usually drives the GPS LED)
        tp5 := make([]byte, 32)
        tp5[4] = 0x32
        tp5[8] = 0x40
        tp5[9] = 0x42
        tp5[10] = 0x0F
        tp5[12] = 0x40
        tp5[13] = 0x42
        tp5[14] = 0x0F
        tp5[28] = 0xE7
        p.Write(makeUBXCFG(0x06, 0x31, 32, tp5))

        // UBX-CFG-NMEA (change NMEA protocol version to 4.0 extended)
        p.Write(makeUBXCFG(0x06, 0x17, 20, []byte{0x00, 0x40, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}))

        // UBX-CFG-NAV5                           |mask1...|  dyn
        p.Write(makeUBXCFG(0x06, 0x24, 36, []byte{0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})) // Dynamic platform model: airborne with &lt;2g acceleration

        // UBX-CFG-SBAS (disable integrity, enable auto-scan)
        p.Write(makeUBXCFG(0x06, 0x16, 8, []byte{0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}))

        // UBX-CFG-MSG (NMEA Standard Messages)  msg   msg   Ports 1-6 (every 10th message over UART1, every message over USB)
        //                                       Class ID    I2C   UART1 UART2 USB   SPI   Res
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00})) // GGA - Global positioning system fix data
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})) // GLL - Latitude and longitude, with time of position fix and status
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x02, 0x00, 0x05, 0x00, 0x05, 0x00, 0x00})) // GSA - GNSS DOP and Active Satellites
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x03, 0x00, 0x05, 0x00, 0x05, 0x00, 0x00})) // GSV - GNSS Satellites in View
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x04, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00})) // RMC - Recommended Minimum data
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x05, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00})) // VGT - Course over ground and Ground speed
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})) // GRS - GNSS Range Residuals
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x07, 0x00, 0x05, 0x00, 0x05, 0x00, 0x00})) // GST - GNSS Pseudo Range Error Statistics
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})) // ZDA - Time and Date&lt;
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})) // GBS - GNSS Satellite Fault Detection
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})) // DTM - Datum Reference
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})) // GNS - GNSS fix data
        // p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})) // ???
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})) // VLW - Dual ground/water distance

        // UBX-CFG-MSG (NMEA PUBX Messages)      msg   msg   Ports 1-6
        //                                       Class ID    I2C   UART1 UART2 USB   SPI   Res
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})) // Ublox - Lat/Long Position Data
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF1, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})) // Ublox - Satellite Status
        p.Write(makeUBXCFG(0x06, 0x01, 8, []byte{0xF1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})) // Ublox - Time of Day and Clock Information

        if navrate == 10 </span><span class="cov0" title="0">{
                p.Write(makeUBXCFG(0x06, 0x08, 6, []byte{0x64, 0x00, 0x01, 0x00, 0x01, 0x00})) // 100ms &amp; 1 cycle -&gt; 10Hz (UBX-CFG-RATE payload bytes: little endian!)
        }</span> else<span class="cov0" title="0"> if navrate == 5 </span><span class="cov0" title="0">{
                p.Write(makeUBXCFG(0x06, 0x08, 6, []byte{0xC8, 0x00, 0x01, 0x00, 0x01, 0x00})) // 200ms &amp; 1 cycle -&gt; 5Hz (UBX-CFG-RATE payload bytes: little endian!)
        }</span> else<span class="cov0" title="0"> if navrate == 2 </span><span class="cov0" title="0">{
                p.Write(makeUBXCFG(0x06, 0x08, 6, []byte{0xF4, 0x01, 0x01, 0x00, 0x01, 0x00})) // 500ms &amp; 1 cycle -&gt; 2Hz (UBX-CFG-RATE payload bytes: little endian!)
        }</span> else<span class="cov0" title="0"> if navrate == 1 </span><span class="cov0" title="0">{
                p.Write(makeUBXCFG(0x06, 0x08, 6, []byte{0xE8, 0x03, 0x01, 0x00, 0x01, 0x00})) // 1000ms &amp; 1 cycle -&gt; 1Hz (UBX-CFG-RATE payload bytes: little endian!)
        }</span>

        <span class="cov0" title="0">logDbg("GPS - applying generic ublox settings (refresh rate: %d)", navrate)</span>
}

func writeTrackerConfigFromSettings() <span class="cov0" title="0">{
        tracker := detectedTracker
        if tracker != nil </span><span class="cov0" title="0">{
                changed := tracker.writeConfigFromSettings(serialPort)
                if !changed </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">delay := tracker.writeReadDelay()
                go func() </span><span class="cov0" title="0">{
                        time.Sleep(delay)
                        if tracker == detectedTracker </span><span class="cov0" title="0">{
                                detectedTracker.requestTrackerConfig(serialPort)
                        }</span>
                }()
        }
}

// func validateNMEAChecksum determines if a string is a properly formatted NMEA sentence with a valid checksum.
//
// If the input string is valid, output is the input stripped of the "$" token and checksum, along with a boolean 'true'
// If the input string is the incorrect format, the checksum is missing/invalid, or checksum calculation fails, an error string and
// boolean 'false' are returned
//
// Checksum is calculated as XOR of all bytes between "$" and "*"

func validateNMEAChecksum(s string) (string, bool) <span class="cov4" title="9">{
        //validate format. NMEA sentences start with "$" and end in "*xx" where xx is the XOR value of all bytes between
        if !(strings.HasPrefix(s, "$") &amp;&amp; strings.Contains(s, "*")) </span><span class="cov1" title="2">{
                return "", false
        }</span>

        // strip leading "$" and split at "*"
        <span class="cov3" title="7">s_split := strings.Split(strings.TrimPrefix(s, "$"), "*")
        s_out := s_split[0]
        s_cs := s_split[1]

        if len(s_cs) &lt; 2 </span><span class="cov1" title="2">{
                return "Missing checksum. Fewer than two bytes after asterisk", false
        }</span>

        <span class="cov3" title="5">cs, err := strconv.ParseUint(s_cs[:2], 16, 8)
        if err != nil </span><span class="cov1" title="1">{
                return "Invalid checksum", false
        }</span>

        <span class="cov2" title="4">cs_calc := byte(0)
        for i := range s_out </span><span class="cov8" title="189">{
                cs_calc = cs_calc ^ byte(s_out[i])
        }</span>

        <span class="cov2" title="4">if cs_calc != byte(cs) </span><span class="cov1" title="1">{
                return fmt.Sprintf("Checksum failed. Calculated %#X; expected %#X", cs_calc, cs), false
        }</span>

        <span class="cov2" title="3">return s_out, true</span>
}

//        Only count this heading if a "sustained" &gt;7 kts is obtained. This filters out a lot of heading
//        changes while on the ground and "movement" is really only changes in GPS fix as it settles down.
//
// TODO: Some more robust checking above current and last speed.
// TODO: Dynamic adjust for gain based on groundspeed
func setTrueCourse(groundSpeed uint16, trueCourse float64) <span class="cov0" title="0">{
        if mySituation.GPSGroundSpeed &gt;= 7 &amp;&amp; groundSpeed &gt;= 7 </span><span class="cov0" title="0">{
                // This was previously used to filter small ground speed spikes caused by GPS position drift.
                //  It was passed to the previous AHRS heading calculator. Currently unused, maybe in the future it will be.
                _ = trueCourse
                _ = groundSpeed
        }</span>
}

/*
calcGPSAttitude estimates turn rate, pitch, and roll based on recent GPS groundspeed, track, and altitude / vertical speed.

Method uses stored performance statistics from myGPSPerfStats[]. Ideally, calculation is based on most recent 1.5 seconds of data,
assuming 10 Hz sampling frequency. Lower frequency sample rates will increase calculation window for smoother response, at the
cost of slightly increased lag.

(c) 2016 Keith Tschohl. All rights reserved.
Distributable under the terms of the "BSD-New" License that can be found in
the LICENSE file, herein included as part of this header.
*/

func calcGPSAttitude() bool <span class="cov0" title="0">{
        // check slice length. Return error if empty set or set zero values
        mySituation.muGPSPerformance.Lock()
        defer mySituation.muGPSPerformance.Unlock()
        length := len(myGPSPerfStats)
        index := length - 1

        if length == 0 </span><span class="cov0" title="0">{
                log.Printf("GPS attitude: No data received yet. Not calculating attitude.\n")
                return false
        }</span> else<span class="cov0" title="0"> if length == 1 </span><span class="cov0" title="0">{
                //log.Printf("myGPSPerfStats has one data point. Setting statistics to zero.\n")
                myGPSPerfStats[index].gpsTurnRate = 0
                myGPSPerfStats[index].gpsPitch = 0
                myGPSPerfStats[index].gpsRoll = 0
                return false
        }</span>

        // check if GPS data was put in the structure more than three seconds ago -- this shouldn't happen unless something is wrong.
        <span class="cov0" title="0">if (stratuxClock.Milliseconds - myGPSPerfStats[index].stratuxTime) &gt; 3000 </span><span class="cov0" title="0">{
                myGPSPerfStats[index].gpsTurnRate = 0
                myGPSPerfStats[index].gpsPitch = 0
                myGPSPerfStats[index].gpsRoll = 0
                log.Printf("GPS attitude: GPS data is more than three seconds old. Setting attitude to zero.\n")
                return false
        }</span>

        // check time interval between samples
        <span class="cov0" title="0">t1 := myGPSPerfStats[index].nmeaTime
        t0 := myGPSPerfStats[index-1].nmeaTime
        dt := t1 - t0

        // first time error case: index is more than three seconds ahead of index-1
        if dt &gt; 3 </span><span class="cov0" title="0">{
                log.Printf("GPS attitude: Can't calculate GPS attitude. Reference data is old. dt = %v\n", dt)
                return false
        }</span>

        // second case: index is behind index-1. This could be result of day rollover. If time is within n seconds of UTC,
        // we rebase to the previous day, and will re-rebase the entire slice forward to the current day once all values roll over.
        //TODO: Validate by testing at 0000Z
        <span class="cov0" title="0">if dt &lt; 0 </span><span class="cov0" title="0">{
                log.Printf("GPS attitude: Current GPS time (%.2f) is older than last GPS time (%.2f). Checking for 0000Z rollover.\n", t1, t0)
                if myGPSPerfStats[index-1].nmeaTime &gt; 86300 &amp;&amp; myGPSPerfStats[index].nmeaTime &lt; 100 </span><span class="cov0" title="0">{ // be generous with the time window at rollover
                        myGPSPerfStats[index].nmeaTime += 86400
                }</span> else<span class="cov0" title="0"> {
                        // time decreased, but not due to a recent rollover. Something odd is going on.
                        log.Printf("GPS attitude: Time isn't near 0000Z. Unknown reason for offset. Can't calculate GPS attitude.\n")
                        return false
                }</span>

                // check time array to see if all timestamps are &gt; 86401 seconds since midnight
                <span class="cov0" title="0">var tempTime []float64
                tempTime = make([]float64, length, length)
                for i := 0; i &lt; length; i++ </span><span class="cov0" title="0">{
                        tempTime[i] = float64(myGPSPerfStats[i].nmeaTime)
                }</span>
                <span class="cov0" title="0">minTime, _ := common.ArrayMin(tempTime)
                if minTime &gt; 86401.0 </span><span class="cov0" title="0">{
                        log.Printf("GPS attitude: Rebasing GPS time since midnight to current day.\n")
                        for i := 0; i &lt; length; i++ </span><span class="cov0" title="0">{
                                myGPSPerfStats[i].nmeaTime -= 86400
                        }</span>
                }

                // Verify adjustment
                <span class="cov0" title="0">dt = myGPSPerfStats[index].nmeaTime - myGPSPerfStats[index-1].nmeaTime
                log.Printf("GPS attitude: New dt = %f\n", dt)
                if dt &gt; 3 </span><span class="cov0" title="0">{
                        log.Printf("GPS attitude: Can't calculate GPS attitude. Reference data is old. dt = %v\n", dt)
                        return false
                }</span> else<span class="cov0" title="0"> if dt &lt; 0 </span><span class="cov0" title="0">{
                        log.Printf("GPS attitude: Something went wrong rebasing the time.\n")
                        return false
                }</span>

        }

        // If all of the bounds checks pass, begin processing the GPS data.

        // local variables
        <span class="cov0" title="0">var headingAvg, dh, v_x, v_z, a_c, omega, slope, intercept float64
        var tempHdg, tempHdgUnwrapped, tempHdgTime, tempSpeed, tempVV, tempSpeedTime, tempRegWeights []float64 // temporary arrays for regression calculation
        var valid bool
        var lengthHeading, lengthSpeed int
        var halfwidth float64 // width of regression evaluation window. Minimum of 1.5 seconds and maximum of 3.5 seconds.

        center := float64(myGPSPerfStats[index].nmeaTime) // current time for calculating regression weights

        /*        // frequency detection
                tempSpeedTime = make([]float64, 0)
                for i := 1; i &lt; length; i++ {
                        dt = myGPSPerfStats[i].nmeaTime - myGPSPerfStats[i-1].nmeaTime
                        if dt &gt; 0.05 { // avoid double counting messages with same / similar timestamps
                                tempSpeedTime = append(tempSpeedTime, float64(dt))
                        }
                }
                //log.Printf("Delta time array is %v.\n",tempSpeedTime)
                dt_avg, valid = mean(tempSpeedTime)
                if valid &amp;&amp; dt_avg &gt; 0 {
                        if globalSettings.DEBUG {
                                log.Printf("GPS attitude: Average delta time is %.2f s (%.1f Hz)\n", dt_avg, 1/dt_avg)
                        }
                        halfwidth = 9 * dt_avg
                        mySituation.GPSPositionSampleRate = 1 / dt_avg
                } else {
                        if globalSettings.DEBUG {
                                log.Printf("GPS attitude: Couldn't determine sample rate\n")
                        }
                        halfwidth = 3.5
                        mySituation.GPSPositionSampleRate = 0
                }

                if halfwidth &gt; 3.5 {
                        halfwidth = 3.5 // limit calculation window to 3.5 seconds of data for 1 Hz or slower samples
                } else if halfwidth &lt; 1.5 {
                        halfwidth = 1.5 // use minimum of 1.5 seconds for sample rates faster than 5 Hz
                }
        */
        halfwidth = calculateNavRate()

        //v_x = float64(myGPSPerfStats[index].gsf * 1.687810)
        //v_z = 0

        // first, parse groundspeed from RMC messages.
        tempSpeedTime = make([]float64, 0)
        tempSpeed = make([]float64, 0)
        tempRegWeights = make([]float64, 0)

        for i := 0; i &lt; length; i++ </span><span class="cov0" title="0">{
                if myGPSPerfStats[i].msgType == "GPRMC" || myGPSPerfStats[i].msgType == "GNRMC" </span><span class="cov0" title="0">{
                        tempSpeed = append(tempSpeed, float64(myGPSPerfStats[i].gsf))
                        tempSpeedTime = append(tempSpeedTime, float64(myGPSPerfStats[i].nmeaTime))
                        tempRegWeights = append(tempRegWeights, common.TriCubeWeight(center, halfwidth, float64(myGPSPerfStats[i].nmeaTime)))
                }</span>
        }
        <span class="cov0" title="0">lengthSpeed = len(tempSpeed)
        if lengthSpeed == 0 </span><span class="cov0" title="0">{
                log.Printf("GPS Attitude: No groundspeed data could be parsed from NMEA RMC messages\n")
                return false
        }</span> else<span class="cov0" title="0"> if lengthSpeed == 1 </span><span class="cov0" title="0">{
                v_x = tempSpeed[0] * 1.687810
        }</span> else<span class="cov0" title="0"> {
                slope, intercept, valid = common.LinRegWeighted(tempSpeedTime, tempSpeed, tempRegWeights)
                if !valid </span><span class="cov0" title="0">{
                        log.Printf("GPS attitude: Error calculating speed regression from NMEA RMC position messages")
                        return false
                }</span> else<span class="cov0" title="0"> {
                        v_x = (slope*float64(myGPSPerfStats[index].nmeaTime) + intercept) * 1.687810 // units are knots, converted to feet/sec
                        //log.Printf("Avg speed %f calculated from %d RMC messages\n", v_x, lengthSpeed) // DEBUG
                }</span>
        }

        // next, calculate vertical velocity from GGA altitude data.
        <span class="cov0" title="0">tempSpeedTime = make([]float64, 0)
        tempVV = make([]float64, 0)
        tempRegWeights = make([]float64, 0)

        for i := 0; i &lt; length; i++ </span><span class="cov0" title="0">{
                if myGPSPerfStats[i].msgType == "GPGGA" || myGPSPerfStats[i].msgType == "GNGGA" </span><span class="cov0" title="0">{
                        tempVV = append(tempVV, float64(myGPSPerfStats[i].alt))
                        tempSpeedTime = append(tempSpeedTime, float64(myGPSPerfStats[i].nmeaTime))
                        tempRegWeights = append(tempRegWeights, common.TriCubeWeight(center, halfwidth, float64(myGPSPerfStats[i].nmeaTime)))
                }</span>
        }
        <span class="cov0" title="0">lengthSpeed = len(tempVV)
        if lengthSpeed &lt; 2 </span><span class="cov0" title="0">{
                log.Printf("GPS Attitude: Not enough points to calculate vertical speed from NMEA GGA messages\n")
                return false
        }</span> else<span class="cov0" title="0"> {
                slope, _, valid = common.LinRegWeighted(tempSpeedTime, tempVV, tempRegWeights)
                if !valid </span><span class="cov0" title="0">{
                        log.Printf("GPS attitude: Error calculating vertical speed regression from NMEA GGA messages")
                        return false
                }</span> else<span class="cov0" title="0"> {
                        v_z = slope // units are feet/sec
                        //log.Printf("Avg VV %f calculated from %d GGA messages\n", v_z, lengthSpeed) // DEBUG
                }</span>
        }

        // If we're going too slow for processNMEALine() to give us valid heading data, there's no sense in trying to parse it.
        // However, we need to return a valid level attitude so we don't get the "red X of death" on our AHRS display.
        // This will also eliminate most of the nuisance error message from the turn rate calculation.
        <span class="cov0" title="0">if v_x &lt; 6 </span><span class="cov0" title="0">{ // ~3.55 knots

                myGPSPerfStats[index].gpsPitch = 0
                myGPSPerfStats[index].gpsRoll = 0
                myGPSPerfStats[index].gpsTurnRate = 0
                myGPSPerfStats[index].gpsLoadFactor = 1.0
                mySituation.GPSTurnRate = 0

                // Output format:GPSAtttiude,seconds,nmeaTime,msg_type,GS,Course,Alt,VV,filtered_GS,filtered_course,turn rate,filtered_vv,pitch, roll,load_factor
                buf := fmt.Sprintf("GPSAttitude,%.1f,%.2f,%s,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f\n", float64(stratuxClock.Milliseconds)/1000, myGPSPerfStats[index].nmeaTime, myGPSPerfStats[index].msgType, myGPSPerfStats[index].gsf, myGPSPerfStats[index].coursef, myGPSPerfStats[index].alt, myGPSPerfStats[index].vv, v_x/1.687810, headingAvg, myGPSPerfStats[index].gpsTurnRate, v_z, myGPSPerfStats[index].gpsPitch, myGPSPerfStats[index].gpsRoll, myGPSPerfStats[index].gpsLoadFactor)
                if globalSettings.DEBUG </span><span class="cov0" title="0">{
                        log.Printf("%s", buf) // FIXME. Send to sqlite log or other file?
                }</span>
                <span class="cov0" title="0">logGPSAttitude(myGPSPerfStats[index])
                //replayLog(buf, MSGCLASS_AHRS)

                return true</span>
        }

        // Heading.  Same method used for UBX and generic.
        // First, walk through the PerfStats and parse only valid heading data.
        //log.Printf("Raw heading data:")
        <span class="cov0" title="0">for i := 0; i &lt; length; i++ </span><span class="cov0" title="0">{
                //log.Printf("%.1f,",myGPSPerfStats[i].coursef)
                if myGPSPerfStats[i].coursef &gt;= 0 </span><span class="cov0" title="0">{ // negative values are used to flag invalid / unavailable course
                        tempHdg = append(tempHdg, float64(myGPSPerfStats[i].coursef))
                        tempHdgTime = append(tempHdgTime, float64(myGPSPerfStats[i].nmeaTime))
                }</span>
        }
        //log.Printf("\n")
        //log.Printf("tempHdg: %v\n", tempHdg)

        // Next, unwrap the heading so we don't mess up the regression by fitting a line across the 0/360 deg discontinuity.
        <span class="cov0" title="0">lengthHeading = len(tempHdg)
        tempHdgUnwrapped = make([]float64, lengthHeading, lengthHeading)
        tempRegWeights = make([]float64, lengthHeading, lengthHeading)

        if lengthHeading &gt; 1 </span><span class="cov0" title="0">{
                tempHdgUnwrapped[0] = tempHdg[0]
                tempRegWeights[0] = common.TriCubeWeight(center, halfwidth, tempHdgTime[0])
                for i := 1; i &lt; lengthHeading; i++ </span><span class="cov0" title="0">{
                        tempRegWeights[i] = common.TriCubeWeight(center, halfwidth, tempHdgTime[i])
                        if math.Abs(tempHdg[i]-tempHdg[i-1]) &lt; 180 </span><span class="cov0" title="0">{ // case 1: if angle change is less than 180 degrees, use the same reference system
                                tempHdgUnwrapped[i] = tempHdgUnwrapped[i-1] + tempHdg[i] - tempHdg[i-1]
                        }</span> else<span class="cov0" title="0"> if tempHdg[i] &gt; tempHdg[i-1] </span><span class="cov0" title="0">{ // case 2: heading has wrapped around from NE to NW. Subtract 360 to keep consistent with previous data.
                                tempHdgUnwrapped[i] = tempHdgUnwrapped[i-1] + tempHdg[i] - tempHdg[i-1] - 360
                        }</span> else<span class="cov0" title="0"> { // case 3:  heading has wrapped around from NW to NE. Add 360 to keep consistent with previous data.
                                tempHdgUnwrapped[i] = tempHdgUnwrapped[i-1] + tempHdg[i] - tempHdg[i-1] + 360
                        }</span>
                }
        } else<span class="cov0" title="0"> { //
                if globalSettings.DEBUG </span><span class="cov0" title="0">{
                        log.Printf("GPS attitude: Can't calculate turn rate with less than two points.\n")
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        // Finally, calculate turn rate as the slope of the weighted linear regression of unwrapped heading.
        <span class="cov0" title="0">slope, intercept, valid = common.LinRegWeighted(tempHdgTime, tempHdgUnwrapped, tempRegWeights)

        if !valid </span><span class="cov0" title="0">{
                log.Printf("GPS attitude: Regression error calculating turn rate")
                return false
        }</span> else<span class="cov0" title="0"> {
                headingAvg = slope*float64(myGPSPerfStats[index].nmeaTime) + intercept
                dh = slope // units are deg per sec; no conversion needed here
                //log.Printf("Calculated heading and turn rate: %.3f degrees, %.3f deg/sec\n",headingAvg,dh)
        }</span>

        <span class="cov0" title="0">myGPSPerfStats[index].gpsTurnRate = dh
        mySituation.GPSTurnRate = dh

        // pitch angle -- or to be more pedantic, glide / climb angle, since we're just looking a rise-over-run.
        // roll angle, based on turn rate and ground speed. Only valid for coordinated flight. Differences between airspeed and groundspeed will trip this up.
        if v_x &gt; 20 </span><span class="cov0" title="0">{ // reduce nuisance 'bounce' at low speeds. 20 ft/sec = 11.9 knots.
                myGPSPerfStats[index].gpsPitch = math.Atan2(v_z, v_x) * 180.0 / math.Pi

                /*
                        Governing equations for roll calculations

                        Physics tells us that
                                a_z = g     (in steady-state flight -- climbing, descending, or level -- this is gravity. 9.81 m/s^2 or 32.2 ft/s^2)
                                a_c = v^2/r (centripetal acceleration)

                        We don't know r. However, we do know the tangential velocity (v) and angular velocity (omega). Express omega in radians per unit time, and

                                v = omega*r

                        By substituting and rearranging terms:

                                a_c = v^2 / (v / omega)
                                a_c = v*omega

                        Free body diagram time!

                                   /|
                          a_r / |  a_z
                                 /__|
                           X   a_c
                                \_________________ [For the purpose of this comment, " X" is an airplane in a 20 degree bank. Use your imagination, mkay?)

                        Resultant acceleration a_r is what the wings feel; a_r/a_z = load factor. Anyway, trig out the bank angle:

                                bank angle = atan(a_c/a_z)
                                                   = atan(v*omega/g)

                                wing loading = sqrt(a_c^2 + a_z^2) / g

                */

                g := 32.174                                               // ft/(s^2)
                omega = common.Radians(myGPSPerfStats[index].gpsTurnRate) // need radians/sec
                a_c = v_x * omega
                myGPSPerfStats[index].gpsRoll = math.Atan2(a_c, g) * 180 / math.Pi // output is degrees
                myGPSPerfStats[index].gpsLoadFactor = math.Sqrt(a_c*a_c+g*g) / g
        }</span> else<span class="cov0" title="0"> {
                myGPSPerfStats[index].gpsPitch = 0
                myGPSPerfStats[index].gpsRoll = 0
                myGPSPerfStats[index].gpsLoadFactor = 1
        }</span>

        <span class="cov0" title="0">if globalSettings.DEBUG </span><span class="cov0" title="0">{
                // Output format:GPSAtttiude,seconds,nmeaTime,msg_type,GS,Course,Alt,VV,filtered_GS,filtered_course,turn rate,filtered_vv,pitch, roll,load_factor
                buf := fmt.Sprintf("GPSAttitude,%.1f,%.2f,%s,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f,%0.3f\n", float64(stratuxClock.Milliseconds)/1000, myGPSPerfStats[index].nmeaTime, myGPSPerfStats[index].msgType, myGPSPerfStats[index].gsf, myGPSPerfStats[index].coursef, myGPSPerfStats[index].alt, myGPSPerfStats[index].vv, v_x/1.687810, headingAvg, myGPSPerfStats[index].gpsTurnRate, v_z, myGPSPerfStats[index].gpsPitch, myGPSPerfStats[index].gpsRoll, myGPSPerfStats[index].gpsLoadFactor)
                log.Printf("%s", buf) // FIXME. Send to sqlite log or other file?
        }</span>

        <span class="cov0" title="0">logGPSAttitude(myGPSPerfStats[index])
        //replayLog(buf, MSGCLASS_AHRS)
        return true</span>
}

func calculateNACp(accuracy float32) uint8 <span class="cov5" title="32">{
        ret := uint8(0)

        if accuracy &lt; 3 </span><span class="cov2" title="3">{
                ret = 11
        }</span> else<span class="cov5" title="29"> if accuracy &lt; 10 </span><span class="cov3" title="5">{
                ret = 10
        }</span> else<span class="cov5" title="24"> if accuracy &lt; 30 </span><span class="cov3" title="5">{
                ret = 9
        }</span> else<span class="cov5" title="19"> if accuracy &lt; 92.6 </span><span class="cov3" title="5">{
                ret = 8
        }</span> else<span class="cov4" title="14"> if accuracy &lt; 185.2 </span><span class="cov3" title="5">{
                ret = 7
        }</span> else<span class="cov4" title="9"> if accuracy &lt; 555.6 </span><span class="cov3" title="5">{
                ret = 6
        }</span>

        <span class="cov5" title="32">return ret</span>
}

/*
registerSituationUpdate().

        Called whenever there is a change in mySituation.
*/
func registerSituationUpdate() <span class="cov0" title="0">{
        logSituation()
        situationUpdate.SendJSON(mySituation)
}</span>

func calculateNavRate() float64 <span class="cov0" title="0">{
        length := len(myGPSPerfStats)
        tempSpeedTime := make([]float64, 0)

        for i := 1; i &lt; length; i++ </span><span class="cov0" title="0">{
                dt := myGPSPerfStats[i].nmeaTime - myGPSPerfStats[i-1].nmeaTime
                if dt &gt; 0.05 </span><span class="cov0" title="0">{ // avoid double counting messages with same / similar timestamps
                        tempSpeedTime = append(tempSpeedTime, float64(dt))
                }</span>
        }

        <span class="cov0" title="0">var halfwidth float64
        dt_avg, valid := common.Mean(tempSpeedTime)
        if valid &amp;&amp; dt_avg &gt; 0 </span><span class="cov0" title="0">{
                logDbg("GPS attitude: Average delta time is %.2f s (%.1f Hz)\n", dt_avg, 1/dt_avg)
                halfwidth = 9 * dt_avg
                mySituation.GPSPositionSampleRate = 1 / dt_avg
        }</span> else<span class="cov0" title="0"> {
                // logDbg("GPS attitude: Couldn't determine sample rate\n")
                halfwidth = 3.5
                mySituation.GPSPositionSampleRate = 0
        }</span>

        <span class="cov0" title="0">if halfwidth &gt; 3.5 </span><span class="cov0" title="0">{
                halfwidth = 3.5 // limit calculation window to 3.5 seconds of data for 1 Hz or slower samples
        }</span> else<span class="cov0" title="0"> if halfwidth &lt; 1.5 </span><span class="cov0" title="0">{
                halfwidth = 1.5 // use minimum of 1.5 seconds for sample rates faster than 5 Hz
        }</span>

        <span class="cov0" title="0">return halfwidth</span>
}

/*
processNMEALine parses NMEA-0183 formatted strings against several message types.

Standard messages supported: RMC GGA VTG GSA

return is false if errors occur during parse, or if GPS position is invalid
return is true if parse occurs correctly and position is valid.
*/
func processNMEALine(l string) (sentenceUsed bool) <span class="cov0" title="0">{
        return processNMEALineLow(l, false)
}</span>

func processNMEALineLow(l string, fakeGpsTimeToCurr bool) (sentenceUsed bool) <span class="cov0" title="0">{
        mySituation.muGPS.Lock()
        TraceLog.Record(CONTEXT_NMEA, []byte(l))

        defer func() </span><span class="cov0" title="0">{
                if sentenceUsed || globalSettings.DEBUG </span><span class="cov0" title="0">{
                        registerSituationUpdate()
                }</span>
                <span class="cov0" title="0">mySituation.muGPS.Unlock()</span>
        }()
        // Simulate in-flight moving GPS, useful in combination with demo traffic in gen_gdl90.go
        /*defer func() {
                tmpSituation := mySituation
                if strings.Contains(l, "GGA,") || strings.Contains(l, "RMC,") {
                        tmpSituation.GPSLatitude += float32(stratuxClock.Milliseconds) / 1000.0 / 60.0 / 30.0
                }

                tmpSituation.GPSTrueCourse = 0
                tmpSituation.GPSGroundSpeed = 110
                tmpSituation.GPSAltitudeMSL = 5000
                tmpSituation.GPSHeightAboveEllipsoid = 5000
                tmpSituation.BaroPressureAltitude = 4800
                mySituation = tmpSituation
        }()*/

        // Local variables for GPS attitude estimation
        <span class="cov0" title="0">thisGpsPerf := gpsPerf                              // write to myGPSPerfStats at end of function IFF
        thisGpsPerf.coursef = -999.9                        // default value of -999.9 indicates invalid heading to regression calculation
        thisGpsPerf.stratuxTime = stratuxClock.Milliseconds // used for gross indexing
        updateGPSPerf := false                              // change to true when position or vector info is read

        l_valid, validNMEAcs := validateNMEAChecksum(l)
        if !validNMEAcs </span><span class="cov0" title="0">{
                if len(l_valid) &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("GPS error. Invalid NMEA string: %s\n", l_valid) // remove log message once validation complete
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov0" title="0">ognPublishNmea(l)
        x := strings.Split(l_valid, ",")

        mySituation.GPSLastValidNMEAMessageTime = stratuxClock.Time
        mySituation.GPSLastValidNMEAMessage = l

        if (x[0] == "GNVTG") || (x[0] == "GPVTG") </span><span class="cov0" title="0">{ // Ground track information.
                tmpSituation := mySituation // If we decide to not use the data in this message, then don't make incomplete changes in mySituation.
                if len(x) &lt; 9 </span><span class="cov0" title="0">{             // Reduce from 10 to 9 to allow parsing by devices pre-NMEA v2.3
                        return false
                }</span>

                <span class="cov0" title="0">groundspeed, err := strconv.ParseFloat(x[5], 32) // Knots.
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">tmpSituation.GPSGroundSpeed = groundspeed

                trueCourse := float32(0)
                tc, err := strconv.ParseFloat(x[1], 32)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if groundspeed &gt; 3 </span><span class="cov0" title="0">{ //TODO: use average groundspeed over last n seconds to avoid random "jumps"
                        trueCourse = float32(tc)
                        setTrueCourse(uint16(groundspeed), tc)
                        tmpSituation.GPSTrueCourse = trueCourse
                }</span> else <span class="cov0" title="0">{
                        // Negligible movement. Don't update course, but do use the slow speed.
                        //TODO: use average course over last n seconds?
                }</span>
                <span class="cov0" title="0">tmpSituation.GPSLastGroundTrackTime = stratuxClock.Time

                // We've made it this far, so that means we've processed "everything" and can now make the change to mySituation.
                mySituation = tmpSituation
                return true</span>

        } else<span class="cov0" title="0"> if (x[0] == "GNGGA") || (x[0] == "GPGGA") </span><span class="cov0" title="0">{ // Position fix.
                tmpSituation := mySituation // If we decide to not use the data in this message, then don't make incomplete changes in mySituation.

                if len(x) &lt; 15 </span><span class="cov0" title="0">{
                        return false
                }</span>

                // use RMC / GGA message detection to sense "NMEA" type.
                <span class="cov0" title="0">if (globalStatus.GPS_detected_type &amp; 0xf0) == 0 </span><span class="cov0" title="0">{
                        globalStatus.GPS_detected_type |= GPS_PROTOCOL_NMEA
                }</span>

                // GPSFixQuality indicator.
                <span class="cov0" title="0">q, err1 := strconv.Atoi(x[6])
                if err1 != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">tmpSituation.GPSFixQuality = uint8(q) // 1 = 3D GPS; 2 = DGPS (SBAS /WAAS)

                // Timestamp.
                if len(x[1]) &lt; 7 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">hr, err1 := strconv.Atoi(x[1][0:2])
                min, err2 := strconv.Atoi(x[1][2:4])
                sec, err3 := strconv.ParseFloat(x[1][4:], 32)
                if err1 != nil || err2 != nil || err3 != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">tmpSituation.GPSLastFixSinceMidnightUTC = float32(3600*hr+60*min) + float32(sec)
                thisGpsPerf.nmeaTime = tmpSituation.GPSLastFixSinceMidnightUTC

                // Latitude.
                if len(x[2]) &lt; 4 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">hr, err1 = strconv.Atoi(x[2][0:2])
                minf, err2 := strconv.ParseFloat(x[2][2:], 32)
                if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">tmpSituation.GPSLatitude = float32(hr) + float32(minf/60.0)
                if x[3] == "S" </span><span class="cov0" title="0">{ // South = negative.
                        tmpSituation.GPSLatitude = -tmpSituation.GPSLatitude
                }</span>

                // Longitude.
                <span class="cov0" title="0">if len(x[4]) &lt; 5 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">hr, err1 = strconv.Atoi(x[4][0:3])
                minf, err2 = strconv.ParseFloat(x[4][3:], 32)
                if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">tmpSituation.GPSLongitude = float32(hr) + float32(minf/60.0)
                if x[5] == "W" </span><span class="cov0" title="0">{ // West = negative.
                        tmpSituation.GPSLongitude = -tmpSituation.GPSLongitude
                }</span>

                // Altitude.
                <span class="cov0" title="0">alt, err1 := strconv.ParseFloat(x[9], 32)
                if err1 != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">tmpSituation.GPSAltitudeMSL = float32(alt * 3.28084) // Convert to feet.
                thisGpsPerf.alt = float32(tmpSituation.GPSAltitudeMSL)

                // Geoid separation (Sep = HAE - MSL)

                geoidSep, err1 := strconv.ParseFloat(x[11], 32)
                if err1 != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">tmpSituation.GPSGeoidSep = float32(geoidSep * 3.28084) // Convert to feet.
                tmpSituation.GPSHeightAboveEllipsoid = tmpSituation.GPSGeoidSep + tmpSituation.GPSAltitudeMSL

                // Timestamp.
                tmpSituation.GPSLastFixLocalTime = stratuxClock.Time

                updateGPSPerf = true
                thisGpsPerf.msgType = x[0]

                // We've made it this far, so that means we've processed "everything" and can now make the change to mySituation.
                mySituation = tmpSituation

                if updateGPSPerf </span><span class="cov0" title="0">{
                        mySituation.muGPSPerformance.Lock()
                        myGPSPerfStats = append(myGPSPerfStats, thisGpsPerf)
                        lenGPSPerfStats := len(myGPSPerfStats)
                        //        log.Printf("GPSPerf array has %n elements. Contents are: %v\n",lenGPSPerfStats,myGPSPerfStats)
                        if lenGPSPerfStats &gt; 299 </span><span class="cov0" title="0">{ //30 seconds @ 10 Hz for UBX, 30 seconds @ 5 Hz for MTK or SIRF with 2x messages per 200 ms)
                                myGPSPerfStats = myGPSPerfStats[(lenGPSPerfStats - 299):] // remove the first n entries if more than 300 in the slice
                        }</span>
                        <span class="cov0" title="0">mySituation.muGPSPerformance.Unlock()</span>
                }

                <span class="cov0" title="0">return true</span>

        } else<span class="cov0" title="0"> if (x[0] == "GNRMC") || (x[0] == "GPRMC") </span><span class="cov0" title="0">{ // Recommended Minimum data.
                tmpSituation := mySituation // If we decide to not use the data in this message, then don't make incomplete changes in mySituation.

                //$GPRMC,123519,A,4807.038,N,01131.000,E,022.4,084.4,230394,003.1,W*6A
                /*                                                check RY835 man for NMEA version, if &gt;2.2, add mode field
                                Where:
                     RMC          Recommended Minimum sentence C
                     123519       Fix taken at 12:35:19 UTC
                     A            Status A=active or V=Void.
                     4807.038,N   Latitude 48 deg 07.038' N
                     01131.000,E  Longitude 11 deg 31.000' E
                     022.4        Speed over the ground in knots
                     084.4        Track angle in degrees True
                     230394       Date - 23rd of March 1994
                     003.1,W      Magnetic Variation
                     D                                mode field (nmea 2.3 and higher)
                     *6A          The checksum data, always begins with *
                */
                if len(x) &lt; 11 </span><span class="cov0" title="0">{
                        return false
                }</span>

                // use RMC / GGA message detection to sense "NMEA" type.
                <span class="cov0" title="0">if (globalStatus.GPS_detected_type &amp; 0xf0) == 0 </span><span class="cov0" title="0">{
                        globalStatus.GPS_detected_type |= GPS_PROTOCOL_NMEA
                }</span>

                <span class="cov0" title="0">if x[2] != "A" </span><span class="cov0" title="0">{ // invalid fix
                        tmpSituation.GPSFixQuality = 0 // Just a note.
                        return false
                }</span>

                // Timestamp.
                <span class="cov0" title="0">if len(x[1]) &lt; 7 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">hr, err1 := strconv.Atoi(x[1][0:2])
                min, err2 := strconv.Atoi(x[1][2:4])
                sec, err3 := strconv.ParseFloat(x[1][4:], 32)
                if err1 != nil || err2 != nil || err3 != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">tmpSituation.GPSLastFixSinceMidnightUTC = float32(3600*hr+60*min) + float32(sec)
                thisGpsPerf.nmeaTime = tmpSituation.GPSLastFixSinceMidnightUTC

                if len(x[9]) == 6 </span><span class="cov0" title="0">{
                        // Date of Fix, i.e 191115 =  19 November 2015 UTC  field 9
                        gpsTimeStr := fmt.Sprintf("%s %02d:%02d:%06.3f", x[9], hr, min, sec)
                        gpsTime, err := time.Parse("020106 15:04:05.000", gpsTimeStr)
                        gpsTime = gpsTime.Add(gpsTimeOffsetPpsMs) // rough estimate for PPS offset

                        if fakeGpsTimeToCurr </span><span class="cov0" title="0">{
                                // Used during trace replay: pretend gps time equals current time, so stratux accepts the NMEA as current
                                gpsTime = time.Now().UTC()
                        }</span>

                        <span class="cov0" title="0">if err == nil &amp;&amp; gpsTime.After(time.Date(2016, time.January, 0, 0, 0, 0, 0, time.UTC)) </span><span class="cov0" title="0">{ // Ignore dates before 2016-JAN-01.
                                tmpSituation.GPSLastGPSTimeStratuxTime = stratuxClock.Time
                                tmpSituation.GPSTime = gpsTime
                                stratuxClock.SetRealTimeReference(gpsTime)
                                if time.Since(gpsTime) &gt; 300*time.Millisecond || time.Since(gpsTime) &lt; -300*time.Millisecond </span><span class="cov0" title="0">{
                                        setStr := gpsTime.Format("20060102 15:04:05.000") + " UTC"
                                        log.Printf("setting system time from %s to: '%s'\n", time.Now().Format("20060102 15:04:05.000"), setStr)
                                        var err error
                                        if common.IsRunningAsRoot() </span><span class="cov0" title="0">{
                                                err = exec.Command("date", "-s", setStr).Run()
                                        }</span>
                                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Set Date failure: %s error\n", err)
                                        }</span> else<span class="cov0" title="0"> {
                                                log.Printf("Time set from GPS. Current time is %v\n", time.Now())
                                        }</span>
                                }
                                <span class="cov0" title="0">TraceLog.OnTimestamp(gpsTime)</span>
                        }
                }

                // Latitude.
                <span class="cov0" title="0">if len(x[3]) &lt; 4 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">hr, err1 = strconv.Atoi(x[3][0:2])
                minf, err2 := strconv.ParseFloat(x[3][2:], 32)
                if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">tmpSituation.GPSLatitude = float32(hr) + float32(minf/60.0)
                if x[4] == "S" </span><span class="cov0" title="0">{ // South = negative.
                        tmpSituation.GPSLatitude = -tmpSituation.GPSLatitude
                }</span>
                // Longitude.
                <span class="cov0" title="0">if len(x[5]) &lt; 5 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">hr, err1 = strconv.Atoi(x[5][0:3])
                minf, err2 = strconv.ParseFloat(x[5][3:], 32)
                if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">tmpSituation.GPSLongitude = float32(hr) + float32(minf/60.0)
                if x[6] == "W" </span><span class="cov0" title="0">{ // West = negative.
                        tmpSituation.GPSLongitude = -tmpSituation.GPSLongitude
                }</span>

                <span class="cov0" title="0">tmpSituation.GPSLastFixLocalTime = stratuxClock.Time

                // ground speed in kts (field 7)
                groundspeed, err := strconv.ParseFloat(x[7], 32)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">tmpSituation.GPSGroundSpeed = groundspeed
                thisGpsPerf.gsf = float32(groundspeed)

                // ground track "True" (field 8)
                trueCourse := float32(0)
                tc, err := strconv.ParseFloat(x[8], 32)
                if err != nil &amp;&amp; groundspeed &gt; 3 </span><span class="cov0" title="0">{ // some receivers return null COG at low speeds. Need to ignore this condition.
                        return false
                }</span>
                <span class="cov0" title="0">if groundspeed &gt; 3 </span><span class="cov0" title="0">{ //TODO: use average groundspeed over last n seconds to avoid random "jumps"
                        trueCourse = float32(tc)
                        setTrueCourse(uint16(groundspeed), tc)
                        tmpSituation.GPSTrueCourse = trueCourse
                        thisGpsPerf.coursef = float32(tc)
                }</span> else<span class="cov0" title="0"> {
                        thisGpsPerf.coursef = -999.9
                        // Negligible movement. Don't update course, but do use the slow speed.
                        //TODO: use average course over last n seconds?
                }</span>
                <span class="cov0" title="0">updateGPSPerf = true
                thisGpsPerf.msgType = x[0]
                tmpSituation.GPSLastGroundTrackTime = stratuxClock.Time

                // We've made it this far, so that means we've processed "everything" and can now make the change to mySituation.
                mySituation = tmpSituation

                if updateGPSPerf </span><span class="cov0" title="0">{
                        mySituation.muGPSPerformance.Lock()
                        myGPSPerfStats = append(myGPSPerfStats, thisGpsPerf)
                        lenGPSPerfStats := len(myGPSPerfStats)
                        //        log.Printf("GPSPerf array has %n elements. Contents are: %v\n",lenGPSPerfStats,myGPSPerfStats)
                        if lenGPSPerfStats &gt; 299 </span><span class="cov0" title="0">{ //30 seconds @ 10 Hz for UBX, 30 seconds @ 5 Hz for MTK or SIRF with 2x messages per 200 ms)
                                myGPSPerfStats = myGPSPerfStats[(lenGPSPerfStats - 299):] // remove the first n entries if more than 300 in the slice
                        }</span>
                        <span class="cov0" title="0">mySituation.muGPSPerformance.Unlock()</span>
                }

                <span class="cov0" title="0">setDataLogTimeWithGPS(mySituation)
                return true</span>

        } else<span class="cov0" title="0"> if (x[0] == "GNGSA") || (x[0] == "GPGSA") </span><span class="cov0" title="0">{ // Satellite data.
                tmpSituation := mySituation // If we decide to not use the data in this message, then don't make incomplete changes in mySituation.

                if len(x) &lt; 18 </span><span class="cov0" title="0">{
                        return false
                }</span>

                // field 1: operation mode
                // M: manual forced to 2D or 3D mode
                // A: automatic switching between 2D and 3D modes

                /*
                        if (x[1] != "A") &amp;&amp; (x[1] != "M") { // invalid fix ... but x[2] is a better indicator of fix quality. Deprecating this.
                                tmpSituation.GPSFixQuality = 0 // Just a note.
                                return false
                        }
                */

                // field 2: solution type
                // 1 = no solution; 2 = 2D fix, 3 = 3D fix. WAAS status is parsed from GGA message, so no need to get here
                <span class="cov0" title="0">if (x[2] == "") || (x[2] == "1") </span><span class="cov0" title="0">{ // missing or no solution
                        tmpSituation.GPSFixQuality = 0 // Just a note.
                        return false
                }</span>

                // fields 3-14: satellites in solution
                <span class="cov0" title="0">var svStr string
                var svType uint8

                // START OF PROTECTED BLOCK
                mySituation.muSatellite.Lock()

                for _, svtxt := range x[3:15] </span><span class="cov0" title="0">{
                        sv, err := strconv.Atoi(svtxt)
                        if err == nil </span><span class="cov0" title="0">{
                                if sv &lt;= 32 </span><span class="cov0" title="0">{
                                        svType = SAT_TYPE_GPS
                                        svStr = fmt.Sprintf("G%d", sv) // GPS 1-32
                                }</span> else<span class="cov0" title="0"> if sv &lt;= 64 </span><span class="cov0" title="0">{
                                        svType = SAT_TYPE_SBAS
                                        svStr = fmt.Sprintf("S%d", sv+87) // SBAS 33-64, 33 = SBAS PRN 120
                                }</span> else<span class="cov0" title="0"> if sv &lt;= 96 </span><span class="cov0" title="0">{
                                        svType = SAT_TYPE_GLONASS
                                        svStr = fmt.Sprintf("R%d", sv-64) // GLONASS 65-96
                                }</span> else<span class="cov0" title="0"> if sv &lt;= 158 </span><span class="cov0" title="0">{
                                        svType = SAT_TYPE_SBAS
                                        svStr = fmt.Sprintf("S%d", sv) // SBAS 152-158
                                }</span> else<span class="cov0" title="0"> if sv &lt;= 202 </span><span class="cov0" title="0">{
                                        svType = SAT_TYPE_QZSS
                                        svStr = fmt.Sprintf("Q%d", sv-192) // QZSS 193-202
                                }</span> else<span class="cov0" title="0"> if sv &lt;= 336 </span><span class="cov0" title="0">{
                                        svType = SAT_TYPE_GALILEO
                                        svStr = fmt.Sprintf("E%d", sv-300) // GALILEO 301-336
                                }</span> else<span class="cov0" title="0"> if sv &lt;= 463 </span><span class="cov0" title="0">{
                                        svType = SAT_TYPE_BEIDOU
                                        svStr = fmt.Sprintf("B%d", sv-400) // BEIDOU 401-463
                                }</span> else<span class="cov0" title="0"> {
                                        svType = SAT_TYPE_UNKNOWN
                                        svStr = fmt.Sprintf("U%d", sv)
                                }</span>

                                <span class="cov0" title="0">var thisSatellite SatelliteInfo

                                // Retrieve previous information on this satellite code.
                                if val, ok := Satellites[svStr]; ok </span><span class="cov0" title="0">{ // if we've already seen this satellite identifier, copy it in to do updates
                                        thisSatellite = val
                                        //log.Printf("Satellite %s already seen. Retrieving from 'Satellites'.\n", svStr)
                                }</span> else<span class="cov0" title="0"> { // this satellite isn't in the Satellites data structure, so create it
                                        thisSatellite.SatelliteID = svStr
                                        thisSatellite.SatelliteNMEA = uint8(sv)
                                        thisSatellite.Type = uint8(svType)
                                        //log.Printf("Creating new satellite %s from GSA message\n", svStr) // DEBUG
                                }</span>
                                <span class="cov0" title="0">thisSatellite.InSolution = true
                                thisSatellite.TimeLastSolution = stratuxClock.Time
                                thisSatellite.TimeLastSeen = stratuxClock.Time    // implied, since this satellite is used in the position solution
                                thisSatellite.TimeLastTracked = stratuxClock.Time // implied, since this satellite is used in the position solution

                                Satellites[thisSatellite.SatelliteID] = thisSatellite</span> // Update constellation with this satellite
                        }
                }
                <span class="cov0" title="0">updateConstellation()
                tmpSituation.GPSSatellites = mySituation.GPSSatellites
                tmpSituation.GPSSatellitesTracked = mySituation.GPSSatellitesTracked
                tmpSituation.GPSSatellitesSeen = mySituation.GPSSatellitesSeen
                mySituation.muSatellite.Unlock()
                // END OF PROTECTED BLOCK

                // Prefer accuracy from G?GST. Only if not received, estimate from hdop/vdop
                if stratuxClock.Since(tmpSituation.GPSLastAccuracyTime) &gt; 10*time.Second </span><span class="cov0" title="0">{
                        // field 16: HDOP
                        // Accuracy estimate
                        hdop, err1 := strconv.ParseFloat(x[16], 32)
                        if err1 != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">if tmpSituation.GPSFixQuality == 2 </span><span class="cov0" title="0">{ // Rough 95% confidence estimate for SBAS solution
                                if globalStatus.GPS_detected_type == GPS_TYPE_UBX9 || globalStatus.GPS_detected_type == GPS_TYPE_UBX10 </span><span class="cov0" title="0">{
                                        tmpSituation.GPSHorizontalAccuracy = float32(hdop * 3.0) // ublox 9
                                }</span> else<span class="cov0" title="0"> {
                                        tmpSituation.GPSHorizontalAccuracy = float32(hdop * 4.0) // ublox 6/7/8
                                }</span>
                        } else<span class="cov0" title="0"> { // Rough 95% confidence estimate non-SBAS solution
                                if globalStatus.GPS_detected_type == GPS_TYPE_UBX9 || globalStatus.GPS_detected_type == GPS_TYPE_UBX10 </span><span class="cov0" title="0">{
                                        tmpSituation.GPSHorizontalAccuracy = float32(hdop * 4.0) // ublox 9
                                }</span> else<span class="cov0" title="0"> {
                                        tmpSituation.GPSHorizontalAccuracy = float32(hdop * 5.0) // ublox 6/7/8
                                }</span>
                        }

                        // NACp estimate.
                        <span class="cov0" title="0">tmpSituation.GPSNACp = calculateNACp(tmpSituation.GPSHorizontalAccuracy)

                        // field 17: VDOP
                        // accuracy estimate
                        vdop, err1 := strconv.ParseFloat(x[17], 32)
                        if err1 != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">tmpSituation.GPSVerticalAccuracy = float32(vdop * 5)</span> // rough estimate for 95% confidence

                        //fmt.Println("hdop hacc: ", tmpSituation.GPSHorizontalAccuracy, ", vacc: ", tmpSituation.GPSVerticalAccuracy)
                }

                // We've made it this far, so that means we've processed "everything" and can now make the change to mySituation.
                <span class="cov0" title="0">mySituation = tmpSituation
                return true</span>

        }

        <span class="cov0" title="0">if x[0] == "GNGST" || x[0] == "GPGST" </span><span class="cov0" title="0">{
                if len(x) &lt; 9 </span><span class="cov0" title="0">{
                        return false
                }</span>

                // $GNGST,205246.00,1.19,0.02,0.01,-2.4501,0.02,0.01,0.03*5B
                // Care: GNGST uses 1-sigma (68%) deviation. We use 2-sigma (~95%)
                <span class="cov0" title="0">stdDevLat, err := strconv.ParseFloat(x[6], 32)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">stdDevLon, err := strconv.ParseFloat(x[7], 32)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">stdDevAlt, err := strconv.ParseFloat(x[8], 32)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">hacc := 2 * math.Sqrt(stdDevLat*stdDevLat+stdDevLon*stdDevLon)
                vacc := 2 * stdDevAlt

                //fmt.Println("gst hacc: ", hacc, ", vacc: ", vacc)

                tmpSituation := mySituation
                tmpSituation.GPSLastAccuracyTime = stratuxClock.Time
                tmpSituation.GPSHorizontalAccuracy = float32(hacc)
                tmpSituation.GPSVerticalAccuracy = float32(vacc)
                tmpSituation.GPSNACp = calculateNACp(tmpSituation.GPSHorizontalAccuracy)
                mySituation = tmpSituation
                return true</span>

        }

        <span class="cov0" title="0">if (x[0] == "GPGSV") || (x[0] == "GLGSV") || (x[0] == "GAGSV") || (x[0] == "GBGSV") </span><span class="cov0" title="0">{ // GPS + SBAS or GLONASS or Galileo or Beidou satellites in view message.
                if len(x) &lt; 4 </span><span class="cov0" title="0">{
                        return false
                }</span>

                // field 1 = number of GSV messages of this type
                <span class="cov0" title="0">msgNum, err := strconv.Atoi(x[2])
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                // field 2 = index of this GSV message

                <span class="cov0" title="0">msgIndex, err := strconv.Atoi(x[2])
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                // field 3 = number of GPS satellites tracked
                /* Is this redundant if parsing from full constellation?
                satTracked, err := strconv.Atoi(x[3])
                if err != nil {
                        return false
                }
                */

                //mySituation.GPSSatellitesTracked = uint16(satTracked) // Replaced with parsing of 'Satellites' data structure

                // field 4-7 = repeating block with satellite id, elevation, azimuth, and signal strengh (Cno)

                <span class="cov0" title="0">lenGSV := len(x)
                satsThisMsg := (lenGSV - 4) / 4

                logDbg("%s message [%d of %d] is %v fields long and describes %v satellites\n", x[0], msgIndex, msgNum, lenGSV, satsThisMsg)

                var sv, elev, az, cno int
                var svType uint8
                var svStr string

                for i := 0; i &lt; satsThisMsg; i++ </span><span class="cov0" title="0">{

                        sv, err = strconv.Atoi(x[4+4*i]) // sv number
                        if err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov0" title="0">if sv &lt;= 32 </span><span class="cov0" title="0">{
                                svType = SAT_TYPE_GPS
                                svStr = fmt.Sprintf("G%d", sv) // GPS 1-32
                        }</span> else<span class="cov0" title="0"> if sv &lt;= 64 </span><span class="cov0" title="0">{
                                svType = SAT_TYPE_SBAS
                                svStr = fmt.Sprintf("S%d", sv+87) // SBAS 33-64, 33 = SBAS PRN 120
                        }</span> else<span class="cov0" title="0"> if sv &lt;= 96 </span><span class="cov0" title="0">{
                                svType = SAT_TYPE_GLONASS
                                svStr = fmt.Sprintf("R%d", sv-64) // GLONASS 65-96
                        }</span> else<span class="cov0" title="0"> if sv &lt;= 158 </span><span class="cov0" title="0">{
                                svType = SAT_TYPE_SBAS
                                svStr = fmt.Sprintf("S%d", sv) // SBAS 152-158
                        }</span> else<span class="cov0" title="0"> if sv &lt;= 202 </span><span class="cov0" title="0">{
                                svType = SAT_TYPE_QZSS
                                svStr = fmt.Sprintf("Q%d", sv-192) // QZSS 193-202
                        }</span> else<span class="cov0" title="0"> if sv &lt;= 336 </span><span class="cov0" title="0">{
                                svType = SAT_TYPE_GALILEO
                                svStr = fmt.Sprintf("E%d", sv-300) // GALILEO 301-336
                        }</span> else<span class="cov0" title="0"> if sv &lt;= 463 </span><span class="cov0" title="0">{
                                svType = SAT_TYPE_BEIDOU
                                svStr = fmt.Sprintf("B%d", sv-400) // BEIDOU 401-463
                        }</span> else<span class="cov0" title="0"> {
                                svType = SAT_TYPE_UNKNOWN
                                svStr = fmt.Sprintf("U%d", sv)
                        }</span>

                        <span class="cov0" title="0">var thisSatellite SatelliteInfo

                        // START OF PROTECTED BLOCK
                        mySituation.muSatellite.Lock()

                        // Retrieve previous information on this satellite code.
                        if val, ok := Satellites[svStr]; ok </span><span class="cov0" title="0">{ // if we've already seen this satellite identifier, copy it in to do updates
                                thisSatellite = val
                                //log.Printf("Satellite %s already seen. Retrieving from 'Satellites'.\n", svStr) // DEBUG
                        }</span> else<span class="cov0" title="0"> { // this satellite isn't in the Satellites data structure, so create it new
                                thisSatellite.SatelliteID = svStr
                                thisSatellite.SatelliteNMEA = uint8(sv)
                                thisSatellite.Type = uint8(svType)
                                //log.Printf("Creating new satellite %s\n", svStr) // DEBUG
                        }</span>
                        <span class="cov0" title="0">thisSatellite.TimeLastTracked = stratuxClock.Time

                        elev, err = strconv.Atoi(x[5+4*i]) // elevation
                        if err != nil </span><span class="cov0" title="0">{                    // some firmwares leave this blank if there's no position fix. Represent as -999.
                                elev = -999
                        }</span>
                        <span class="cov0" title="0">thisSatellite.Elevation = int16(elev)

                        az, err = strconv.Atoi(x[6+4*i]) // azimuth
                        if err != nil </span><span class="cov0" title="0">{                  // UBX allows tracking up to 5(?) degrees below horizon. Some firmwares leave this blank if no position fix. Represent invalid as -999.
                                az = -999
                        }</span>
                        <span class="cov0" title="0">thisSatellite.Azimuth = int16(az)

                        cno, err = strconv.Atoi(x[7+4*i]) // signal
                        if err != nil </span><span class="cov0" title="0">{                   // will be blank if satellite isn't being received. Represent as -99.
                                cno = -99
                                thisSatellite.InSolution = false // resets the "InSolution" status if the satellite disappears out of solution due to no signal. FIXME
                                //log.Printf("Satellite %s is no longer in solution due to cno parse error - GSV\n", svStr) // DEBUG
                        }</span> else<span class="cov0" title="0"> if cno &gt; 0 </span><span class="cov0" title="0">{
                                thisSatellite.TimeLastSeen = stratuxClock.Time // Is this needed?
                        }</span>
                        <span class="cov0" title="0">if cno &gt; 127 </span><span class="cov0" title="0">{ // make sure strong signals don't overflow. Normal range is 0-99 so it shouldn't, but take no chances.
                                cno = 127
                        }</span>
                        <span class="cov0" title="0">thisSatellite.Signal = int8(cno)

                        // hack workaround for GSA 12-sv limitation... if this is a SBAS satellite, we have a SBAS solution, and signal is greater than some arbitrary threshold, set InSolution
                        // drawback is this will show all tracked SBAS satellites as being in solution.
                        if thisSatellite.Type == SAT_TYPE_SBAS </span><span class="cov0" title="0">{
                                if mySituation.GPSFixQuality == 2 </span><span class="cov0" title="0">{
                                        if thisSatellite.Signal &gt; 16 </span><span class="cov0" title="0">{
                                                thisSatellite.InSolution = true
                                                thisSatellite.TimeLastSolution = stratuxClock.Time
                                        }</span>
                                } else<span class="cov0" title="0"> { // quality == 0 or 1
                                        thisSatellite.InSolution = false
                                        //log.Printf("WAAS satellite %s is marked as out of solution GSV\n", svStr) // DEBUG
                                }</span>
                        }

                        <span class="cov0" title="0">if globalSettings.DEBUG </span><span class="cov0" title="0">{
                                inSolnStr := " "
                                if thisSatellite.InSolution </span><span class="cov0" title="0">{
                                        inSolnStr = "+"
                                }</span>
                                <span class="cov0" title="0">log.Printf("GSV: Satellite %s%s at index %d. Type = %d, NMEA-ID = %d, Elev = %d, Azimuth = %d, Cno = %d\n", inSolnStr, svStr, i, svType, sv, elev, az, cno)</span> // remove later?
                        }

                        <span class="cov0" title="0">Satellites[thisSatellite.SatelliteID] = thisSatellite // Update constellation with this satellite
                        updateConstellation()
                        mySituation.muSatellite.Unlock()</span>
                        // END OF PROTECTED BLOCK
                }

                <span class="cov0" title="0">return true</span>
        }

        // OGN Tracker pressure data:
        // $POGNB,22.0,+29.1,100972.3,3.8,+29.4,+87.2,-0.04,+32.6,*6B
        <span class="cov0" title="0">if x[0] == "POGNB" </span><span class="cov0" title="0">{
                if len(x) &lt; 5 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">var vspeed float64

                pressureAlt, err := strconv.ParseFloat(x[5], 32)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">vspeed, err = strconv.ParseFloat(x[7], 32)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">if !isTempPressValid() || mySituation.BaroSourceType != BARO_TYPE_BMP280 </span><span class="cov0" title="0">{
                        mySituation.muBaro.Lock()
                        mySituation.BaroPressureAltitude = float32(pressureAlt * 3.28084) // meters to feet
                        mySituation.BaroVerticalSpeed = float32(vspeed * 196.85)          // m/s in ft/min
                        mySituation.BaroLastMeasurementTime = stratuxClock.Time
                        mySituation.BaroSourceType = BARO_TYPE_OGNTRACKER
                        mySituation.muBaro.Unlock()
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        // Handling of all trackers via drivers. Care: serialPort might be nil during baud detection
        <span class="cov0" title="0">if detectedTracker != nil &amp;&amp; serialPort != nil </span><span class="cov0" title="0">{
                if detectedTracker.onNmea(serialPort, x) </span><span class="cov0" title="0">{
                        return true
                }</span>
        } else<span class="cov0" title="0"> if serialPort != nil </span><span class="cov0" title="0">{
                handled := false
                for _, tracker := range trackerDrivers </span><span class="cov0" title="0">{
                        handled = tracker.onNmea(serialPort, x) || handled
                        if tracker.isDetected() </span><span class="cov0" title="0">{
                                // First detected tracker. Write transient config and read back
                                detectedTracker = tracker
                                globalStatus.GPS_detected_type = tracker.getGpsHardwareType()
                                gpsTimeOffsetPpsMs = tracker.gpsTimeOffsetPps()
                                tracker.requestTrackerConfig(serialPort)
                                timelimit := stratuxClock.Time.Add(5 * time.Second)
                                go func() </span><span class="cov0" title="0">{
                                        for stratuxClock.Time.Before(timelimit) &amp;&amp; serialPort != nil &amp;&amp; detectedTracker == tracker </span><span class="cov0" title="0">{
                                                if tracker.isConfigRead() </span><span class="cov0" title="0">{
                                                        tracker.writeInitialConfig(serialPort)
                                                        break</span>
                                                }
                                                <span class="cov0" title="0">time.Sleep(20 * time.Millisecond)</span>
                                        }
                                }()
                                <span class="cov0" title="0">break</span>
                        }
                }

                <span class="cov0" title="0">if handled </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Only evaluate PGRMZ for SoftRF/Flarm, where we know that it is standard barometric pressure.
        // might want to add more types if applicable.
        // $PGRMZ,1089,f,3*2B
        <span class="cov0" title="0">if x[0] == "PGRMZ" &amp;&amp; ((globalStatus.GPS_detected_type&amp;0x0f) == GPS_TYPE_SERIAL || (globalStatus.GPS_detected_type&amp;0x0f) == GPS_TYPE_SOFTRF_DONGLE || (globalStatus.GPS_detected_type&amp;0x0f) == GPS_TYPE_SOFTRF) </span><span class="cov0" title="0">{
                if len(x) &lt; 3 </span><span class="cov0" title="0">{
                        return false
                }</span>
                // Assume pressure altitude in PGRMZ if we don't have any other baro (SoftRF style)
                <span class="cov0" title="0">pressureAlt, err := strconv.ParseFloat(x[1], 32)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">unit := x[2]
                if unit == "m" </span><span class="cov0" title="0">{
                        pressureAlt *= 3.28084
                }</span>
                // Prefer internal sensor and OGN tracker over this...
                <span class="cov0" title="0">if !isTempPressValid() || (mySituation.BaroSourceType != BARO_TYPE_BMP280 &amp;&amp; mySituation.BaroSourceType != BARO_TYPE_OGNTRACKER) </span><span class="cov0" title="0">{
                        mySituation.muBaro.Lock()
                        mySituation.BaroPressureAltitude = float32(pressureAlt) // meters to feet
                        mySituation.BaroLastMeasurementTime = stratuxClock.Time
                        mySituation.BaroSourceType = BARO_TYPE_NMEA
                        mySituation.muBaro.Unlock()
                        return true
                }</span>
        }

        // Flarm NMEA traffic data
        <span class="cov0" title="0">if x[0] == "PFLAU" || x[0] == "PFLAA" </span><span class="cov0" title="0">{
                parseFlarmNmeaMessage(x)
                return true
        }</span>

        // If we've gotten this far, the message isn't one that we can use.
        <span class="cov0" title="0">return false</span>
}

var gnssBaroAltDiffs = make(map[int]int)

// Little helper function to dump the gnssBaroAltDiffs map to CSV for plotting
//func dumpValues() {
//        vals := ""
//        for k, v := range gnssBaroAltDiffs {
//                vals += fmt.Sprintf("%d,%d\n", k*100, v)
//        }
//        ioutil.WriteFile("/tmp/values.csv", []byte(vals), 0644)
//}

// Maps 100ft bands to gnssBaroAltDiffs of known traffic.
// This will then be used to estimate our own baro altitude from GNSS if we don't have a pressure sensor connected...
// Sometimes dump1090 will deliver some strange invalid data with wild values, so we need some outlier detection.
// To achieve that, the algorithm works like this:
// 1. Create a linear regression over all confirmed targets altitude-&gt;GnssBaroDiff mapping
// 2. filter out targets that are more than +-400ft off from that regression
// 3. Now for the remaining targets, sort them into buckets again in a smoothed out way
// 4. Use a weighted linear regression with a higher weight around our own altitude to determine a smoothed-out GnssBaroDiff for our current altitude
// 5. Use GPS Alt +- GnssBaroDiff to determine our own baro alt

func baroAltGuesser() <span class="cov0" title="0">{
        ticker := time.NewTicker(1 * time.Second)
        for </span><span class="cov0" title="0">{
                &lt;-ticker.C
                // Create linear regression from GnssBaroAltDiffs we have confirmed already
                var alts, diffs []float64
                for k, v := range gnssBaroAltDiffs </span><span class="cov0" title="0">{
                        alts = append(alts, float64(k*100))
                        diffs = append(diffs, float64(v))
                }</span>
                <span class="cov0" title="0">slope, intercept, valid := common.LinReg(alts, diffs)
                //fmt.Printf("General: %f * x + %f \n", slope, intercept)

                trafficMutex.Lock()
                for _, ti := range traffic </span><span class="cov0" title="0">{
                        if ti.ReceivedMsgs &lt; 30 || ti.SignalLevel &lt; -28 || ti.SignalLevel &gt; -3 </span><span class="cov0" title="0">{
                                continue</span> // Make sure it is actually a confirmed target, so we don't accidentally use invalid values from invalid data
                        }
                        <span class="cov0" title="0">if stratuxClock.Since(ti.Last_GnssDiff) &gt; 1*time.Second || ti.Alt &lt;= 1 || stratuxClock.Since(ti.Last_alt) &gt; 1*time.Second </span><span class="cov0" title="0">{
                                continue</span> // already considered this value or we don't have a value - skip
                        }

                        <span class="cov0" title="0">bucket := int(ti.Alt / 100)
                        if bucket &lt;= 0 </span><span class="cov0" title="0">{
                                continue</span> // sometimes some random altitude reports - usually close to 0ft but GNSS diff from around 40000.. try to filter those
                        }

                        <span class="cov0" title="0">if len(gnssBaroAltDiffs) &gt;= 30 &amp;&amp; valid </span><span class="cov0" title="0">{
                                // Check if this ti is potentially an outlier/invalid data..
                                estimatedDiff := float64(ti.Alt)*slope + intercept
                                if math.Abs(float64(ti.GnssDiffFromBaroAlt)-estimatedDiff) &gt; 400 </span><span class="cov0" title="0">{
                                        fmt.Printf("Ignoring %d, alt=%d for baro computation. Expected GnssDiff: %f, Received: %d \n", ti.Icao_addr, ti.Alt, estimatedDiff, ti.GnssDiffFromBaroAlt)
                                        continue</span>
                                }
                        }

                        <span class="cov0" title="0">if val, ok := gnssBaroAltDiffs[bucket]; ok </span><span class="cov0" title="0">{
                                // weighted average - don't tune too quickly... smooth over one minute (for one aircraft, half a minute for two, etc).
                                gnssBaroAltDiffs[bucket] = (val*59 + int(ti.GnssDiffFromBaroAlt)*1) / 60
                        }</span> else<span class="cov0" title="0"> {
                                gnssBaroAltDiffs[bucket] = int(ti.GnssDiffFromBaroAlt)
                        }</span>
                }
                <span class="cov0" title="0">trafficMutex.Unlock()

                if len(gnssBaroAltDiffs) &lt; 30 </span><span class="cov0" title="0">{
                        continue</span> // not enough data
                }
                <span class="cov0" title="0">if isGPSValid() &amp;&amp; (!isTempPressValid() || mySituation.BaroSourceType == BARO_TYPE_NONE || mySituation.BaroSourceType == BARO_TYPE_ADSBESTIMATE) </span><span class="cov0" title="0">{
                        // We have no real baro source.. try to estimate baro altitude with the help of closeby ADS-B aircraft that define BaroGnssDiff...

                        myAlt := mySituation.GPSAltitudeMSL
                        if isTempPressValid() </span><span class="cov0" title="0">{
                                myAlt = mySituation.BaroPressureAltitude // we have something better than GPS from a previous run or something
                        }</span>
                        <span class="cov0" title="0">alts := make([]float64, 0, len(gnssBaroAltDiffs))
                        diffs := make([]float64, 0, len(gnssBaroAltDiffs))
                        weights := make([]float64, 0, len(gnssBaroAltDiffs)) // Weigh close altitudes higher than far altitudes for linreg
                        for k, v := range gnssBaroAltDiffs </span><span class="cov0" title="0">{
                                bucketAlt := float64(k*100 + 50)
                                alts = append(alts, bucketAlt) // Compute back from bucket to "real" altitude (+50 to be in the center of the bucket)
                                diffs = append(diffs, float64(v))
                                // Weight: 1 / altitudeDifference / 100
                                weight := math.Abs(float64(myAlt) - bucketAlt)
                                if weight == 0 </span><span class="cov0" title="0">{
                                        weight = 1
                                }</span> else<span class="cov0" title="0"> {
                                        weight = math.Min(1/(weight/1000), 1)
                                }</span>
                                <span class="cov0" title="0">weights = append(weights, weight*5)</span> // 5 = arbitrary factor to weight the local data even stronger compared to stuff thats 30000ft above.
                                // See https://www.desmos.com/calculator/qiqmb4wrev for why this seems to make sense.
                                // X-axis is altitude, Y axis is reported GnssBaroDiff
                        }
                        <span class="cov0" title="0">if len(gnssBaroAltDiffs) &gt;= 2 </span><span class="cov0" title="0">{
                                slope, intercept, valid := common.LinRegWeighted(alts, diffs, weights)
                                if valid </span><span class="cov0" title="0">{
                                        gnssBaroDiff := float64(myAlt)*slope + intercept
                                        mySituation.muBaro.Lock()
                                        mySituation.BaroLastMeasurementTime = stratuxClock.Time
                                        mySituation.BaroPressureAltitude = mySituation.GPSHeightAboveEllipsoid - float32(gnssBaroDiff)
                                        mySituation.BaroSourceType = BARO_TYPE_ADSBESTIMATE
                                        //fmt.Printf(" %f * x + %f \n", slope, intercept)
                                        mySituation.muBaro.Unlock()
                                }</span>
                        }
                }
        }
}

func gpsSerialReader() <span class="cov0" title="0">{
        defer serialPort.Close()
        readyToInitGPS = false //TODO: replace with channel control to terminate goroutine when complete

        i := 0 //debug monitor
        scanner := bufio.NewScanner(serialPort)
        for scanner.Scan() &amp;&amp; globalStatus.GPS_connected &amp;&amp; globalSettings.GPS_Enabled </span><span class="cov0" title="0">{
                i++
                if globalSettings.DEBUG &amp;&amp; i%100 == 0 </span><span class="cov0" title="0">{
                        log.Printf("gpsSerialReader() scanner loop iteration i=%d\n", i) // debug monitor
                }</span>

                <span class="cov0" title="0">s := scanner.Text()
                // Split the line into individual NMEA messages
                messages := strings.Split(s, "$")
                for _, msg := range messages </span><span class="cov0" title="0">{
                        if len(msg) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Add back the $ prefix that was removed by Split
                        <span class="cov0" title="0">msg = "$" + msg

                        if !processNMEALine(msg) </span><span class="cov0" title="0">{
                                if globalSettings.DEBUG </span><span class="cov0" title="0">{
                                        fmt.Printf("processNMEALine() exited early -- %s\n", msg)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                log.Printf("reading standard input: %s\n", err.Error())
        }</span>

        <span class="cov0" title="0">if globalSettings.DEBUG </span><span class="cov0" title="0">{
                log.Printf("Exiting gpsSerialReader() after i=%d loops\n", i) // debug monitor
        }</span>
        <span class="cov0" title="0">globalStatus.GPS_connected = false
        readyToInitGPS = true //TODO: replace with channel control to terminate goroutine when complete
        return</span>
}

func makeAHRSSimReport() <span class="cov0" title="0">{
        msg := createXPlaneAttitudeMsg(float32(mySituation.AHRSGyroHeading), float32(mySituation.AHRSPitch), float32(mySituation.AHRSRoll))
        sendXPlane(msg, 100*time.Millisecond, 1)
}</span>

/*

        ForeFlight "AHRS Message".

        Sends AHRS information to ForeFlight.

*/

func makeFFAHRSMessage() <span class="cov0" title="0">{
        msg := make([]byte, 12)
        msg[0] = 0x65 // Message type "ForeFlight".
        msg[1] = 0x01 // AHRS message identifier.

        // Values if invalid
        pitch := int16(0x7FFF)
        roll := int16(0x7FFF)
        hdg := uint16(0xFFFF)
        ias := uint16(0xFFFF)
        tas := uint16(0xFFFF)

        if isAHRSValid() </span><span class="cov0" title="0">{
                if !isAHRSInvalidValue(mySituation.AHRSPitch) </span><span class="cov0" title="0">{
                        pitch = common.RoundToInt16(mySituation.AHRSPitch * 10)
                }</span>
                <span class="cov0" title="0">if !isAHRSInvalidValue(mySituation.AHRSRoll) </span><span class="cov0" title="0">{
                        roll = common.RoundToInt16(mySituation.AHRSRoll * 10)
                }</span>
        }

        // Roll.
        <span class="cov0" title="0">msg[2] = byte((roll &gt;&gt; 8) &amp; 0xFF)
        msg[3] = byte(roll &amp; 0xFF)

        // Pitch.
        msg[4] = byte((pitch &gt;&gt; 8) &amp; 0xFF)
        msg[5] = byte(pitch &amp; 0xFF)

        // Heading.
        msg[6] = byte((hdg &gt;&gt; 8) &amp; 0xFF)
        msg[7] = byte(hdg &amp; 0xFF)

        // Indicated Airspeed.
        msg[8] = byte((ias &gt;&gt; 8) &amp; 0xFF)
        msg[9] = byte(ias &amp; 0xFF)

        // True Airspeed.
        msg[10] = byte((tas &gt;&gt; 8) &amp; 0xFF)
        msg[11] = byte(tas &amp; 0xFF)

        sendMsg(prepareMessage(msg), NETWORK_AHRS_GDL90, 200*time.Millisecond, 3)</span>
}

/*
        ffAttitudeSender()
         Send AHRS message in FF format every 200ms.
*/

func ffAttitudeSender() <span class="cov0" title="0">{
        ticker := time.NewTicker(200 * time.Millisecond)
        for </span><span class="cov0" title="0">{
                &lt;-ticker.C
                makeFFAHRSMessage()
        }</span>
}

func makeAHRSGDL90Report() <span class="cov0" title="0">{
        msg := make([]byte, 24)
        msg[0] = 0x4c
        msg[1] = 0x45
        msg[2] = 0x01
        msg[3] = 0x01

        // Values if invalid
        pitch := int16(0x7FFF)
        roll := int16(0x7FFF)
        hdg := int16(0x7FFF)
        slip_skid := int16(0x7FFF)
        yaw_rate := int16(0x7FFF)
        g := int16(0x7FFF)
        airspeed := int16(0x7FFF) // Can add this once we can read airspeed
        palt := uint16(0xFFFF)
        vs := int16(0x7FFF)
        if isAHRSValid() </span><span class="cov0" title="0">{
                if !isAHRSInvalidValue(mySituation.AHRSPitch) </span><span class="cov0" title="0">{
                        pitch = common.RoundToInt16(mySituation.AHRSPitch * 10)
                }</span>
                <span class="cov0" title="0">if !isAHRSInvalidValue(mySituation.AHRSRoll) </span><span class="cov0" title="0">{
                        roll = common.RoundToInt16(mySituation.AHRSRoll * 10)
                }</span>
                <span class="cov0" title="0">if !isAHRSInvalidValue(mySituation.AHRSGyroHeading) </span><span class="cov0" title="0">{
                        hdg = common.RoundToInt16(mySituation.AHRSGyroHeading * 10)
                }</span>
                <span class="cov0" title="0">if !isAHRSInvalidValue(mySituation.AHRSSlipSkid) </span><span class="cov0" title="0">{
                        slip_skid = common.RoundToInt16(-mySituation.AHRSSlipSkid * 10)
                }</span>
                <span class="cov0" title="0">if !isAHRSInvalidValue(mySituation.AHRSTurnRate) </span><span class="cov0" title="0">{
                        yaw_rate = common.RoundToInt16(mySituation.AHRSTurnRate * 10)
                }</span>
                <span class="cov0" title="0">if !isAHRSInvalidValue(mySituation.AHRSGLoad) </span><span class="cov0" title="0">{
                        g = common.RoundToInt16(mySituation.AHRSGLoad * 10)
                }</span>
        }
        <span class="cov0" title="0">if isTempPressValid() </span><span class="cov0" title="0">{
                palt = uint16(mySituation.BaroPressureAltitude + 5000.5)
                vs = common.RoundToInt16(float64(mySituation.BaroVerticalSpeed))
        }</span>

        // Roll.
        <span class="cov0" title="0">msg[4] = byte((roll &gt;&gt; 8) &amp; 0xFF)
        msg[5] = byte(roll &amp; 0xFF)

        // Pitch.
        msg[6] = byte((pitch &gt;&gt; 8) &amp; 0xFF)
        msg[7] = byte(pitch &amp; 0xFF)

        // Heading.
        msg[8] = byte((hdg &gt;&gt; 8) &amp; 0xFF)
        msg[9] = byte(hdg &amp; 0xFF)

        // Slip/skid.
        msg[10] = byte((slip_skid &gt;&gt; 8) &amp; 0xFF)
        msg[11] = byte(slip_skid &amp; 0xFF)

        // Yaw rate.
        msg[12] = byte((yaw_rate &gt;&gt; 8) &amp; 0xFF)
        msg[13] = byte(yaw_rate &amp; 0xFF)

        // "G".
        msg[14] = byte((g &gt;&gt; 8) &amp; 0xFF)
        msg[15] = byte(g &amp; 0xFF)

        // Indicated Airspeed
        msg[16] = byte((airspeed &gt;&gt; 8) &amp; 0xFF)
        msg[17] = byte(airspeed &amp; 0xFF)

        // Pressure Altitude
        msg[18] = byte((palt &gt;&gt; 8) &amp; 0xFF)
        msg[19] = byte(palt &amp; 0xFF)

        // Vertical Speed
        msg[20] = byte((vs &gt;&gt; 8) &amp; 0xFF)
        msg[21] = byte(vs &amp; 0xFF)

        // Reserved
        msg[22] = 0x7F
        msg[23] = 0xFF

        sendMsg(prepareMessage(msg), NETWORK_AHRS_GDL90, 100*time.Millisecond, 3)</span>
}

func gpsAttitudeSender() <span class="cov0" title="0">{
        timer := time.NewTicker(100 * time.Millisecond) // ~10Hz update.
        for </span><span class="cov0" title="0">{
                &lt;-timer.C
                if !(globalStatus.GPS_connected || globalStatus.IMUConnected) </span><span class="cov0" title="0">{
                        myGPSPerfStats = make([]gpsPerfStats, 0) // reinitialize statistics on disconnect / reconnect
                }</span> else<span class="cov0" title="0"> {
                        mySituation.muGPSPerformance.Lock()
                        calculateNavRate()
                        mySituation.muGPSPerformance.Unlock()
                }</span>

                <span class="cov0" title="0">for !(globalSettings.IMU_Sensor_Enabled &amp;&amp; globalStatus.IMUConnected) &amp;&amp; (globalSettings.GPS_Enabled &amp;&amp; globalStatus.GPS_connected) </span><span class="cov0" title="0">{
                        &lt;-timer.C

                        if !isGPSValid() || !calcGPSAttitude() </span><span class="cov0" title="0">{
                                logDbg("Couldn't calculate GPS-based attitude statistics\n")
                        }</span> else<span class="cov0" title="0"> {
                                mySituation.muGPSPerformance.Lock()
                                index := len(myGPSPerfStats) - 1
                                if index &gt; 1 </span><span class="cov0" title="0">{
                                        mySituation.AHRSPitch = myGPSPerfStats[index].gpsPitch
                                        mySituation.AHRSRoll = myGPSPerfStats[index].gpsRoll
                                        mySituation.AHRSGyroHeading = float64(mySituation.GPSTrueCourse)
                                        mySituation.AHRSLastAttitudeTime = stratuxClock.Time

                                        makeAHRSGDL90Report()
                                        makeAHRSSimReport()
                                        makeAHRSLevilReport()
                                }</span>
                                <span class="cov0" title="0">mySituation.muGPSPerformance.Unlock()</span>
                        }
                }
        }
}

/*
        updateConstellation(): Periodic cleanup and statistics calculation for 'Satellites'
                data structure. Calling functions must protect this in a mySituation.muSatellite.

*/

func updateConstellation() <span class="cov0" title="0">{
        var sats, tracked, seen uint8
        for svStr, thisSatellite := range Satellites </span><span class="cov0" title="0">{
                if stratuxClock.Since(thisSatellite.TimeLastTracked) &gt; 10*time.Second </span><span class="cov0" title="0">{ // remove stale satellites if they haven't been tracked for 10 seconds
                        delete(Satellites, svStr)
                }</span> else<span class="cov0" title="0"> { // satellite almanac data is "fresh" even if it isn't being received.
                        tracked++
                        if thisSatellite.Signal &gt; 0 </span><span class="cov0" title="0">{
                                seen++
                        }</span>
                        <span class="cov0" title="0">if stratuxClock.Since(thisSatellite.TimeLastSolution) &gt; 5*time.Second </span><span class="cov0" title="0">{
                                thisSatellite.InSolution = false
                                Satellites[svStr] = thisSatellite
                        }</span>
                        <span class="cov0" title="0">if thisSatellite.InSolution </span><span class="cov0" title="0">{ // TESTING: Determine "In solution" from structure (fix for multi-GNSS overflow)
                                sats++
                        }</span>
                        // do any other calculations needed for this satellite
                }
        }

        <span class="cov0" title="0">mySituation.GPSSatellites = uint16(sats)
        mySituation.GPSSatellitesTracked = uint16(tracked)
        mySituation.GPSSatellitesSeen = uint16(seen)</span>
}

func isGPSConnected() bool <span class="cov0" title="0">{
        return stratuxClock.Since(mySituation.GPSLastValidNMEAMessageTime) &lt; 5*time.Second
}</span>

/*
isGPSValid returns true only if a valid position fix has been seen in the last 3 seconds,
and if the GPS subsystem has recently detected a GPS device.

If false, 'GPSFixQuality` is set to 0 ("No fix"), as is the number of satellites in solution.
*/

func isGPSValid() bool <span class="cov6" title="68">{
        isValid := false
        if (stratuxClock.Since(mySituation.GPSLastFixLocalTime) &lt; 3*time.Second) &amp;&amp; globalStatus.GPS_connected &amp;&amp; mySituation.GPSFixQuality &gt; 0 </span><span class="cov4" title="10">{
                isValid = true
        }</span> else<span class="cov6" title="58"> {
                mySituation.GPSFixQuality = 0
                mySituation.GPSSatellites = 0
                mySituation.GPSHorizontalAccuracy = 999999
                mySituation.GPSVerticalAccuracy = 999999
                mySituation.GPSNACp = 0
        }</span>
        <span class="cov6" title="68">return isValid</span>
}

/*
isGPSGroundTrackValid returns true only if a valid ground track was obtained in the last 3 seconds,
and if NACp &gt;= 9.
*/

func isGPSGroundTrackValid() bool <span class="cov0" title="0">{
        return isGPSValid() &amp;&amp;
                (mySituation.GPSHorizontalAccuracy &lt; 30)
}</span>

func isGPSClockValid() bool <span class="cov0" title="0">{
        return !mySituation.GPSLastGPSTimeStratuxTime.IsZero() &amp;&amp; stratuxClock.Since(mySituation.GPSLastGPSTimeStratuxTime).Seconds() &lt; 15
}</span>

func isAHRSValid() bool <span class="cov2" title="3">{
        // If attitude information gets to be over 1 second old, declare invalid.
        // If no GPS then we won't use or send attitude information.
        return isGPSValid() &amp;&amp; stratuxClock.Since(mySituation.AHRSLastAttitudeTime).Seconds() &lt; 1
}</span>

func isTempPressValid() bool <span class="cov4" title="12">{
        return stratuxClock.Since(mySituation.BaroLastMeasurementTime).Seconds() &lt; 15
}</span>

func pollGPS() <span class="cov0" title="0">{
        readyToInitGPS = true //TODO: Implement more robust method (channel control) to kill zombie serial readers
        timer := time.NewTicker(4 * time.Second)
        go gpsAttitudeSender()
        go ffAttitudeSender()
        for </span><span class="cov0" title="0">{
                &lt;-timer.C
                // GPS enabled, was not connected previously?
                if globalSettings.GPS_Enabled &amp;&amp; !globalStatus.GPS_connected &amp;&amp; readyToInitGPS </span><span class="cov0" title="0">{ //TODO: Implement more robust method (channel control) to kill zombie serial readers
                        globalStatus.GPS_connected = initGPSSerial()
                        if globalStatus.GPS_connected &amp;&amp; (globalStatus.GPS_detected_type&amp;0x0f) != GPS_TYPE_NETWORK </span><span class="cov0" title="0">{
                                go gpsSerialReader()
                        }</span>
                }
        }
}

func initGPS(isReplayMode bool) <span class="cov0" title="0">{
        Satellites = make(map[string]SatelliteInfo)

        if !isReplayMode </span><span class="cov0" title="0">{
                go pollGPS()
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
        Copyright (c) 2023 Adrian Batzill
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        logging.go: Initialize go logging, watch log file size and rotate, delete old logs

*/

package main

import (
        "io"
        "log"
        "os"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "syscall"
        "time"

        "github.com/ricochet2200/go-disk-usage/du"
)

const debugLogFile = "stratux.log"

var debugLogf string // Set according to OS config.
var logFileHandle *os.File

func getStratuxLogFiles() []string <span class="cov0" title="0">{
        entries, err := os.ReadDir(logDir)
        stratuxLogs := make([]string, 0)
        if err != nil </span><span class="cov0" title="0">{
                return stratuxLogs
        }</span>

        <span class="cov0" title="0">for _, e := range entries </span><span class="cov0" title="0">{
                if strings.HasPrefix(e.Name(), debugLogFile+".") </span><span class="cov0" title="0">{
                        stratuxLogs = append(stratuxLogs, filepath.Join(logDirf, e.Name()))
                }</span>
        }
        <span class="cov0" title="0">sort.Strings(stratuxLogs)
        return stratuxLogs</span>
}

func rotateLogs() <span class="cov0" title="0">{
        stratuxLogs := getStratuxLogFiles()

        // rename suffix, remove if &gt; 9
        for i := len(stratuxLogs) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                parts := strings.Split(stratuxLogs[i], ".")
                logNum, err := strconv.Atoi(parts[len(parts)-1])
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">newPath := filepath.Join(logDirf, debugLogFile+"."+strconv.Itoa(logNum+1))

                if logNum == 9 </span><span class="cov0" title="0">{
                        os.Remove(stratuxLogs[i])
                }</span> else<span class="cov0" title="0"> {
                        os.Rename(stratuxLogs[i], newPath)
                }</span>
        }

        // Now rename current log file and re-open
        <span class="cov0" title="0">os.Rename(debugLogf, debugLogf+".1")
        openLogFile()</span>
}

func deleteOldestLog() int64 <span class="cov0" title="0">{
        logs := getStratuxLogFiles()
        if len(logs) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">oldest := logs[len(logs)-1]
        stat, err := os.Stat(oldest)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">err = os.Remove(oldest)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return stat.Size()</span>
}

func logFileSize() int64 <span class="cov0" title="0">{
        if logFileHandle == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">fileInfo, err := logFileHandle.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return fileInfo.Size()</span>
}

func clearDebugLogFile() <span class="cov0" title="0">{
        if logFileHandle != nil </span><span class="cov0" title="0">{
                _, err := logFileHandle.Seek(0, 0)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Could not seek to the beginning of the logfile\n")
                        return
                }</span> else<span class="cov0" title="0"> {
                        err2 := logFileHandle.Truncate(0)
                        if err2 != nil </span><span class="cov0" title="0">{
                                log.Printf("Could not truncate the logfile\n")
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("Logfile truncated\n")</span>
                }
        }
}

func logFileWatcher() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                logSize, err := os.Stat(debugLogf)
                if err == nil &amp;&amp; logSize.Size() &gt; 10*1024*1024 </span><span class="cov0" title="0">{ // 10mb limit
                        rotateLogs()
                }</span>

                <span class="cov0" title="0">usage := du.NewDiskUsage(logDirf)
                freeBytes := int64(usage.Free())
                for freeBytes &lt; 50*1024*1024 </span><span class="cov0" title="0">{ // leave 50mb free
                        deleted := deleteOldestLog()
                        if deleted == 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">freeBytes += deleted</span>
                }

                <span class="cov0" title="0">time.Sleep(30 * time.Second)</span>
        }
}

func openLogFile() <span class="cov0" title="0">{
        oldFp := logFileHandle
        debugLogf = filepath.Join(logDirf, debugLogFile)
        fp, err := os.OpenFile(debugLogf, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                addSingleSystemErrorf(debugLogf, "Failed to open '%s': %s", debugLogf, err.Error())
        }</span> else<span class="cov0" title="0"> {
                // Keep the logfile handle for later use
                logFileHandle = fp
                mfp := io.MultiWriter(fp, os.Stdout)
                log.SetOutput(mfp)

                // Make sure crash dumps are written to the log as well
                syscall.Dup3(int(fp.Fd()), 2, 0)
        }</span>
        <span class="cov0" title="0">if oldFp != nil </span><span class="cov0" title="0">{
                oldFp.Close()
        }</span>
}

func initLogging() <span class="cov0" title="0">{
        openLogFile()
        go logFileWatcher()
}</span>

// Log allways
func logInf(msg string, args ...any) <span class="cov0" title="0">{ log.Printf(msg, args...) }</span>

// Log on error (no special proccessing right now)
func logErr(msg string, args ...any) <span class="cov0" title="0">{ log.Printf(msg, args...) }</span>

// Log if debug enabled ("verbose message log" in settings tab)
func logDbg(msg string, args ...any) <span class="cov0" title="0">{
        if globalSettings.DEBUG </span><span class="cov0" title="0">{
                log.Printf(msg, args...)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "encoding/hex"
        "fmt"
        "log"
        "os"
        "time"
        "unsafe"

        "github.com/stratux/serial"
)

/*

#cgo LDFLAGS: -Wl,-rpath=${SRCDIR}/.. -Wl,-rpath=/opt/stratux/lib -L${SRCDIR}/.. -ldump978 -lm

#include &lt;stdint.h&gt;
#include "../dump978/fec.h"

*/
import "C"

var radioSerialConfig *serial.Config
var radioSerialPort *serial.Port

func initUATRadioSerial(isTraceReplayMode bool) error <span class="cov0" title="0">{
        // Init for FEC routines.
        C.init_fec()
        if isTraceReplayMode </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                watchTicker := time.NewTicker(1 * time.Second)
                for </span><span class="cov0" title="0">{
                        &lt;-watchTicker.C
                        // Watch for the radio or change in settings.
                        if !globalSettings.UAT_Enabled || globalStatus.UATRadio_connected </span><span class="cov0" title="0">{
                                // UAT not enabled or radio already set up. Continue.
                                continue</span>
                        }
                        <span class="cov0" title="0">if _, err := os.Stat("/dev/uatradio"); err != nil </span><span class="cov0" title="0">{
                                // Device not connected.
                                continue</span>
                        }
                        <span class="cov0" title="0">log.Printf("===== UAT Device Name  : UATRadio v1.0 =====\n")

                        // Initialize port at 2Mbaud.
                        radioSerialConfig = &amp;serial.Config{Name: "/dev/uatradio", Baud: 2000000}
                        p, err := serial.OpenPort(radioSerialConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("\tUAT Open Failed: %s\n", err.Error())
                                continue</span>
                        }

                        <span class="cov0" title="0">log.Printf("\tUATRadio init success.\n")

                        radioSerialPort = p
                        globalStatus.UATRadio_connected = true

                        // Start a goroutine to watch the serial port.
                        go radioSerialPortReader(radioSerialPort)</span>
                }
        }()
        <span class="cov0" title="0">return nil</span>
}

/*
radioSerialPortReader().

        Loop to read data from the radio serial port.
*/
var radioMagic = []byte{0x0a, 0xb0, 0xcd, 0xe0}

func radioSerialPortReader(serialPort *serial.Port) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                globalStatus.UATRadio_connected = false
                serialPort.Close()
        }</span>()
        <span class="cov0" title="0">tmpBuf := make([]byte, 1024) // Read buffer.
        var buf []byte               // Message buffer.
        for </span><span class="cov0" title="0">{
                n, err := serialPort.Read(tmpBuf)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("serial port err, shutting down radio: %s\n", err.Error())
                        return
                }</span>
                <span class="cov0" title="0">buf = append(buf, tmpBuf[:n]...)
                bufLen := len(buf)
                var finBuf []byte   // Truncated buffer, with processed messages extracted.
                var numMessages int // Number of messages extracted.
                // Search for a suitable message to extract.
                for i := 0; i &lt; bufLen-6; i++ </span><span class="cov0" title="0">{
                        if (buf[i] == radioMagic[0]) &amp;&amp; (buf[i+1] == radioMagic[1]) &amp;&amp; (buf[i+2] == radioMagic[2]) &amp;&amp; (buf[i+3] == radioMagic[3]) </span><span class="cov0" title="0">{
                                // Found the magic sequence. Get the length.
                                msgLen := int(uint16(buf[i+4])+(uint16(buf[i+5])&lt;&lt;8)) + 5 // 5 bytes for RSSI and TS.
                                // Check if we've read enough to finish this message.
                                if bufLen &lt; i+6+msgLen </span><span class="cov0" title="0">{
                                        break</span> // Wait for more of the message to come in.
                                }
                                // Message is long enough.
                                <span class="cov0" title="0">processRadioMessage(buf[i+6 : i+6+msgLen])
                                // Remove everything in the buffer before this message.
                                finBuf = buf[i+6+msgLen:]
                                numMessages++</span>
                        }
                }
                <span class="cov0" title="0">if numMessages &gt; 0 </span><span class="cov0" title="0">{
                        buf = finBuf
                }</span>
        }
}

/*
        processRadioMessage().
         Processes a single message from the radio. De-interleaves (when necessary), checks Reed-Solomon, passes to main process.
*/

func processRadioMessage(msg []byte) <span class="cov0" title="0">{
        TraceLog.Record(CONTEXT_LOWPOWERUAT, msg)
        // RSSI and message timestamp are prepended to the actual packet.

        // RSSI
        rssiRaw := int8(msg[0])
        //rssiAdjusted := int16(rssiRaw) - 132 // -132 dBm, calculated minimum RSSI.
        //rssiDump978 := int16(1000 * (10 ^ (float64(rssiAdjusted) / 20)))
        rssiDump978 := rssiRaw

        //_ := uint32(msg[1]) + (uint32(msg[2]) &lt;&lt; 8) + (uint32(msg[3]) &lt;&lt; 16) + (uint32(msg[4]) &lt;&lt; 24) // Timestamp. Currently unused.

        msg = msg[5:]

        var toRelay string
        var rs_errors int
        switch len(msg) </span>{
        case 552:<span class="cov0" title="0">
                to := make([]byte, 552)
                C.correct_uplink_frame((*C.uint8_t)(unsafe.Pointer(&amp;msg[0])), (*C.uint8_t)(unsafe.Pointer(&amp;to[0])), (*C.int)(unsafe.Pointer(&amp;rs_errors)))
                toRelay = fmt.Sprintf("+%s;ss=%d;", hex.EncodeToString(to[:432]), rssiDump978)</span>
        case 48:<span class="cov0" title="0">
                to := make([]byte, 48)
                copy(to, msg)
                i := int(C.correct_adsb_frame((*C.uint8_t)(unsafe.Pointer(&amp;to[0])), (*C.int)(unsafe.Pointer(&amp;rs_errors))))
                if i == 1 </span><span class="cov0" title="0">{
                        // Short ADS-B frame.
                        toRelay = fmt.Sprintf("-%s;ss=%d;", hex.EncodeToString(to[:18]), rssiDump978)
                }</span> else<span class="cov0" title="0"> if i == 2 </span><span class="cov0" title="0">{
                        // Long ADS-B frame.
                        toRelay = fmt.Sprintf("-%s;ss=%d;", hex.EncodeToString(to[:34]), rssiDump978)
                }</span>
        default:<span class="cov0" title="0">
                log.Printf("processRadioMessage(): unhandled message size %d\n", len(msg))</span>
        }

        <span class="cov0" title="0">if len(toRelay) &gt; 0 &amp;&amp; rs_errors != 9999 </span><span class="cov0" title="0">{
                o, msgtype := parseInput(toRelay)
                if o != nil &amp;&amp; msgtype != 0 </span><span class="cov0" title="0">{
                        relayMessage(msgtype, o)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
        Copyright (c) 2015-2016 Christopher Young
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        managementinterface.go: Web interfaces (JSON and websocket), web server for web interface HTML.
*/

package main

import (
        "archive/zip"
        "bytes"
        "compress/gzip"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "math"
        "net/http"
        "net/url"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "sync"
        "syscall"
        "text/template"
        "time"

        "database/sql"

        _ "github.com/mattn/go-sqlite3"

        humanize "github.com/dustin/go-humanize"
        "golang.org/x/net/websocket"

        "github.com/stratux/stratux/common"
)

type SettingMessage struct {
        Setting string `json:"setting"`
        Value   bool   `json:"state"`
}

type MbTileConnectionCacheEntry struct {
        Path     string
        Conn     *sql.DB
        Metadata map[string]string
        fileTime time.Time
}

func (this *MbTileConnectionCacheEntry) IsOutdated() bool <span class="cov0" title="0">{
        file, err := os.Stat(this.Path)
        if err != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">modTime := file.ModTime()
        return modTime != this.fileTime</span>
}

func NewMbTileConnectionCacheEntry(path string, conn *sql.DB) *MbTileConnectionCacheEntry <span class="cov0" title="0">{
        file, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;MbTileConnectionCacheEntry{path, conn, nil, file.ModTime()}</span>
}

var mbtileCacheLock = sync.Mutex{}
var mbtileConnectionCache = make(map[string]MbTileConnectionCacheEntry)

// Weather updates channel.
var weatherUpdate *uibroadcaster
var trafficUpdate *uibroadcaster
var radarUpdate *uibroadcaster
var gdl90Update *uibroadcaster

func handleGDL90WS(conn *websocket.Conn) <span class="cov0" title="0">{
        // Subscribe the socket to receive updates.
        gdl90Update.AddSocket(conn)

        // Connection closes when function returns. Since uibroadcast is writing and we don't need to read anything (for now), just keep it busy.
        for </span><span class="cov0" title="0">{
                buf := make([]byte, 1024)
                _, err := conn.Read(buf)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if buf[0] != 0 </span><span class="cov0" title="0">{ // Dummy.
                        continue</span>
                }
                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
        }
}

// Situation updates channel.
var situationUpdate *uibroadcaster

// Raw weather (UATFrame packet stream) update channel.
var weatherRawUpdate *uibroadcaster

/*
The /weather websocket starts off by sending the current buffer of weather messages, then sends updates as they are received.
*/
func handleWeatherWS(conn *websocket.Conn) <span class="cov0" title="0">{
        // Subscribe the socket to receive updates.
        weatherUpdate.AddSocket(conn)

        // Connection closes when function returns. Since uibroadcast is writing and we don't need to read anything (for now), just keep it busy.
        for </span><span class="cov0" title="0">{
                buf := make([]byte, 1024)
                _, err := conn.Read(buf)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if buf[0] != 0 </span><span class="cov0" title="0">{ // Dummy.
                        continue</span>
                }
                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
        }
}

func handleJsonIo(conn *websocket.Conn) <span class="cov0" title="0">{
        trafficMutex.Lock()
        for _, traf := range traffic </span><span class="cov0" title="0">{
                if !traf.Position_valid </span><span class="cov0" title="0">{ // Don't send unless a valid position exists.
                        continue</span>
                }
                <span class="cov0" title="0">trafficJSON, _ := json.Marshal(&amp;traf)
                conn.Write(trafficJSON)</span>
        }
        // Subscribe the socket to receive updates.
        <span class="cov0" title="0">trafficUpdate.AddSocket(conn)
        radarUpdate.AddSocket(conn)
        weatherRawUpdate.AddSocket(conn)
        situationUpdate.AddSocket(conn)

        trafficMutex.Unlock()

        // Connection closes when function returns. Since uibroadcast is writing and we don't need to read anything (for now), just keep it busy.
        for </span><span class="cov0" title="0">{
                buf := make([]byte, 1024)
                _, err := conn.Read(buf)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if buf[0] != 0 </span><span class="cov0" title="0">{ // Dummy.
                        continue</span>
                }
                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
        }
}

// Works just as weather updates do.

func handleTrafficWS(conn *websocket.Conn) <span class="cov0" title="0">{
        trafficMutex.Lock()
        for _, traf := range traffic </span><span class="cov0" title="0">{
                if !traf.Position_valid </span><span class="cov0" title="0">{ // Don't send unless a valid position exists.
                        continue</span>
                }
                <span class="cov0" title="0">trafficJSON, _ := json.Marshal(&amp;traf)
                conn.Write(trafficJSON)</span>
        }
        // Subscribe the socket to receive updates.
        <span class="cov0" title="0">trafficUpdate.AddSocket(conn)
        trafficMutex.Unlock()

        // Connection closes when function returns. Since uibroadcast is writing and we don't need to read anything (for now), just keep it busy.
        for </span><span class="cov0" title="0">{
                buf := make([]byte, 1024)
                _, err := conn.Read(buf)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if buf[0] != 0 </span><span class="cov0" title="0">{ // Dummy.
                        continue</span>
                }
                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
        }
}

func handleRadarWS(conn *websocket.Conn) <span class="cov0" title="0">{
        trafficMutex.Lock()
        // Subscribe the socket to receive updates. Not necessary to send old traffic
        radarUpdate.AddSocket(conn)
        trafficMutex.Unlock()

        radarUpdate.SendJSON(globalSettings)

        // Connection closes when function returns. Since uibroadcast is writing and we don't need to read anything (for now), just keep it busy.
        for </span><span class="cov0" title="0">{
                buf := make([]byte, 1024)
                _, err := conn.Read(buf)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if buf[0] != 0 </span><span class="cov0" title="0">{ // Dummy.
                        continue</span>
                }
                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
        }
}

func handleStatusWS(conn *websocket.Conn) <span class="cov0" title="0">{
        //        log.Printf("Web client connected.\n")

        timer := time.NewTicker(1 * time.Second)
        for </span><span class="cov0" title="0">{
                // The below is not used, but should be if something needs to be streamed from the web client ever in the future.
                /*                var msg SettingMessage
                                err := websocket.JSON.Receive(conn, &amp;msg)
                                if err == io.EOF {
                                        break
                                } else if err != nil {
                                        log.Printf("handleStatusWS: %s\n", err.Error())
                                } else {
                                        // Use 'msg'.
                                }
                */

                // Send status.
                update, _ := json.Marshal(&amp;globalStatus)
                _, err := conn.Write(update)

                if err != nil </span><span class="cov0" title="0">{
                        //                        log.Printf("Web client disconnected.\n")
                        break</span>
                }
                <span class="cov0" title="0">&lt;-timer.C</span>
        }
}

func handleSituationWS(conn *websocket.Conn) <span class="cov0" title="0">{
        timer := time.NewTicker(100 * time.Millisecond)
        for </span><span class="cov0" title="0">{
                situationJSON, _ := json.Marshal(&amp;mySituation)
                _, err := conn.Write(situationJSON)

                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">&lt;-timer.C</span>

        }

}

// AJAX call - /getStatus. Responds with current global status
// a webservice call for the same data available on the websocket but when only a single update is needed
func handleStatusRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        setNoCache(w)
        setJSONHeaders(w)
        statusJSON, _ := json.Marshal(&amp;globalStatus)
        fmt.Fprintf(w, "%s\n", statusJSON)
}</span>

// AJAX call - /getSituation. Responds with current situation (lat/lon/gdspeed/track/pitch/roll/heading/etc.)
func handleSituationRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        setNoCache(w)
        setJSONHeaders(w)
        situationJSON, _ := json.Marshal(&amp;mySituation)
        fmt.Fprintf(w, "%s\n", situationJSON)
}</span>

// AJAX call - /getTowers. Responds with all ADS-B ground towers that have sent messages that we were able to parse, along with its stats.
func handleTowersRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        setNoCache(w)
        setJSONHeaders(w)

        ADSBTowerMutex.Lock()
        towersJSON, err := json.Marshal(&amp;ADSBTowers)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending tower JSON data: %s\n", err.Error())
        }</span>
        // for testing purposes, we can return a fixed reply
        // towersJSON = []byte(`{"(38.490880,-76.135554)":{"Lat":38.49087953567505,"Lng":-76.13555431365967,"Signal_strength_last_minute":100,"Signal_strength_max":67,"Messages_last_minute":1,"Messages_total":1059},"(38.978698,-76.309276)":{"Lat":38.97869825363159,"Lng":-76.30927562713623,"Signal_strength_last_minute":495,"Signal_strength_max":32,"Messages_last_minute":45,"Messages_total":83},"(39.179285,-76.668413)":{"Lat":39.17928457260132,"Lng":-76.66841268539429,"Signal_strength_last_minute":50,"Signal_strength_max":24,"Messages_last_minute":1,"Messages_total":16},"(39.666309,-74.315300)":{"Lat":39.66630935668945,"Lng":-74.31529998779297,"Signal_strength_last_minute":9884,"Signal_strength_max":35,"Messages_last_minute":4,"Messages_total":134}}`)
        <span class="cov0" title="0">fmt.Fprintf(w, "%s\n", towersJSON)
        ADSBTowerMutex.Unlock()</span>
}

// AJAX call - /getSatellites. Responds with all GNSS satellites that are being tracked, along with status information.
func handleSatellitesRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        setNoCache(w)
        setJSONHeaders(w)
        mySituation.muSatellite.Lock()
        satellitesJSON, err := json.Marshal(&amp;Satellites)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending GNSS satellite JSON data: %s\n", err.Error())
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(w, "%s\n", satellitesJSON)
        mySituation.muSatellite.Unlock()</span>
}

// AJAX call - /getSettings. Responds with all stratux.conf data.
func handleSettingsGetRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        setNoCache(w)
        setJSONHeaders(w)
        settingsJSON, err := json.Marshal(&amp;globalSettings)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("%s", err)
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(w, "%s\n", settingsJSON)</span>
}

func handleRegionGet(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        setNoCache(w)
        setJSONHeaders(w)
        switch globalSettings.RegionSelected </span>{
        case 1:<span class="cov0" title="0">
                RegionSettings.IsSet = true
                RegionSettings.Region = "US"</span>
        case 2:<span class="cov0" title="0">
                RegionSettings.IsSet = true
                RegionSettings.Region = "EU"</span>
        default:<span class="cov0" title="0">
                RegionSettings.IsSet = false</span>
        }

        <span class="cov0" title="0">regionJSON, err := json.Marshal(&amp;RegionSettings)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("%s", err)
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(w, "%s\n", regionJSON)</span>
}

// AJAX call - /setRegion. receives via POST command, any/all stratux.conf data.
func handleRegionSet(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // define header in support of cross-domain AJAX
        setNoCache(w)
        setJSONHeaders(w)
        w.Header().Set("Access-Control-Allow-Method", "GET, POST, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept")
        if r.Method == "POST" </span><span class="cov0" title="0">{
                // raw, _ := httputil.DumpRequest(r, true)
                // log.Printf("handleRegionSet:raw: %s\n", raw)

                decoder := json.NewDecoder(r.Body)
                for </span><span class="cov0" title="0">{
                        var msg map[string]interface{} // support arbitrary JSON

                        err := decoder.Decode(&amp;msg)
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                log.Printf("handleRegionSet:error: %s\n", err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                for key, val := range msg </span><span class="cov0" title="0">{
                                        // log.Printf("handleRegionSet:json: testing for key:%s of type %s\n", key, reflect.TypeOf(val))
                                        switch key </span>{
                                        case "Region":<span class="cov0" title="0">
                                                val := val.(string)
                                                log.Printf("String is %s\n", val)
                                                if val == "US" </span><span class="cov0" title="0">{
                                                        globalSettings.RegionSelected = 1
                                                }</span> else<span class="cov0" title="0"> if val == "EU" </span><span class="cov0" title="0">{
                                                        globalSettings.RegionSelected = 2
                                                }</span> else<span class="cov0" title="0"> {
                                                        globalSettings.RegionSelected = 0
                                                }</span>
                                                <span class="cov0" title="0">changeRegionSettings()</span>
                                        default:<span class="cov0" title="0">
                                                log.Printf("handleRegionSet:json: unrecognized key:%s\n", key)</span>
                                        }
                                }
                                //                                saveSettings()
                        }
                }
        }

}

// AJAX call - /setSettings. receives via POST command, any/all stratux.conf data.
func handleSettingsSetRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // define header in support of cross-domain AJAX
        setNoCache(w)
        setJSONHeaders(w)
        w.Header().Set("Access-Control-Allow-Method", "GET, POST, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept")

        // for an OPTION method request, we return header without processing.
        // this insures we are recognized as supporting cross-domain AJAX REST calls
        if r.Method == "POST" </span><span class="cov0" title="0">{
                // raw, _ := httputil.DumpRequest(r, true)
                // log.Printf("handleSettingsSetRequest:raw: %s\n", raw)

                decoder := json.NewDecoder(r.Body)
                for </span><span class="cov0" title="0">{
                        var msg map[string]interface{} // support arbitrary JSON

                        err := decoder.Decode(&amp;msg)
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                log.Printf("handleSettingsSetRequest:error: %s\n", err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                reconfigureTracker := false
                                reconfigureFancontrol := false
                                for key, val := range msg </span><span class="cov0" title="0">{
                                        // log.Printf("handleSettingsSetRequest:json: testing for key:%s of type %s\n", key, reflect.TypeOf(val))
                                        switch key </span>{
                                        case "DarkMode":<span class="cov0" title="0">
                                                globalSettings.DarkMode = val.(bool)</span>
                                        case "UAT_Enabled":<span class="cov0" title="0">
                                                globalSettings.UAT_Enabled = val.(bool)</span>
                                        case "ES_Enabled":<span class="cov0" title="0">
                                                globalSettings.ES_Enabled = val.(bool)</span>
                                        case "OGN_Enabled":<span class="cov0" title="0">
                                                globalSettings.OGN_Enabled = val.(bool)</span>
                                        case "AIS_Enabled":<span class="cov0" title="0">
                                                globalSettings.AIS_Enabled = val.(bool)</span>
                                        case "APRS_Enabled":<span class="cov0" title="0">
                                                globalSettings.APRS_Enabled = val.(bool)</span>
                                        case "Ping_Enabled":<span class="cov0" title="0">
                                                globalSettings.Ping_Enabled = val.(bool)</span>
                                        case "Pong_Enabled":<span class="cov0" title="0">
                                                globalSettings.Pong_Enabled = val.(bool)</span>
                                        case "OGNI2CTXEnabled":<span class="cov0" title="0">
                                                globalSettings.OGNI2CTXEnabled = val.(bool)</span>
                                        case "GPS_Enabled":<span class="cov0" title="0">
                                                globalSettings.GPS_Enabled = val.(bool)</span>
                                        case "IMU_Sensor_Enabled":<span class="cov0" title="0">
                                                globalSettings.IMU_Sensor_Enabled = val.(bool)
                                                if !globalSettings.IMU_Sensor_Enabled &amp;&amp; globalStatus.IMUConnected </span><span class="cov0" title="0">{
                                                        myIMUReader.Close()
                                                        globalStatus.IMUConnected = false
                                                }</span>
                                        case "BMP_Sensor_Enabled":<span class="cov0" title="0">
                                                globalSettings.BMP_Sensor_Enabled = val.(bool)
                                                if !globalSettings.BMP_Sensor_Enabled &amp;&amp; globalStatus.BMPConnected </span><span class="cov0" title="0">{
                                                        myPressureReader.Close()
                                                        globalStatus.BMPConnected = false
                                                }</span>
                                        case "DEBUG":<span class="cov0" title="0">
                                                globalSettings.DEBUG = val.(bool)</span>
                                        case "DisplayTrafficSource":<span class="cov0" title="0">
                                                globalSettings.DisplayTrafficSource = val.(bool)</span>
                                        case "ReplayLog":<span class="cov0" title="0">
                                                v := val.(bool)
                                                if v != globalSettings.ReplayLog </span><span class="cov0" title="0">{ // Don't mark the files unless there is a change.
                                                        globalSettings.ReplayLog = v
                                                }</span>
                                        case "TraceLog":<span class="cov0" title="0">
                                                globalSettings.TraceLog = val.(bool)</span>
                                        case "AHRSLog":<span class="cov0" title="0">
                                                globalSettings.AHRSLog = val.(bool)</span>
                                        case "PersistentLogging":<span class="cov0" title="0">
                                                globalSettings.PersistentLogging = val.(bool)
                                                setPersistentLogging(globalSettings.PersistentLogging)</span>
                                        case "IMUMapping":<span class="cov0" title="0">
                                                if globalSettings.IMUMapping != val.([2]int) </span><span class="cov0" title="0">{
                                                        globalSettings.IMUMapping = val.([2]int)
                                                        myIMUReader.Close()
                                                        globalStatus.IMUConnected = false // Force a restart of the IMU reader
                                                }</span>
                                        case "Dump1090Gain":<span class="cov0" title="0">
                                                globalSettings.Dump1090Gain = (val.(float64))</span>
                                        case "PPM":<span class="cov0" title="0">
                                                globalSettings.PPM = int(val.(float64))</span>
                                        case "AltitudeOffset":<span class="cov0" title="0">
                                                globalSettings.AltitudeOffset = int(val.(float64))</span>
                                        case "RadarLimits":<span class="cov0" title="0">
                                                globalSettings.RadarLimits = int(val.(float64))
                                                radarUpdate.SendJSON(globalSettings)</span>
                                        case "RadarRange":<span class="cov0" title="0">
                                                globalSettings.RadarRange = int(val.(float64))
                                                radarUpdate.SendJSON(globalSettings)</span>
                                        case "Baud":<span class="cov0" title="0">
                                                if globalSettings.SerialOutputs != nil </span><span class="cov0" title="0">{
                                                        for dev, serialOut := range globalSettings.SerialOutputs </span><span class="cov0" title="0">{
                                                                newBaud := int(val.(float64))
                                                                if newBaud == serialOut.Baud </span><span class="cov0" title="0">{ // Same baud rate. No change.
                                                                        continue</span>
                                                                }
                                                                <span class="cov0" title="0">log.Printf("changing %s baud rate from %d to %d.\n", dev, serialOut.Baud, newBaud)
                                                                serialOut.Baud = newBaud
                                                                globalSettings.SerialOutputs[dev] = serialOut
                                                                closeSerial(dev)</span>
                                                        }
                                                }
                                        case "WatchList":<span class="cov0" title="0">
                                                globalSettings.WatchList = val.(string)</span>
                                        case "GLimits":<span class="cov0" title="0">
                                                globalSettings.GLimits = val.(string)</span>
                                        case "OwnshipModeS":<span class="cov0" title="0">
                                                codes := strings.Split(val.(string), ",")
                                                codesFinal := make([]string, 0)
                                                for _, code := range codes </span><span class="cov0" title="0">{
                                                        code = strings.Trim(code, " ")
                                                        // Expecting a hex string less than 6 characters (24 bits) long.
                                                        if len(code) &gt; 6 </span><span class="cov0" title="0">{ // Too long.
                                                                continue</span>
                                                        }
                                                        // Pad string, must be 6 characters long.
                                                        <span class="cov0" title="0">vals := strings.ToUpper(code)
                                                        for len(vals) &lt; 6 </span><span class="cov0" title="0">{
                                                                vals = "0" + vals
                                                        }</span>
                                                        <span class="cov0" title="0">hexn, err := hex.DecodeString(vals)
                                                        if err != nil </span><span class="cov0" title="0">{ // Number not valid.
                                                                log.Printf("handleSettingsSetRequest:OwnshipModeS: %s\n", err.Error())
                                                                continue</span>
                                                        }
                                                        <span class="cov0" title="0">codesFinal = append(codesFinal, fmt.Sprintf("%02X%02X%02X", hexn[0], hexn[1], hexn[2]))</span>
                                                }
                                                <span class="cov0" title="0">globalSettings.OwnshipModeS = strings.Join(codesFinal, ",")</span>
                                        case "StaticIps":<span class="cov0" title="0">
                                                ipsStr := val.(string)
                                                ips := strings.Split(ipsStr, " ")
                                                if ipsStr == "" </span><span class="cov0" title="0">{
                                                        ips = make([]string, 0)
                                                }</span>

                                                <span class="cov0" title="0">re, _ := regexp.Compile(`^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$`)
                                                err := ""
                                                for _, ip := range ips </span><span class="cov0" title="0">{
                                                        // Verify IP format
                                                        if !re.MatchString(ip) </span><span class="cov0" title="0">{
                                                                err = err + "Invalid IP: " + ip + ". "
                                                        }</span>
                                                }
                                                <span class="cov0" title="0">if err != "" </span><span class="cov0" title="0">{
                                                        log.Printf("handleSettingsSetRequest:StaticIps: %s\n", err)
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">globalSettings.StaticIps = ips</span>
                                        case "WiFiCountry":<span class="cov0" title="0">
                                                setWifiCountry(val.(string))</span>
                                        case "WiFiSSID":<span class="cov0" title="0">
                                                setWifiSSID(val.(string))</span>
                                        case "WiFiChannel":<span class="cov0" title="0">
                                                setWifiChannel(int(val.(float64)))</span>
                                        case "WiFiSecurityEnabled":<span class="cov0" title="0">
                                                setWifiSecurityEnabled(val.(bool))</span>
                                        case "WiFiPassphrase":<span class="cov0" title="0">
                                                setWifiPassphrase(val.(string))</span>
                                        case "WiFiIPAddress":<span class="cov0" title="0">
                                                setWifiIPAddress(val.(string))</span>
                                        case "WiFiMode":<span class="cov0" title="0">
                                                setWiFiMode(int(val.(float64)))</span>
                                        case "WiFiDirectPin":<span class="cov0" title="0">
                                                setWifiDirectPin(val.(string))</span>
                                        case "WiFiClientNetworks":<span class="cov0" title="0">
                                                var networks = make([]wifiClientNetwork, 0)
                                                for _, rawNetwork := range val.([]interface{}) </span><span class="cov0" title="0">{
                                                        network := rawNetwork.(map[string]interface{})
                                                        networks = append(networks, wifiClientNetwork{network["SSID"].(string), network["Password"].(string)})
                                                }</span>
                                                <span class="cov0" title="0">setWifiClientNetworks(networks)</span>
                                        case "WiFiInternetPassThroughEnabled":<span class="cov0" title="0">
                                                setWifiInternetPassthroughEnabled(val.(bool))</span>
                                        case "EstimateBearinglessDist":<span class="cov0" title="0">
                                                globalSettings.EstimateBearinglessDist = val.(bool)</span>

                                        case "OGNAddrType":<span class="cov0" title="0">
                                                globalSettings.OGNAddrType = int(val.(float64))
                                                reconfigureTracker = true</span>
                                        case "OGNAddr":<span class="cov0" title="0">
                                                globalSettings.OGNAddr = val.(string)
                                                reconfigureTracker = true</span>
                                        case "OGNAcftType":<span class="cov0" title="0">
                                                globalSettings.OGNAcftType = int(val.(float64))
                                                reconfigureTracker = true</span>
                                        case "OGNPilot":<span class="cov0" title="0">
                                                globalSettings.OGNPilot = val.(string)
                                                reconfigureTracker = true</span>
                                        case "OGNReg":<span class="cov0" title="0">
                                                globalSettings.OGNReg = val.(string)
                                                reconfigureTracker = true</span>
                                        case "OGNTxPower":<span class="cov0" title="0">
                                                globalSettings.OGNTxPower = int(val.(float64))
                                                reconfigureTracker = true</span>
                                        case "PWMDutyMin":<span class="cov0" title="0">
                                                globalSettings.PWMDutyMin = int(val.(float64))
                                                reconfigureFancontrol = true</span>

                                        default:<span class="cov0" title="0">
                                                log.Printf("handleSettingsSetRequest:json: unrecognized key:%s\n", key)</span>
                                        }
                                }
                                <span class="cov0" title="0">saveSettings()
                                applyNetworkSettings(false, false)
                                if reconfigureTracker &amp;&amp; detectedTracker != nil </span><span class="cov0" title="0">{
                                        writeTrackerConfigFromSettings()
                                }</span>
                                <span class="cov0" title="0">if reconfigureFancontrol </span><span class="cov0" title="0">{
                                        exec.Command("killall", "-SIGUSR1", "fancontrol").Run()
                                }</span>
                        }
                }

                // while it may be redundant, we return the latest settings
                <span class="cov0" title="0">settingsJSON, _ := json.Marshal(&amp;globalSettings)
                fmt.Fprintf(w, "%s\n", settingsJSON)</span>
        }
}

func setPersistentLogging(persistent bool) <span class="cov0" title="0">{
        if persistent </span><span class="cov0" title="0">{
                overlayctl("disable")
        }</span> else<span class="cov0" title="0"> {
                overlayctl("enable")
        }</span>
}

func handleShutdownRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        syscall.Sync()
        exec.Command("systemctl", "poweroff").Run()
}</span>

func doReboot() <span class="cov0" title="0">{
        syscall.Sync()
        exec.Command("systemctl", "reboot").Run()
}</span>

func handleDeleteLogFile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        log.Println("handleDeleteLogFile called!!!")
        clearDebugLogFile()
}</span>

func handleDeleteAHRSLogFiles(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        files, err := ioutil.ReadDir("/var/log")
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("error deleting AHRS logs: %s", err), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">var fn string
        for _, f := range files </span><span class="cov0" title="0">{
                fn = f.Name()
                if v, _ := filepath.Match("sensors_*.csv", fn); v </span><span class="cov0" title="0">{
                        os.Remove("/var/log/" + fn)
                        log.Printf("Deleting AHRS log file %s\n", fn)
                }</span>
                <span class="cov0" title="0">analysisLogger = nil</span>
        }
}

func handleDevelModeToggle(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        log.Printf("handleDevelModeToggle called!!!\n")
        globalSettings.DeveloperMode = true
        saveSettings()
}</span>

func handleRestartRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        log.Printf("handleRestartRequest called\n")
        go doRestartApp()
}</span>

func handleRebootRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        setNoCache(w)
        setJSONHeaders(w)
        w.Header().Set("Access-Control-Allow-Method", "GET, POST, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept")
        go delayReboot()
}</span>

func handleOrientAHRS(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // define header in support of cross-domain AJAX
        setNoCache(w)
        w.Header().Set("Content-Type", "text/plain")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Method", "GET, POST, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept")

        // For an OPTION method request, we return header without processing.
        // This ensures we are recognized as supporting cross-domain AJAX REST calls.
        if r.Method == "POST" </span><span class="cov0" title="0">{
                var (
                        action []byte = make([]byte, 1)
                        err    error
                )

                if _, err = r.Body.Read(action); err != nil </span><span class="cov0" title="0">{
                        log.Println("AHRS Error: handleOrientAHRS received invalid request")
                        http.Error(w, "orientation received invalid request", http.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">switch action[0] </span>{
                case 'f':<span class="cov0" title="0"> // Set sensor "forward" direction (toward nose of airplane).
                        f, err := getMinAccelDirection()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("AHRS Error: sensor orientation: couldn't read accelerometer: %s\n", err)
                                http.Error(w, fmt.Sprintf("couldn't read accelerometer: %s\n", err), http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("AHRS Info: sensor orientation success! forward axis is %d\n", f)
                        globalSettings.IMUMapping = [2]int{f, 0}</span>
                case 'd':<span class="cov0" title="0"> // Set sensor "up" direction (toward top of airplane).
                        globalSettings.SensorQuaternion = [4]float64{0, 0, 0, 0}
                        saveSettings()
                        myIMUReader.Close()
                        globalStatus.IMUConnected = false // restart the processes depending on the orientation
                        ResetAHRSGLoad()
                        time.Sleep(2000 * time.Millisecond)</span>
                }
        }
}

func handleCageAHRS(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // define header in support of cross-domain AJAX
        setNoCache(w)
        w.Header().Set("Content-Type", "text/plain")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Method", "GET, POST, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept")

        // For an OPTION method request, we return header without processing.
        // This ensures we are recognized as supporting cross-domain AJAX REST calls.
        if r.Method == "POST" </span><span class="cov0" title="0">{
                CageAHRS()
        }</span>
}

func handleCalibrateAHRS(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // define header in support of cross-domain AJAX
        setNoCache(w)
        w.Header().Set("Content-Type", "text/plain")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Method", "GET, POST, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept")

        // For an OPTION method request, we return header without processing.
        // This ensures we are recognized as supporting cross-domain AJAX REST calls.
        if r.Method == "POST" </span><span class="cov0" title="0">{
                CalibrateAHRS()
        }</span>
}

func handleResetGMeter(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // define header in support of cross-domain AJAX
        setNoCache(w)
        w.Header().Set("Content-Type", "text/plain")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Method", "GET, POST, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept")

        // For an OPTION method request, we return header without processing.
        // This ensures we are recognized as supporting cross-domain AJAX REST calls.
        if r.Method == "POST" </span><span class="cov0" title="0">{
                ResetAHRSGLoad()
        }</span>
}

func doRestartApp() <span class="cov0" title="0">{
        time.Sleep(1)
        syscall.Sync()
        out, err := exec.Command("/bin/systemctl", "restart", "stratux").Output()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("restart error: %s\n%s", err.Error(), out)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("restart: %s\n", out)
        }</span>
}

// AJAX call - /getClients. Responds with all connected clients.
func handleClientsGetRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        setNoCache(w)
        setJSONHeaders(w)
        netMutex.Lock()
        clientsJSON, _ := json.Marshal(&amp;clientConnections)
        netMutex.Unlock()
        fmt.Fprintf(w, "%s\n", clientsJSON)
}</span>

func delayReboot() <span class="cov0" title="0">{
        time.Sleep(1 * time.Second)
        doReboot()
}</span>

func handleDownloadLogRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        //w.Header().Set("Content-Type", "application/zip")
        w.Header().Set("Content-Disposition", "attachment; filename=stratux.log")
        http.ServeFile(w, r, "/var/log/stratux.log")
}</span>

func handleDownloadAHRSLogsRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Common error handler
        httpErr := func(w http.ResponseWriter, e error) </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("error zipping AHRS logs: %s", e), http.StatusNotFound)
        }</span>

        <span class="cov0" title="0">files, err := ioutil.ReadDir("/var/log")
        if err != nil </span><span class="cov0" title="0">{
                httpErr(w, err)
                return
        }</span>

        <span class="cov0" title="0">z := zip.NewWriter(w)
        defer z.Close()

        for _, f := range files </span><span class="cov0" title="0">{
                fn := f.Name()
                v1, _ := filepath.Match("sensors_*.csv", fn)
                v2, _ := filepath.Match("stratux.log", fn)
                if !(v1 || v2) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">unzippedFile, err := os.Open("/var/log/" + fn)
                if err != nil </span><span class="cov0" title="0">{
                        httpErr(w, err)
                        return
                }</span>

                <span class="cov0" title="0">fh, err := zip.FileInfoHeader(f)
                if err != nil </span><span class="cov0" title="0">{
                        httpErr(w, err)
                        return
                }</span>
                <span class="cov0" title="0">zippedFile, err := z.CreateHeader(fh)
                if err != nil </span><span class="cov0" title="0">{
                        httpErr(w, err)
                        return
                }</span>

                <span class="cov0" title="0">_, err = io.Copy(zippedFile, unzippedFile)
                if err != nil </span><span class="cov0" title="0">{
                        httpErr(w, err)
                        return
                }</span>
        }
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/zip")
        w.Header().Set("Content-Disposition", "attachment; filename=ahrs_logs.zip")</span>
}

func handleDownloadDBRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        //w.Header().Set("Content-Type", "application/zip")
        w.Header().Set("Content-Disposition", "attachment; filename=stratux.sqlite")
        http.ServeFile(w, r, "/var/log/stratux.sqlite")
}</span>

// Upload an update file.
func handleUpdatePostRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        setNoCache(w)
        setJSONHeaders(w)
        overlayctl("unlock")
        reader, err := r.MultipartReader()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Update failed from %s (%s).\n", r.RemoteAddr, err.Error())
                return
        }</span>

        <span class="cov0" title="0">var temp_filename string
        var upload_filename string

        var base_dir string

        if common.IsRunningAsRoot() </span><span class="cov0" title="0">{
                base_dir = "/overlay/robase/root"
        }</span> else<span class="cov0" title="0"> {
                base_dir = "."
                log.Printf("not running as root, using base_dir of %s", base_dir)
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                part, err := reader.NextPart()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Update failed from %s (%s).\n", r.RemoteAddr, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if part == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">if part.FormName() != "update_file" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">temp_filename = fmt.Sprintf("%s/TMP_%s", base_dir, part.FileName())
                upload_filename = fmt.Sprintf("%s/%s", base_dir, part.FileName())

                fi, err := os.OpenFile(temp_filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Update failed from %s (%s).\n", r.RemoteAddr, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">defer fi.Close()
                _, err = io.Copy(fi, part)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Update failed from %s (%s).\n", r.RemoteAddr, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">break</span>
        }

        <span class="cov0" title="0">os.Rename(temp_filename, upload_filename)
        log.Printf("%s uploaded %s for update.\n", r.RemoteAddr, upload_filename)
        overlayctl("disable")
        // Successful update upload. Now reboot.
        go delayReboot()</span>
}

// Upload an update file for Pong
func handlePongUpdatePostRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        setNoCache(w)
        setJSONHeaders(w)
        log.Printf("request: %s\n", r.URL.RequestURI())
        err := r.ParseMultipartForm(8 &lt;&lt; 20)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Step 1 Update failed from %s (%s).\n", r.RemoteAddr, err.Error())
                return
        }</span>
        <span class="cov0" title="0">file, _, err := r.FormFile("pong_update_file")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("FormFile returned error %s\n", err.Error())
                return
        }</span>
        <span class="cov0" title="0">fi, err := os.OpenFile("/tmp/update_pong.zip", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Cannot open file for saving (%s)\n", err.Error())
                return
        }</span>
        <span class="cov0" title="0">defer fi.Close()
        _, err = io.Copy(fi, file)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Could not copy file (%s)\n", err.Error())
                return
        }</span>
        <span class="cov0" title="0">log.Printf("Set update mode flag to signal Pong to run the update\n")
        pongSetUpdateMode()

        file.Close()</span>
}

func setNoCache(w http.ResponseWriter) <span class="cov0" title="0">{
        w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
        w.Header().Set("Pragma", "no-cache")
        w.Header().Set("Expires", "0")
}</span>

func setJSONHeaders(w http.ResponseWriter) <span class="cov0" title="0">{
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Content-Type", "application/json")
}</span>

func defaultServer(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Cache-Control", "max-age=360") // 5 min, so that if user installs update, he will revalidate soon enough
        //        setNoCache(w)
        http.FileServer(http.Dir(STRATUX_WWW_DIR)).ServeHTTP(w, r)
}</span>

func handleroPartitionRebuild(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        out, err := exec.Command("/usr/sbin/rebuild_ro_part.sh").Output()

        if err != nil </span><span class="cov0" title="0">{
                addSingleSystemErrorf("partition-rebuild", "Rebuild RO Partition error: %s", err.Error())
        }</span> else<span class="cov0" title="0"> {
                addSingleSystemErrorf("partition-rebuild", "Rebuild RO Partition success: %s", out)
        }</span>

}

// https://gist.github.com/alexisrobert/982674.
// Copyright (c) 2010-2014 Alexis ROBERT &lt;alexis.robert@gmail.com&gt;.
const dirlisting_tpl = `&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt;
&lt;!-- Modified from lighttpd directory listing --&gt;
&lt;head&gt;
&lt;title&gt;Index of {{.Name}}&lt;/title&gt;
&lt;style type="text/css"&gt;
a, a:active {text-decoration: none; color: blue;}
a:visited {color: #48468F;}
a:hover, a:focus {text-decoration: underline; color: red;}
body {background-color: #F5F5F5;}
h2 {margin-bottom: 12px;}
table {margin-left: 12px;}
th, td { font: 90% monospace; text-align: left;}
th { font-weight: bold; padding-right: 14px; padding-bottom: 3px;}
td {padding-right: 14px;}
td.s, th.s {text-align: right;}
div.list { background-color: white; border-top: 1px solid #646464; border-bottom: 1px solid #646464; padding-top: 10px; padding-bottom: 14px;}
div.foot { font: 90% monospace; color: #787878; padding-top: 4px;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;Index of {{.Name}}&lt;/h2&gt;
&lt;div class="list"&gt;
&lt;table summary="Directory Listing" cellpadding="0" cellspacing="0"&gt;
&lt;thead&gt;&lt;tr&gt;&lt;th class="n"&gt;Name&lt;/th&gt;&lt;th&gt;Last Modified&lt;/th&gt;&lt;th&gt;Size (bytes)&lt;/th&gt;&lt;th class="dl"&gt;Options&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;
{{range .Children_files}}
&lt;tr&gt;&lt;td class="n"&gt;&lt;a href="/logs/{{.Path}}"&gt;{{.Name}}&lt;/a&gt;&lt;/td&gt;&lt;td&gt;{{.Mtime}}&lt;/td&gt;&lt;td&gt;{{.Size}}&lt;/td&gt;&lt;td class="dl"&gt;&lt;a href="/logs/{{.Path}}"&gt;Download&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
{{end}}
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="foot"&gt;{{.ServerUA}}&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`

type fileInfo struct {
        Name  string
        Path  string
        Mtime string
        Size  string
}

// Manages directory listings
type dirlisting struct {
        Name           string
        Children_files []fileInfo
        ServerUA       string
}

// FIXME: This needs to be switched to show a "sessions log" from the sqlite database.
func viewLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        urlpath := strings.TrimPrefix(r.URL.Path, "/logs/")
        path := "/var/log/" + urlpath
        finfo, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                w.Write([]byte(fmt.Sprintf("Failed to open %s: %s", path, err.Error())))
                return
        }</span>

        <span class="cov0" title="0">if !finfo.IsDir() </span><span class="cov0" title="0">{
                http.ServeFile(w, r, path)
                return
        }</span>

        <span class="cov0" title="0">names, err := ioutil.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fi := make([]fileInfo, 0)
        for _, val := range names </span><span class="cov0" title="0">{
                if val.Name()[0] == '.' </span><span class="cov0" title="0">{
                        continue</span>
                } // Remove hidden files from listing

                <span class="cov0" title="0">if val.IsDir() </span><span class="cov0" title="0">{
                        mtime := val.ModTime().Format("2006-Jan-02 15:04:05")
                        sz := ""
                        fi = append(fi, fileInfo{Name: val.Name() + "/", Path: urlpath + "/" + val.Name(), Mtime: mtime, Size: sz})
                }</span> else<span class="cov0" title="0"> {
                        mtime := val.ModTime().Format("2006-Jan-02 15:04:05")
                        sz := humanize.Comma(val.Size())
                        fi = append(fi, fileInfo{Name: val.Name(), Path: urlpath + "/" + val.Name(), Mtime: mtime, Size: sz})
                }</span>
        }

        <span class="cov0" title="0">tpl, err := template.New("tpl").Parse(dirlisting_tpl)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data := dirlisting{Name: r.URL.Path, ServerUA: "Stratux " + stratuxVersion + "/" + stratuxBuild,
                Children_files: fi}

        err = tpl.Execute(w, data)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("viewLogs() error: %s\n", err.Error())
        }</span>

}

func connectMbTilesArchive(path string) (*sql.DB, map[string]string, error) <span class="cov0" title="0">{
        mbtileCacheLock.Lock()
        defer mbtileCacheLock.Unlock()
        if conn, ok := mbtileConnectionCache[path]; ok </span><span class="cov0" title="0">{
                if !conn.IsOutdated() </span><span class="cov0" title="0">{
                        return conn.Conn, conn.Metadata, nil
                }</span>
                <span class="cov0" title="0">log.Printf("Reloading MBTiles " + path)</span>
        }

        <span class="cov0" title="0">conn, err := sql.Open("sqlite3", "file:"+path+"?mode=ro")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">cacheEntry := NewMbTileConnectionCacheEntry(path, conn)
        cacheEntry.Metadata = readMbTilesMetadata(path, conn)
        if cacheEntry != nil </span><span class="cov0" title="0">{
                mbtileConnectionCache[path] = *cacheEntry
        }</span>
        <span class="cov0" title="0">return conn, cacheEntry.Metadata, nil</span>
}

func tileToDegree(z, x, y int) (lon, lat float64) <span class="cov0" title="0">{
        // osm-like schema:
        y = (1 &lt;&lt; z) - y - 1
        n := math.Pi - 2.0*math.Pi*float64(y)/math.Exp2(float64(z))
        lat = 180.0 / math.Pi * math.Atan(0.5*(math.Exp(n)-math.Exp(-n)))
        lon = float64(x)/math.Exp2(float64(z))*360.0 - 180.0
        return lon, lat
}</span>

func readMbTilesMetadata(fname string, db *sql.DB) map[string]string <span class="cov0" title="0">{
        rows, err := db.Query(`SELECT name, value FROM metadata 
                UNION SELECT 'minzoom', min(zoom_level) FROM tiles WHERE NOT EXISTS (SELECT * FROM metadata WHERE name='minzoom' and value is not null and value != '')
                UNION SELECT 'maxzoom', max(zoom_level) FROM tiles WHERE NOT EXISTS (SELECT * FROM metadata WHERE name='maxzoom' and value is not null and value != '')`)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("SQLite read error %s: %s", fname, err.Error())
                return nil
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        meta := make(map[string]string)
        for rows.Next() </span><span class="cov0" title="0">{
                var name, val string
                rows.Scan(&amp;name, &amp;val)
                if len(val) &gt; 0 </span><span class="cov0" title="0">{
                        meta[name] = val
                }</span>
        }
        // determine extent of layer if not given.. Openlayers kinda needs this, or it can happen that it tries to do
        // a billion request do down-scale high-res pngs that aren't even there (i.e. all 404s)
        <span class="cov0" title="0">if _, ok := meta["bounds"]; !ok </span><span class="cov0" title="0">{
                maxZoomInt, _ := strconv.ParseInt(meta["maxzoom"], 10, 32)
                rows, err = db.Query("SELECT min(tile_column), min(tile_row), max(tile_column), max(tile_row) FROM tiles WHERE zoom_level=?", maxZoomInt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("SQLite read error %s: %s", fname, err.Error())
                        return nil
                }</span>
                <span class="cov0" title="0">rows.Next()
                var xmin, ymin, xmax, ymax int
                rows.Scan(&amp;xmin, &amp;ymin, &amp;xmax, &amp;ymax)
                lonmin, latmin := tileToDegree(int(maxZoomInt), xmin, ymin)
                lonmax, latmax := tileToDegree(int(maxZoomInt), xmax+1, ymax+1)
                meta["bounds"] = fmt.Sprintf("%f,%f,%f,%f", lonmin, latmin, lonmax, latmax)</span>
        }

        // check if it is vectortiles and we have a style, then add the URL to metadata...
        <span class="cov0" title="0">if format, ok := meta["format"]; ok &amp;&amp; format == "pbf" </span><span class="cov0" title="0">{
                _, file := filepath.Split(fname)
                if _, err := os.Stat(STRATUX_HOME + "/mapdata/styles/" + file + "/style.json"); err == nil </span><span class="cov0" title="0">{
                        // We found a style!
                        meta["stratux_style_url"] = "/mapdata/styles/" + file + "/style.json"
                }</span>

        }
        <span class="cov0" title="0">return meta</span>
}

// Scans mapdata dir for all .db and .mbtiles files and returns json representation of all metadata values
func handleTilesets(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        files, err := ioutil.ReadDir(STRATUX_HOME + "/mapdata/")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("handleTilesets() error: %s\n", err.Error())
                http.Error(w, err.Error(), 500)
        }</span>
        <span class="cov0" title="0">result := make(map[string]map[string]string, 0)
        for _, f := range files </span><span class="cov0" title="0">{
                if f.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.HasSuffix(f.Name(), ".mbtiles") || strings.HasSuffix(f.Name(), ".db") </span><span class="cov0" title="0">{
                        _, meta, err := connectMbTilesArchive(STRATUX_HOME + "/mapdata/" + f.Name())
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("SQLite open "+f.Name()+" failed: %s", err.Error())
                                continue</span>
                        }
                        <span class="cov0" title="0">result[f.Name()] = meta</span>
                }
        }
        <span class="cov0" title="0">resJson, _ := json.Marshal(result)
        w.Write(resJson)</span>
}

func loadTile(fname string, z, x, y int) ([]byte, error) <span class="cov0" title="0">{
        db, meta, err := connectMbTilesArchive(STRATUX_HOME + "/mapdata/" + fname)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rows, err := db.Query("SELECT tile_data FROM tiles WHERE zoom_level=? AND tile_column=? AND tile_row=?", z, x, y)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to query mbtiles: %s", err.Error())
                return nil, nil
        }</span>

        <span class="cov0" title="0">defer rows.Close()
        for rows.Next() </span><span class="cov0" title="0">{
                var res []byte
                rows.Scan(&amp;res)
                // sometimes pbfs are gzipped...
                if format, ok := meta["format"]; ok &amp;&amp; format == "pbf" &amp;&amp; len(res) &gt;= 2 &amp;&amp; res[0] == 0x1f &amp;&amp; res[1] == 0x8b </span><span class="cov0" title="0">{
                        reader := bytes.NewReader(res)
                        gzreader, _ := gzip.NewReader(reader)
                        unzipped, err := ioutil.ReadAll(gzreader)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to unzip gzipped PBF data")
                                return nil, nil
                        }</span>
                        <span class="cov0" title="0">res = unzipped</span>
                }
                <span class="cov0" title="0">return res, nil</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

func handleTile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        parts := strings.Split(r.RequestURI, "/")
        if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">idx := len(parts) - 1
        y, err := strconv.Atoi(strings.Split(parts[idx], ".")[0])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to parse y", 500)
                return
        }</span>
        <span class="cov0" title="0">idx--
        x, _ := strconv.Atoi(parts[idx])
        idx--
        z, _ := strconv.Atoi(parts[idx])
        idx--
        file, _ := url.QueryUnescape(parts[idx])
        tileData, err := loadTile(file, z, x, y)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), 500)
        }</span> else<span class="cov0" title="0"> if tileData == nil </span><span class="cov0" title="0">{
                http.Error(w, "Tile not found", 404)
        }</span> else<span class="cov0" title="0"> {
                w.Write(tileData)
        }</span>
}

func managementInterface() <span class="cov0" title="0">{
        weatherUpdate = NewUIBroadcaster()
        trafficUpdate = NewUIBroadcaster()
        radarUpdate = NewUIBroadcaster()
        situationUpdate = NewUIBroadcaster()
        weatherRawUpdate = NewUIBroadcaster()
        gdl90Update = NewUIBroadcaster()

        http.HandleFunc("/", defaultServer)
        //http.Handle("/logs/", http.StripPrefix("/logs/", http.FileServer(http.Dir("/var/log"))))
        http.Handle("/mapdata/styles/", http.StripPrefix("/mapdata/styles/", http.FileServer(http.Dir(STRATUX_HOME+"/mapdata/styles"))))
        http.HandleFunc("/logs/", viewLogs)

        http.HandleFunc("/gdl90",
                func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                        s := websocket.Server{
                                Handler: websocket.Handler(handleGDL90WS)}
                        s.ServeHTTP(w, req)
                }</span>)
        <span class="cov0" title="0">http.HandleFunc("/status",
                func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                        s := websocket.Server{
                                Handler: websocket.Handler(handleStatusWS)}
                        s.ServeHTTP(w, req)
                }</span>)
        <span class="cov0" title="0">http.HandleFunc("/situation",
                func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                        s := websocket.Server{
                                Handler: websocket.Handler(handleSituationWS)}
                        s.ServeHTTP(w, req)
                }</span>)
        <span class="cov0" title="0">http.HandleFunc("/weather",
                func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                        s := websocket.Server{
                                Handler: websocket.Handler(handleWeatherWS)}
                        s.ServeHTTP(w, req)
                }</span>)
        <span class="cov0" title="0">http.HandleFunc("/traffic",
                func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                        s := websocket.Server{
                                Handler: websocket.Handler(handleTrafficWS)}
                        s.ServeHTTP(w, req)
                }</span>)
        <span class="cov0" title="0">http.HandleFunc("/radar",
                func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                        s := websocket.Server{
                                Handler: websocket.Handler(handleRadarWS)}
                        s.ServeHTTP(w, req)
                }</span>)

        <span class="cov0" title="0">http.HandleFunc("/jsonio",
                func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                        s := websocket.Server{
                                Handler: websocket.Handler(handleJsonIo)}
                        s.ServeHTTP(w, req)
                }</span>)

        <span class="cov0" title="0">http.HandleFunc("/getStatus", handleStatusRequest)
        http.HandleFunc("/getSituation", handleSituationRequest)
        http.HandleFunc("/getTowers", handleTowersRequest)
        http.HandleFunc("/getSatellites", handleSatellitesRequest)
        http.HandleFunc("/getSettings", handleSettingsGetRequest)
        http.HandleFunc("/getRegion", handleRegionGet)
        http.HandleFunc("/setRegion", handleRegionSet)
        http.HandleFunc("/setSettings", handleSettingsSetRequest)
        http.HandleFunc("/restart", handleRestartRequest)
        http.HandleFunc("/shutdown", handleShutdownRequest)
        http.HandleFunc("/reboot", handleRebootRequest)
        http.HandleFunc("/getClients", handleClientsGetRequest)
        http.HandleFunc("/updateUpload", handleUpdatePostRequest)
        http.HandleFunc("/updatePong", handlePongUpdatePostRequest)
        http.HandleFunc("/roPartitionRebuild", handleroPartitionRebuild)
        http.HandleFunc("/develmodetoggle", handleDevelModeToggle)
        http.HandleFunc("/orientAHRS", handleOrientAHRS)
        http.HandleFunc("/calibrateAHRS", handleCalibrateAHRS)
        http.HandleFunc("/cageAHRS", handleCageAHRS)
        http.HandleFunc("/resetGMeter", handleResetGMeter)
        http.HandleFunc("/deletelogfile", handleDeleteLogFile)
        http.HandleFunc("/downloadlog", handleDownloadLogRequest)
        http.HandleFunc("/deleteahrslogfiles", handleDeleteAHRSLogFiles)
        http.HandleFunc("/downloadahrslogs", handleDownloadAHRSLogsRequest)
        http.HandleFunc("/downloaddb", handleDownloadDBRequest)
        http.HandleFunc("/tiles/tilesets", handleTilesets)
        http.HandleFunc("/tiles/", handleTile)

        addr := fmt.Sprintf(":%d", ManagementAddr)
        log.Printf("web configuration console on port %s", addr)
        if err := http.ListenAndServe(addr, nil); err != nil </span><span class="cov0" title="0">{
                log.Printf("managementInterface ListenAndServe: %s\n", err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
        Copyright (c) 2021 Adrian Batzill
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        messagequeue.go: Prioritizing queue for slow network connections
*/

package main

import (
        "sort"
        "sync"
        "time"
)

type QueueEntry struct {
        priority   int32
        outdatedAt time.Time
        data       interface{}
}

type MessageQueue struct {
        maxSize       int
        entries       []QueueEntry
        DataAvailable chan bool
        Closed        bool
        mutex         sync.Mutex
}

func NewMessageQueue(maxSize int) *MessageQueue <span class="cov6" title="14">{
        return &amp;MessageQueue{
                maxSize:       maxSize,
                entries:       make([]QueueEntry, 0),
                DataAvailable: make(chan bool, 1),
        }
}</span>

func (queue *MessageQueue) Put(prio int32, maxAge time.Duration, data interface{}) <span class="cov9" title="48">{
        if queue.Closed </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov9" title="47">queue.mutex.Lock()
        defer queue.mutex.Unlock()

        timeout := stratuxClock.Time.Add(maxAge)
        entry := QueueEntry{prio, timeout, data}

        if queue.entries == nil || len(queue.entries) == 0 </span><span class="cov6" title="11">{
                queue.entries = make([]QueueEntry, 1)
                queue.entries[0] = QueueEntry{prio, timeout, data}
        }</span> else<span class="cov8" title="36"> {
                index := queue.findInsertPosition(prio)

                if index == len(queue.entries) </span><span class="cov7" title="26">{
                        queue.entries = append(queue.entries, entry)
                }</span> else<span class="cov5" title="10"> {
                        queue.entries = append(queue.entries[:index+1], queue.entries[index:]...)
                        queue.entries[index] = entry
                }</span>
        }

        // Allow 10% over-use before we prune, so the pruning is done in batches to save CPU
        <span class="cov9" title="47">if float32(len(queue.entries)) &gt; float32(queue.maxSize)*1.1 </span><span class="cov5" title="10">{
                queue.prune()
        }</span>
        <span class="cov9" title="47">if len(queue.entries) != 0 </span><span class="cov9" title="47">{
                queue.notifyData()
        }</span>
}

func (queue *MessageQueue) PeekFirst() (interface{}, int32) <span class="cov3" title="4">{
        return queue.getFirst(false)
}</span>

func (queue *MessageQueue) PopFirst() (interface{}, int32) <span class="cov7" title="19">{
        return queue.getFirst(true)
}</span>

func (queue *MessageQueue) getFirst(remove bool) (interface{}, int32) <span class="cov7" title="23">{
        queue.mutex.Lock()
        defer queue.mutex.Unlock()

        index := queue.getFirstUsableIndex()
        if index &lt; 0 </span><span class="cov2" title="2">{
                return nil, 0 // nothing in queue
        }</span>

        // found one. Strip the queue and return it
        <span class="cov7" title="21">entry := queue.entries[index]
        if remove </span><span class="cov7" title="18">{
                queue.entries = queue.entries[index+1:]
        }</span> else<span class="cov3" title="3"> {
                queue.entries = queue.entries[index:]
        }</span>
        <span class="cov7" title="21">return entry.data, entry.priority</span>
}

// Returns the first entry that's not outdated
func (queue *MessageQueue) getFirstUsableIndex() int <span class="cov7" title="23">{
        for i, data := range queue.entries </span><span class="cov7" title="22">{
                if data.outdatedAt.Before(stratuxClock.Time) </span><span class="cov1" title="1">{
                        // entry already timed out..
                        continue</span>
                }
                // found one
                <span class="cov7" title="21">return i</span>
        }

        // Nothing current in queue
        <span class="cov2" title="2">if len(queue.entries) &gt; 0 </span><span class="cov0" title="0">{
                queue.entries = make([]QueueEntry, 0)
        }</span>

        <span class="cov2" title="2">return -1</span>
}

func (queue *MessageQueue) GetQueueDump(pruneFirst bool) []interface{} <span class="cov3" title="4">{
        queue.mutex.Lock()
        defer queue.mutex.Unlock()

        if pruneFirst </span><span class="cov1" title="1">{
                queue.prune()
        }</span>
        <span class="cov3" title="4">data := make([]interface{}, len(queue.entries))
        for i, d := range queue.entries </span><span class="cov6" title="13">{
                data[i] = d.data
        }</span>
        <span class="cov3" title="4">return data</span>
}

// Removes elements from the queue so it fits its maxSize
// - All outdated elements are discarded
// - Low priority elements are discarded, starting with the oldest ones
func (queue *MessageQueue) prune() <span class="cov6" title="11">{
        // Group into priority categories, so we can then strip the beginning of each category is needed (remove oldest messages)
        newEntries := make([][]QueueEntry, 0)
        //npruned := 0
        totalUsable := 0
        prevPrio := int32(999999999)
        for _, entry := range queue.entries </span><span class="cov9" title="65">{
                if entry.outdatedAt.Before(stratuxClock.Time) </span><span class="cov0" title="0">{
                        continue</span> // outdated, remove completely
                }
                <span class="cov9" title="65">totalUsable++
                if len(newEntries) == 0 || entry.priority != prevPrio </span><span class="cov9" title="65">{
                        // new prio-category
                        newEntries = append(newEntries, make([]QueueEntry, 0))
                }</span>
                <span class="cov9" title="65">newEntries[len(newEntries)-1] = append(newEntries[len(newEntries)-1], entry)
                prevPrio = entry.priority</span>
        }
        <span class="cov6" title="11">toBeRemoved := totalUsable - queue.maxSize
        if toBeRemoved &gt; 0 </span><span class="cov5" title="10">{
                for i := len(newEntries) - 1; i &gt;= 0; i-- </span><span class="cov5" title="10">{
                        //fmt.Printf("%p: Pruning %d prio %d entries (%d available)\n", queue, toBeRemoved, newEntries[i][0].priority, len(newEntries[i]))
                        // From lowerst to highest prio, remove the oldest messages of each category until we have few enough in total
                        if len(newEntries[i]) &gt;= toBeRemoved </span><span class="cov5" title="10">{
                                // can remove enough in this category
                                newEntries[i] = newEntries[i][toBeRemoved:]
                                break</span>
                        } else<span class="cov0" title="0"> {
                                // remove this category, then proceed with next higher prio one
                                toBeRemoved -= len(newEntries[i])
                                newEntries[i] = nil
                        }</span>
                }
        }

        // finally, copy everything back to our queue
        <span class="cov6" title="11">queue.entries = make([]QueueEntry, 0)
        for _, category := range newEntries </span><span class="cov9" title="65">{
                if category != nil </span><span class="cov9" title="65">{
                        queue.entries = append(queue.entries, category...)
                }</span>
        }
}

func (queue *MessageQueue) findInsertPosition(priority int32) int <span class="cov8" title="39">{
        index := sort.Search(len(queue.entries), func(i int) bool </span><span class="cov10" title="68">{
                // &gt; instead of &gt;= so we get to the first entry that is larger - in order to keep insertion order
                // for equal-priority messages
                return queue.entries[i].priority &gt; priority
        }</span>)

        <span class="cov8" title="39">return index</span>
}

func (queue *MessageQueue) notifyData() <span class="cov9" title="48">{
        select </span>{
        case queue.DataAvailable &lt;- true:<span class="cov6" title="12"></span>
        default:<span class="cov8" title="36"></span>
        }
}

func (queue *MessageQueue) Close() <span class="cov2" title="2">{
        if queue.Closed </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov1" title="1">queue.Closed = true
        queue.notifyData()</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
        Copyright (c) 2015-2016 Christopher Young
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        Modifications (c) 2016 AvSquirrel (https://github.com/AvSquirrel)
        monotonic.go: Create monotonic clock using time.Timer - necessary because of real time clock changes on RPi.
*/

package main

import (
        humanize "github.com/dustin/go-humanize"
        "time"
)

// Timer (since start).

type monotonic struct {
        Milliseconds uint64
        Time         time.Time
        ticker       *time.Ticker
        realTimeSet  bool
        RealTime     time.Time
}

func (m *monotonic) Watcher() <span class="cov1" title="1">{
        for </span><span class="cov10" title="408">{
                &lt;-m.ticker.C
                m.Milliseconds += 10
                m.Time = m.Time.Add(10 * time.Millisecond)
                if m.realTimeSet </span><span class="cov0" title="0">{
                        m.RealTime = m.RealTime.Add(10 * time.Millisecond)
                }</span>
        }
}

func (m *monotonic) Since(t time.Time) time.Duration <span class="cov7" title="98">{
        return m.Time.Sub(t)
}</span>

func (m *monotonic) HumanizeTime(t time.Time) string <span class="cov0" title="0">{
        return humanize.RelTime(t, m.Time, "ago", "from now")
}</span>

func (m *monotonic) Unix() int64 <span class="cov0" title="0">{
        return int64(m.Since(time.Time{}).Seconds())
}</span>

func (m *monotonic) HasRealTimeReference() bool <span class="cov0" title="0">{
        return m.realTimeSet
}</span>

func (m *monotonic) SetRealTimeReference(t time.Time) <span class="cov0" title="0">{
        if !m.realTimeSet </span><span class="cov0" title="0">{ // Only allow the real clock to be set once.
                m.RealTime = t
                m.realTimeSet = true
        }</span>
}

func NewMonotonic() *monotonic <span class="cov1" title="1">{
        t := &amp;monotonic{Milliseconds: 0, Time: time.Time{}, ticker: time.NewTicker(10 * time.Millisecond)}
        go t.Watcher()
        return t
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
        Copyright (c) 2015-2016 Christopher Young
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        network.go: Client networking routines, DHCP lease monitoring, queue management, ICMP monitoring.
*/

package main

import (
        "bufio"
        "fmt"
        "io/ioutil"
        "log"
        "net"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/tarm/serial"
        "golang.org/x/net/icmp"
        "golang.org/x/net/ipv4"
        "tinygo.org/x/bluetooth"
)

var clientConnections map[string]connection // UDP out, TCP out, serial out

var dhcpLeases map[string]string
var networkGDL90Chan chan []byte // For gdl90 web socket
var netMutex *sync.Mutex         // netMutex needs to be locked before accessing dhcpLeases, pingResponse, and outSockets and calling isSleeping() and isThrottled().

var totalNetworkMessagesSent uint32

const (
        NETWORK_GDL90_STANDARD = 1
        NETWORK_AHRS_FFSIM     = 2
        NETWORK_AHRS_GDL90     = 4
        NETWORK_FLARM_NMEA     = 8
        NETWORK_POSITION_FFSIM = 16
        dhcp_lease_file        = "/var/lib/misc/dnsmasq.leases"
        dhcp_lease_dir         = "/var/lib/misc/"
        extra_hosts_file       = "/etc/stratux-static-hosts.conf"
)

var dhcpLeaseDirectoryLastTest time.Time // Last time fsWriteTest() was run on the DHCP lease directory.

// Read the "dnsmasq.leases" file and parse out IP/hostname.
func getDHCPLeases() (map[string]string, error) <span class="cov0" title="0">{
        // Do a write test. Even if we are able to read the file, it may be out of date because there's a fs write issue.
        // Only perform the test once every 5 minutes to minimize writes.
        if stratuxClock.Since(dhcpLeaseDirectoryLastTest) &gt;= 5*time.Minute </span><span class="cov0" title="0">{
                err := fsWriteTest(dhcp_lease_dir)
                if err != nil </span><span class="cov0" title="0">{
                        addSingleSystemErrorf("fs-write", "Write error on '%s', your EFB may have issues receiving weather and traffic.", dhcp_lease_dir)
                }</span>
                <span class="cov0" title="0">dhcpLeaseDirectoryLastTest = stratuxClock.Time</span>
        }
        <span class="cov0" title="0">dat, err := ioutil.ReadFile(dhcp_lease_file)
        ret := make(map[string]string)

        if err == nil </span><span class="cov0" title="0">{
                lines := strings.Split(string(dat), "\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        spaced := strings.Split(line, " ")
                        if len(spaced) &gt;= 4 </span><span class="cov0" title="0">{
                                ip := spaced[2]
                                host := spaced[3]
                                if host == "*" </span><span class="cov0" title="0">{
                                        host = ""
                                }</span>
                                <span class="cov0" title="0">ret[ip] = host</span>
                        }
                }
        }

        // Add IP's set through the settings page
        <span class="cov0" title="0">if globalSettings.StaticIps != nil </span><span class="cov0" title="0">{
                for _, ip := range globalSettings.StaticIps </span><span class="cov0" title="0">{
                        ret[ip] = ""
                }</span>
        }

        // Check kernel ARP table - useful when in client mode. We skip reverse hostname lookup since it can be very slow..
        <span class="cov0" title="0">dat2, err := ioutil.ReadFile("/proc/net/arp")
        if err != nil </span><span class="cov0" title="0">{
                return ret, nil
        }</span>
        <span class="cov0" title="0">iplines := strings.Split(string(dat2), "\n")
        for _, ipline := range iplines </span><span class="cov0" title="0">{
                spacedip := strings.Split(ipline, " ")
                if len(spacedip) &gt; 1 </span><span class="cov0" title="0">{
                        ip := spacedip[0]
                        if _, contained := ret[ip]; !contained &amp;&amp; ip[0] &gt;= '0' &amp;&amp; ip[0] &lt;= '2' </span><span class="cov0" title="0">{
                                ret[ip] = ""
                        }</span>
                }
        }

        // Added the ability to have static IP hosts stored in /etc/stratux-static-hosts.conf

        <span class="cov0" title="0">dat3, err := ioutil.ReadFile(extra_hosts_file)
        if err != nil </span><span class="cov0" title="0">{
                return ret, nil
        }</span>

        <span class="cov0" title="0">iplines = strings.Split(string(dat3), "\n")
        block_ip2 := ""
        for _, ipline := range iplines </span><span class="cov0" title="0">{
                spacedip := strings.Split(ipline, " ")
                if len(spacedip) == 2 </span><span class="cov0" title="0">{
                        // The ip is in block_ip2
                        block_ip2 = spacedip[0]
                        // the hostname is here
                        ret[block_ip2] = spacedip[1]
                }</span>
        }

        <span class="cov0" title="0">return ret, nil</span>
}

func networkOutWatcher() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                ch := &lt;-networkGDL90Chan
                gdl90Update.SendJSON(ch)
        }</span>
}

// Monitor serial output channel, send to serial port.
func serialOutWatcher() <span class="cov0" title="0">{
        // Check every 30 seconds for a serial output device.
        serialTicker := time.NewTicker(10 * time.Second)

        //FIXME: This is temporary. Only one serial output device for each protocol for now.
        serialDevs := make([]string, 0)
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                serialDevs = append(serialDevs, fmt.Sprintf("/dev/serialout%d", i))
                serialDevs = append(serialDevs, fmt.Sprintf("/dev/serialout_nmea%d", i))
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-serialTicker.C:<span class="cov0" title="0">
                        for _, serialDev := range serialDevs </span><span class="cov0" title="0">{
                                if _, err := os.Stat(serialDev); !os.IsNotExist(err) </span><span class="cov0" title="0">{ // Check if the device file exists.
                                        var config serialConnection

                                        // Master is globalSettings.SerialOutputs. Once we connect to one, it will be copied to the active connections map
                                        if val, ok := globalSettings.SerialOutputs[serialDev]; !ok </span><span class="cov0" title="0">{
                                                proto := uint8(NETWORK_GDL90_STANDARD)
                                                if strings.Contains(serialDev, "_nmea") </span><span class="cov0" title="0">{
                                                        proto = NETWORK_FLARM_NMEA
                                                }</span>
                                                <span class="cov0" title="0">if globalSettings.SerialOutputs == nil </span><span class="cov0" title="0">{
                                                        globalSettings.SerialOutputs = make(map[string]serialConnection)
                                                }</span>
                                                <span class="cov0" title="0">globalSettings.SerialOutputs[serialDev] = serialConnection{DeviceString: serialDev, Baud: 38400, Capability: proto, Queue: NewMessageQueue(1024)}
                                                log.Printf("detected new serial output, setting up now: %s. Default baudrate 38400.\n", serialDev)
                                                config = globalSettings.SerialOutputs[serialDev]

                                                saveSettings()</span>
                                        } else<span class="cov0" title="0"> {
                                                config = val
                                                if config.Capability == 0 </span><span class="cov0" title="0">{
                                                        config.Capability = NETWORK_GDL90_STANDARD // Fix old serial conns that didn't have protocol set
                                                }</span>
                                        }

                                        <span class="cov0" title="0">netMutex.Lock()

                                        needsConnect := true
                                        if activeConn, ok := clientConnections[serialDev]; ok </span><span class="cov0" title="0">{
                                                if !activeConn.IsSleeping() </span><span class="cov0" title="0">{
                                                        needsConnect = false
                                                }</span> else<span class="cov0" title="0"> {
                                                        go activeConn.Close() // expired/unplugged? async because it might lock..
                                                        delete(clientConnections, serialDev)
                                                }</span>
                                        }

                                        <span class="cov0" title="0">if needsConnect </span><span class="cov0" title="0">{
                                                cfg := &amp;serial.Config{Name: config.DeviceString, Baud: config.Baud}
                                                p, err := serial.OpenPort(cfg)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        log.Printf("serialout port (%s) err: %s\n", config.DeviceString, err.Error())
                                                }</span> else<span class="cov0" title="0"> {
                                                        log.Printf("opened serialout: Name: %s, Baud: %d\n", config.DeviceString, config.Baud)
                                                        // Save the serial port connection.
                                                        tmp := config
                                                        tmp.serialPort = p
                                                        clientConnections[serialDev] = &amp;tmp
                                                        go connectionWriter(&amp;tmp)
                                                }</span>
                                        }
                                        <span class="cov0" title="0">netMutex.Unlock()</span>
                                }
                        }
                }
        }
}

// TCP port 2000 for Airconnect-like NMEA-Out
func tcpNMEAOutListener() <span class="cov0" title="0">{
        ln, err := net.Listen("tcp", ":2000")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                conn, err := ln.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        continue</span>
                }
                <span class="cov0" title="0">key := "TCP:" + conn.RemoteAddr().String()

                tcpConn := &amp;tcpConnection{
                        conn.(*net.TCPConn),
                        NewMessageQueue(1024),
                        NETWORK_FLARM_NMEA,
                        key,
                }
                clientConnections[tcpConn.GetConnectionKey()] = tcpConn
                go connectionWriter(tcpConn)</span>
        }
}

/* Server that can be used to feed NMEA data to, e.g. to connect OGN Tracker wirelessly */
func tcpNMEAInListener() <span class="cov0" title="0">{
        ln, err := net.Listen("tcp", ":30011")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf(err.Error())
                return
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                conn, err := ln.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf(err.Error())
                        continue</span>
                }
                <span class="cov0" title="0">go handleNmeaInConnection(conn)</span>
        }
}
func handleNmeaInConnection(c net.Conn) <span class="cov0" title="0">{
        defer c.Close()
        reader := bufio.NewReader(c)
        // Set to fixed GPS_TYPE_NETWORK in the beginning, to override previous detected NMEA types
        globalStatus.GPS_detected_type = GPS_TYPE_NETWORK
        globalStatus.GPS_NetworkRemoteIp = strings.Split(c.RemoteAddr().String(), ":")[0]
        for </span><span class="cov0" title="0">{
                globalStatus.GPS_connected = true
                // Keep detected protocol, only ensure type=network
                globalStatus.GPS_detected_type = GPS_TYPE_NETWORK | (globalStatus.GPS_detected_type &amp; 0xf0)
                line, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">processNMEALine(line)</span>
        }
        <span class="cov0" title="0">globalStatus.GPS_connected = false
        globalStatus.GPS_detected_type = 0
        globalStatus.GPS_NetworkRemoteIp = ""</span>
}

// Returns the number of DHCP leases and prints queue lengths.
func getNetworkStats() <span class="cov0" title="0">{
        timer := time.NewTicker(15 * time.Second)

        for </span><span class="cov0" title="0">{
                &lt;-timer.C
                netMutex.Lock()

                var numNonSleepingClients uint

                for k, conn := range clientConnections </span><span class="cov0" title="0">{
                        // only use net conns
                        netconn, ok := conn.(*networkConnection)
                        if netconn == nil || !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if globalSettings.DEBUG </span><span class="cov0" title="0">{
                                queueBytes := 0
                                queueDump := netconn.Queue.GetQueueDump(true)
                                for _, msg := range queueDump </span><span class="cov0" title="0">{
                                        queueBytes += len(msg.([]byte))
                                }</span>
                                <span class="cov0" title="0">log.Printf("On  %s:%d,  Queue length = %d messages / %d bytes\n", netconn.Ip, netconn.Port, len(queueDump), queueBytes)</span>
                        }
                        <span class="cov0" title="0">ipAndPort := strings.Split(k, ":")
                        if len(ipAndPort) != 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Don't count the ping time if it is the same as stratuxClock epoch.
                        // If the client has responded to a ping in the last 15 minutes, count it as "connected" or "recent".
                        <span class="cov0" title="0">if !netconn.LastPingResponse.IsZero() &amp;&amp; stratuxClock.Since(netconn.LastPingResponse) &lt; 15*time.Minute </span><span class="cov0" title="0">{
                                numNonSleepingClients++
                        }</span>
                        <span class="cov0" title="0">if !netconn.LastPongResponse.IsZero() &amp;&amp; stratuxClock.Since(netconn.LastPongResponse) &lt; 15*time.Minute </span><span class="cov0" title="0">{
                                numNonSleepingClients++
                        }</span>
                }

                <span class="cov0" title="0">globalStatus.Connected_Users = numNonSleepingClients

                netMutex.Unlock()</span>
        }
}

// See who has a DHCP lease and make a UDP connection to each of them.
func refreshConnectedClients() <span class="cov0" title="0">{
        validConnections := make(map[string]bool)
        t, err := getDHCPLeases()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("getDHCPLeases(): %s\n", err.Error())
                return
        }</span>
        <span class="cov0" title="0">netMutex.Lock()
        defer netMutex.Unlock()

        dhcpLeases = t
        // Client connected that wasn't before.
        for ip, hostname := range dhcpLeases </span><span class="cov0" title="0">{
                for _, networkOutput := range globalSettings.NetworkOutputs </span><span class="cov0" title="0">{
                        ipAndPort := ip + ":" + strconv.Itoa(int(networkOutput.Port))
                        if _, ok := clientConnections[ipAndPort]; !ok </span><span class="cov0" title="0">{
                                log.Printf("client connected: %s:%d (%s).\n", ip, networkOutput.Port, hostname)
                                addr, err := net.ResolveUDPAddr("udp", ipAndPort)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("ResolveUDPAddr(%s): %s\n", ipAndPort, err.Error())
                                        continue</span>
                                }
                                <span class="cov0" title="0">outConn, err := net.DialUDP("udp", nil, addr)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("DialUDP(%s): %s\n", ipAndPort, err.Error())
                                        continue</span>
                                }
                                <span class="cov0" title="0">clientConnections[ipAndPort] = &amp;networkConnection{
                                        Conn:       outConn,
                                        Ip:         ip,
                                        Port:       networkOutput.Port,
                                        Capability: networkOutput.Capability,
                                        Queue:      NewMessageQueue(1024),
                                }
                                go connectionWriter(clientConnections[ipAndPort])</span>
                        }
                        <span class="cov0" title="0">validConnections[ipAndPort] = true</span>
                }
        }
        // Client that was connected before that isn't.
        <span class="cov0" title="0">for ipAndPort, netconn := range clientConnections </span><span class="cov0" title="0">{
                if conn, ok := netconn.(*networkConnection); ok </span><span class="cov0" title="0">{
                        if _, valid := validConnections[ipAndPort]; !valid </span><span class="cov0" title="0">{
                                log.Printf("removed connection %s.\n", ipAndPort)
                                conn.Queue.Close()
                                conn.Conn.Close()
                                delete(clientConnections, ipAndPort)
                        }</span>
                }
        }
}

func parseBleUuid(uuidStr string) (uuid bluetooth.UUID) <span class="cov0" title="0">{
        if len(uuidStr) == 4 </span><span class="cov0" title="0">{
                // Assume hex 16 bit
                var val uint64
                val, _ = strconv.ParseUint(uuidStr, 16, 16)
                uuid = bluetooth.New16BitUUID(uint16(val))
        }</span> else<span class="cov0" title="0"> {
                uuid, _ = bluetooth.ParseUUID(uuidStr)
        }</span>
        <span class="cov0" title="0">return</span>
}

var bleAdapter = bluetooth.DefaultAdapter

func initBluetooth() <span class="cov0" title="0">{
        if len(globalSettings.BleOutputs) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                if err := bleAdapter.Enable(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to init BLE adapter: %s", err.Error())
                        time.Sleep(5 * time.Second)
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }
        <span class="cov0" title="0">services := []bluetooth.UUID{}
        for _, conn := range globalSettings.BleOutputs </span><span class="cov0" title="0">{
                services = append(services, parseBleUuid(conn.UUIDService))
        }</span>

        <span class="cov0" title="0">adv := bleAdapter.DefaultAdvertisement()
        adv.Configure(bluetooth.AdvertisementOptions{
                LocalName:    globalSettings.WiFiSSID,
                ServiceUUIDs: services,
        })
        if err := adv.Start(); err != nil </span><span class="cov0" title="0">{
                addSingleSystemErrorf("BLE", "BLE Advertising failed to start: %s", err.Error())
        }</span>
        // TODO: not working if we have multiple GATTs in one service
        <span class="cov0" title="0">for i := range globalSettings.BleOutputs </span><span class="cov0" title="0">{
                conn := &amp;globalSettings.BleOutputs[i]
                err := bleAdapter.AddService(&amp;bluetooth.Service{
                        UUID: parseBleUuid(conn.UUIDService),
                        Characteristics: []bluetooth.CharacteristicConfig{
                                {
                                        Handle: &amp;conn.Characteristic,
                                        UUID:   parseBleUuid(conn.UUIDGatt),
                                        Value:  []byte{},
                                        Flags:  bluetooth.CharacteristicNotifyPermission | bluetooth.CharacteristicReadPermission | bluetooth.CharacteristicWriteWithoutResponsePermission,
                                        //WriteEvent: func(client bluetooth.Connection, offset int, value []byte) {
                                        //        log.Printf("client %d: received %s", client, string(value))
                                        //},
                                },
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to bring up BLE Gatt Service %s: %s", conn.UUIDService, err.Error())
                        continue</span>
                }
                <span class="cov0" title="0">netMutex.Lock()
                clientConnections[conn.GetConnectionKey()] = conn
                go connectionWriter(conn)
                netMutex.Unlock()</span>
        }
}

func onConnectionClosed(conn connection) <span class="cov0" title="0">{
        if conn == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">netMutex.Lock()
        key := conn.GetConnectionKey()
        delete(clientConnections, key)
        netMutex.Unlock()</span>
}

func collectMessages(conn connection) []byte <span class="cov0" title="0">{
        data := make([]byte, 0)
        maxMsgLen := 0
        for </span><span class="cov0" title="0">{
                if conn.IsSleeping() || conn.IsThrottled() </span><span class="cov0" title="0">{
                        _, prio := conn.MessageQueue().PeekFirst()
                        if conn.IsSleeping() &amp;&amp; prio &gt; -10 </span><span class="cov0" title="0">{
                                // If we are sleeping, only send heartbeats do detect a client becoming available
                                return data
                        }</span>
                        <span class="cov0" title="0">if conn.IsThrottled() &amp;&amp; prio &gt; 0 </span><span class="cov0" title="0">{
                                // if throttled, only send important stuff (position, status, crucial traffic)
                                return data
                        }</span>
                }

                <span class="cov0" title="0">newData, _ := conn.MessageQueue().PopFirst()
                if newData == nil </span><span class="cov0" title="0">{
                        return data // no more data to send
                }</span>
                <span class="cov0" title="0">msg := newData.([]byte)
                data = append(data, msg...)
                // So we can estimate if another message fits in
                if len(msg) &gt; maxMsgLen </span><span class="cov0" title="0">{
                        maxMsgLen = len(data)
                }</span>
                <span class="cov0" title="0">if len(data)+maxMsgLen &gt; conn.GetDesiredPacketSize() </span><span class="cov0" title="0">{
                        // Probably can't fit in another message
                        return data
                }</span>
        }
}

func connectionWriter(connection connection) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                queue := connection.MessageQueue()
                &lt;-queue.DataAvailable
                for </span><span class="cov0" title="0">{
                        if queue.Closed </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // Try to send around 1kb of data per packet to reduce IOPS when queue is full
                        <span class="cov0" title="0">msg := collectMessages(connection)
                        if msg == nil || len(msg) == 0 </span><span class="cov0" title="0">{
                                break</span> // Wait for next time that the DataAvailable channel has more for us
                        }
                        //fmt.Printf("Sending message bytes %d\n", len(msg))
                        <span class="cov0" title="0">written := 0
                        for written &lt; len(msg) </span><span class="cov0" title="0">{
                                writtenNow, err := connection.Writer().Write(msg)
                                written += writtenNow
                                if err != nil </span><span class="cov0" title="0">{
                                        connection.OnError(err)
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">totalNetworkMessagesSent++
                        globalStatus.NetworkDataMessagesSent++
                        globalStatus.NetworkDataBytesSent += uint64(written)</span>
                        //time.Sleep(532 * time.Millisecond)
                }
        }
}

func sendMsg(msg []byte, msgType uint8, maxAge time.Duration, priority int32) <span class="cov0" title="0">{
        if (msgType &amp; NETWORK_GDL90_STANDARD) != 0 </span><span class="cov0" title="0">{
                // It's a GDL90 message - do ui broadcast.
                networkGDL90Chan &lt;- msg
        }</span>

        <span class="cov0" title="0">netMutex.Lock()
        defer netMutex.Unlock()

        // Push to all UDP, TCP, Serial connections if they support the message
        for _, conn := range clientConnections </span><span class="cov0" title="0">{
                // Check if this port is able to accept the type of message we're sending.
                if (conn.Capabilities() &amp; msgType) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">conn.MessageQueue().Put(priority, maxAge, msg)</span>
        }
}

func sendGDL90(msg []byte, maxAge time.Duration, priority int32) <span class="cov0" title="0">{
        sendMsg(msg, NETWORK_GDL90_STANDARD, maxAge, priority)
}</span>

func sendXPlane(msg []byte, maxAge time.Duration, priority int32) <span class="cov0" title="0">{
        sendMsg(msg, NETWORK_POSITION_FFSIM, maxAge, priority)
}</span>

func sendNetFLARM(msg string, maxAge time.Duration, priority int32) <span class="cov0" title="0">{
        sendMsg([]byte(msg), NETWORK_FLARM_NMEA, maxAge, priority)
}</span>

func monitorDHCPLeases() <span class="cov0" title="0">{
        timer := time.NewTicker(30 * time.Second)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-timer.C:<span class="cov0" title="0">
                        refreshConnectedClients()</span>
                }
        }
}

func icmpEchoSender(c *icmp.PacketConn) <span class="cov0" title="0">{
        timer := time.NewTicker(5 * time.Second)
        for </span><span class="cov0" title="0">{
                &lt;-timer.C
                netMutex.Lock()
                // Collect IPs.
                ips := make(map[string]bool)
                for k, conn := range clientConnections </span><span class="cov0" title="0">{
                        if _, ok := conn.(*networkConnection); ok </span><span class="cov0" title="0">{
                                ipAndPort := strings.Split(k, ":")
                                ips[ipAndPort[0]] = true
                        }</span>
                }
                // Send to all IPs.
                <span class="cov0" title="0">for ip := range ips </span><span class="cov0" title="0">{
                        wm := icmp.Message{
                                Type: ipv4.ICMPTypeEcho, Code: 0,
                                Body: &amp;icmp.Echo{
                                        ID: os.Getpid() &amp; 0xffff, Seq: 1,
                                        Data: []byte("STRATUX"),
                                },
                        }
                        wb, err := wm.Marshal(nil)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("couldn't send ICMP Echo: %s\n", err.Error())
                                continue</span>
                        }
                        <span class="cov0" title="0">if _, err := c.WriteTo(wb, &amp;net.IPAddr{IP: net.ParseIP(ip)}); err != nil </span><span class="cov0" title="0">{
                                log.Printf("couldn't send ICMP Echo: %s\n", err.Error())
                                continue</span>
                        }
                        <span class="cov0" title="0">totalNetworkMessagesSent++</span>
                }
                <span class="cov0" title="0">netMutex.Unlock()</span>
        }
}

func getNetworkConn(ipAndPort string) *networkConnection <span class="cov0" title="0">{
        netMutex.Lock()
        defer netMutex.Unlock()
        if strings.Contains(ipAndPort, ":") </span><span class="cov0" title="0">{
                if conn, ok := clientConnections[ipAndPort]; ok </span><span class="cov0" title="0">{
                        if netconn, ok := conn.(*networkConnection); ok </span><span class="cov0" title="0">{
                                return netconn
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func getNetworkConnsByIp(ip string) []*networkConnection <span class="cov0" title="0">{
        conns := make([]*networkConnection, 0)
        // Search for any connection with the same IP to match ping responses
        for key, conn := range clientConnections </span><span class="cov0" title="0">{
                if netconn, ok := conn.(*networkConnection); ok </span><span class="cov0" title="0">{
                        if strings.HasPrefix(key, ip) </span><span class="cov0" title="0">{
                                conns = append(conns, netconn)
                        }</span>
                }
        }
        <span class="cov0" title="0">return conns</span>
}

func getSerialConns() []*serialConnection <span class="cov0" title="0">{
        netMutex.Lock()
        defer netMutex.Unlock()
        conns := make([]*serialConnection, 0)
        for _, conn := range clientConnections </span><span class="cov0" title="0">{
                if s, ok := conn.(*serialConnection); ok </span><span class="cov0" title="0">{
                        conns = append(conns, s)
                }</span>
        }
        <span class="cov0" title="0">return conns</span>
}

func closeSerial(dev string) <span class="cov0" title="0">{
        netMutex.Lock()
        defer netMutex.Unlock()
        if conn, ok := clientConnections[dev]; ok </span><span class="cov0" title="0">{
                delete(clientConnections, dev)
                go conn.Close()
        }</span>
}

// Monitor clients going in/out of sleep mode via ICMP unreachable packets.
func sleepMonitor() <span class="cov0" title="0">{
        c, err := icmp.ListenPacket("ip4:icmp", "0.0.0.0")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error listening for udp - sending data to all ports for all connected clients. err: %s", err)
                return
        }</span>
        <span class="cov0" title="0">go icmpEchoSender(c)
        defer c.Close()
        for </span><span class="cov0" title="0">{
                buf := make([]byte, 1500)
                n, peer, err := c.ReadFrom(buf)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("%s\n", err.Error())
                        continue</span>
                }
                <span class="cov0" title="0">msg, err := icmp.ParseMessage(1, buf[:n])
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ip := peer.String()

                // Look for echo replies, mark it as received.
                if msg.Type == ipv4.ICMPTypeEchoReply </span><span class="cov0" title="0">{
                        for _, conn := range getNetworkConnsByIp(ip) </span><span class="cov0" title="0">{
                                conn.LastPingResponse = stratuxClock.Time
                                conn.LastPongResponse = stratuxClock.Time
                        }</span>
                        <span class="cov0" title="0">continue</span> // No further processing needed.
                }

                // Only deal with ICMP Unreachable packets (since that's what iOS and Android seem to be sending whenever the apps are not available).
                <span class="cov0" title="0">if msg.Type != ipv4.ICMPTypeDestinationUnreachable </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Packet parsing.
                <span class="cov0" title="0">mb, err := msg.Body.Marshal(1)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if len(mb) &lt; 28 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // The unreachable port.
                <span class="cov0" title="0">port := (uint16(mb[26]) &lt;&lt; 8) | uint16(mb[27])
                ipAndPort := ip + ":" + strconv.Itoa(int(port))
                conn := getNetworkConn(ipAndPort)
                if conn != nil </span><span class="cov0" title="0">{
                        conn.LastUnreachable = stratuxClock.Time
                }</span>
        }
}

func networkStatsCounter() <span class="cov0" title="0">{
        timer := time.NewTicker(1 * time.Second)
        var previousNetworkMessagesSent, previousNetworkBytesSent uint64

        for </span><span class="cov0" title="0">{
                &lt;-timer.C
                globalStatus.NetworkDataMessagesSentLastSec = globalStatus.NetworkDataMessagesSent - previousNetworkMessagesSent
                globalStatus.NetworkDataBytesSentLastSec = globalStatus.NetworkDataBytesSent - previousNetworkBytesSent

                // debug option. Uncomment to log per-second network statistics. Useful for debugging WiFi instability.
                //log.Printf("Network data messages sent: %d total, %d last second.  Network data bytes sent: %d total, %d last second.\n", globalStatus.NetworkDataMessagesSent, globalStatus.NetworkDataMessagesSentLastSec, globalStatus.NetworkDataBytesSent, globalStatus.NetworkDataBytesSentLastSec)

                previousNetworkMessagesSent = globalStatus.NetworkDataMessagesSent
                previousNetworkBytesSent = globalStatus.NetworkDataBytesSent
        }</span>
}

func initNetwork() <span class="cov0" title="0">{
        networkGDL90Chan = make(chan []byte, 1024)
        clientConnections = make(map[string]connection)

        netMutex = &amp;sync.Mutex{}
        refreshConnectedClients()
        go monitorDHCPLeases() // Checks for new UDP connections
        go sleepMonitor()
        go networkStatsCounter()
        go serialOutWatcher()  // Check for new Serial connections
        go networkOutWatcher() // Pushes to websocket
        go tcpNMEAOutListener()
        go tcpNMEAInListener()
        go getNetworkStats()
        go initBluetooth()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
        Copyright (c) 2019 Adrian Batzill
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        networksettings.go: Management functions for network settings (wpa_supplicant, IP, DHCP)
*/

package main

import (
        "log"
        "os"
        "os/exec"
        "regexp"
        "strconv"
        "strings"
        "text/template"
        "time"
)

const (
        WifiModeAp       = 0
        WifiModeDirect   = 1
        WifiModeApClient = 2
)

// NetworkTemplateParams is passed to the template engine to write settings
type NetworkTemplateParams struct {
        WiFiMode                       int
        WiFiCountry                    string
        IpAddr                         string
        IpPrefix                       string
        DhcpRangeStart                 string
        DhcpRangeEnd                   string
        WiFiSSID                       string
        WiFiChannel                    int
        WiFiDirectPin                  string
        WiFiPassPhrase                 string
        WiFiClientNetworks             []wifiClientNetwork
        WiFiInternetPassThroughEnabled bool
}
type wifiClientNetwork struct {
        SSID     string
        Password string
}

var hasChanged bool

func setWifiCountry(countryCode string) <span class="cov0" title="0">{
        if countryCode != globalSettings.WiFiCountry </span><span class="cov0" title="0">{
                globalSettings.WiFiCountry = countryCode
                hasChanged = true
        }</span>
}

func setWifiSSID(ssid string) <span class="cov0" title="0">{
        if ssid != globalSettings.WiFiSSID </span><span class="cov0" title="0">{
                globalSettings.WiFiSSID = ssid
                hasChanged = true
        }</span>
}

func setWifiPassphrase(passphrase string) <span class="cov0" title="0">{
        if passphrase != globalSettings.WiFiPassphrase </span><span class="cov0" title="0">{
                globalSettings.WiFiPassphrase = passphrase
                hasChanged = true
        }</span>
}

func setWifiChannel(channel int) <span class="cov0" title="0">{
        if channel != globalSettings.WiFiChannel </span><span class="cov0" title="0">{
                globalSettings.WiFiChannel = channel
                hasChanged = true
        }</span>
}

func setWifiSecurityEnabled(enabled bool) <span class="cov0" title="0">{
        if globalSettings.WiFiSecurityEnabled != enabled </span><span class="cov0" title="0">{
                globalSettings.WiFiSecurityEnabled = enabled
                hasChanged = true
        }</span>
}

func setWifiIPAddress(ip string) <span class="cov0" title="0">{
        match, err := regexp.MatchString(`^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`, ip)
        if err == nil &amp;&amp; match </span><span class="cov0" title="0">{
                if globalSettings.WiFiIPAddress != ip </span><span class="cov0" title="0">{
                        globalSettings.WiFiIPAddress = ip
                        hasChanged = true
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("Ignoring invalid IP Address: " + ip)
        }</span>
}

func setWiFiMode(mode int) <span class="cov0" title="0">{
        if globalSettings.WiFiMode != mode </span><span class="cov0" title="0">{
                globalSettings.WiFiMode = mode
                hasChanged = true
        }</span>
}

func setWifiDirectPin(pin string) <span class="cov0" title="0">{
        if globalSettings.WiFiDirectPin != pin </span><span class="cov0" title="0">{
                globalSettings.WiFiDirectPin = pin
                hasChanged = true
        }</span>
}

func setWifiClientNetworks(networks []wifiClientNetwork) <span class="cov0" title="0">{
        if len(globalSettings.WiFiClientNetworks) != len(networks) </span><span class="cov0" title="0">{
                globalSettings.WiFiClientNetworks = networks
                hasChanged = true
                return
        }</span>

        <span class="cov0" title="0">for i, net := range networks </span><span class="cov0" title="0">{
                if globalSettings.WiFiClientNetworks[i].SSID != net.SSID || globalSettings.WiFiClientNetworks[i].Password != net.Password </span><span class="cov0" title="0">{
                        globalSettings.WiFiClientNetworks = networks
                        hasChanged = true
                        return
                }</span>
        }
}

func setWifiInternetPassthroughEnabled(enabled bool) <span class="cov0" title="0">{
        if globalSettings.WiFiInternetPassThroughEnabled != enabled </span><span class="cov0" title="0">{
                globalSettings.WiFiInternetPassThroughEnabled = enabled
                hasChanged = true
        }</span>
}

// if onlyWriteFiles is true, we only write the config files. Otherwise we also reconfigure the network
// Also, if we only write the files, this function runs synchroneously. Otherwise the long-running network reconfiguration is done async.
func applyNetworkSettings(force bool, onlyWriteFiles bool) <span class="cov0" title="0">{
        if !hasChanged &amp;&amp; !force </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">hasChanged = false

        // Prepare all template strings and write settings files, then ifdown/ifup wlan0
        ipAddr := globalSettings.WiFiIPAddress
        log.Printf("Applying new network settings for IP %s", ipAddr)
        if ipAddr == "" </span><span class="cov0" title="0">{
                ipAddr = "192.168.10.1"
        }</span>
        <span class="cov0" title="0">ipParts := strings.Split(ipAddr, ".")

        ipPrefix := ipParts[0] + "." + ipParts[1] + "." + ipParts[2]

        myIP, _ := strconv.Atoi(ipParts[3])
        dhcpRangeStart := ipPrefix + ".10"
        dhcpRangeEnd := ipPrefix + ".50"
        if myIP &gt;= 10 &amp;&amp; myIP &lt;= 50 </span><span class="cov0" title="0">{
                // In case the stratux ip is inside its dhcp range, we move the dhcp range back to something else..
                dhcpRangeStart = ipPrefix + ".60"
                dhcpRangeEnd = ipPrefix + ".110"
        }</span>

        <span class="cov0" title="0">var tplSettings NetworkTemplateParams
        tplSettings.WiFiMode = globalSettings.WiFiMode
        tplSettings.IpAddr = ipAddr
        tplSettings.IpPrefix = ipPrefix
        tplSettings.DhcpRangeStart = dhcpRangeStart
        tplSettings.DhcpRangeEnd = dhcpRangeEnd
        tplSettings.WiFiChannel = globalSettings.WiFiChannel
        tplSettings.WiFiCountry = globalSettings.WiFiCountry
        tplSettings.WiFiSSID = globalSettings.WiFiSSID
        tplSettings.WiFiDirectPin = globalSettings.WiFiDirectPin
        tplSettings.WiFiClientNetworks = globalSettings.WiFiClientNetworks
        tplSettings.WiFiInternetPassThroughEnabled = globalSettings.WiFiInternetPassThroughEnabled

        if tplSettings.WiFiChannel == 0 </span><span class="cov0" title="0">{
                tplSettings.WiFiChannel = 1
        }</span>
        <span class="cov0" title="0">if globalSettings.WiFiSecurityEnabled || tplSettings.WiFiMode == WifiModeDirect </span><span class="cov0" title="0">{
                tplSettings.WiFiPassPhrase = globalSettings.WiFiPassphrase
        }</span>

        <span class="cov0" title="0">if tplSettings.WiFiSSID == "" </span><span class="cov0" title="0">{
                tplSettings.WiFiSSID = "Stratux"
        }</span>

        <span class="cov0" title="0">f := func() </span><span class="cov0" title="0">{
                time.Sleep(time.Second)
                if !onlyWriteFiles </span><span class="cov0" title="0">{
                        cmd := exec.Command("ifdown", "wlan0")
                        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error shutting down WiFi: %s\n", err.Error())
                        }</span>
                        <span class="cov0" title="0">if err := cmd.Wait(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error shutting down WiFi: %s\n", err.Error())
                        }</span>
                }

                <span class="cov0" title="0">overlayctl("unlock")
                writeTemplate(STRATUX_HOME+"/cfg/stratux-dnsmasq.conf.template", "/overlay/robase/etc/dnsmasq.d/stratux-dnsmasq.conf", tplSettings)
                writeTemplate(STRATUX_HOME+"/cfg/interfaces.template", "/overlay/robase/etc/network/interfaces", tplSettings)
                writeTemplate(STRATUX_HOME+"/cfg/wpa_supplicant.conf.template", "/overlay/robase/etc/wpa_supplicant/wpa_supplicant.conf", tplSettings)
                writeTemplate(STRATUX_HOME+"/cfg/wpa_supplicant_ap.conf.template", "/overlay/robase/etc/wpa_supplicant/wpa_supplicant_ap.conf", tplSettings)
                overlayctl("lock")

                if !onlyWriteFiles </span><span class="cov0" title="0">{
                        cmd := exec.Command("ifup", "wlan0")
                        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error starting WiFi: %s\n", err.Error())
                        }</span>
                        <span class="cov0" title="0">if err := cmd.Wait(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error starting WiFi: %s\n", err.Error())
                        }</span>
                }
        }

        <span class="cov0" title="0">if onlyWriteFiles </span><span class="cov0" title="0">{
                f()
        }</span> else<span class="cov0" title="0"> {
                go f()
        }</span>
}

func writeTemplate(tplFile string, outFile string, settings NetworkTemplateParams) <span class="cov0" title="0">{
        configTemplate, err := template.ParseFiles(tplFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Network Settings: Unable to read settings template %s: %s", tplFile, err)
                return
        }</span>

        <span class="cov0" title="0">outputFile, err := os.Create(outFile)
        defer outputFile.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Network Settings: Unable to open output file %s: %s", outFile, err)
                return
        }</span>

        <span class="cov0" title="0">err = configTemplate.Execute(outputFile, settings)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Network Settings: Unable to execute template substitution %s: %s", outFile, err)
                return
        }</span>
        <span class="cov0" title="0">outputFile.Sync()</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
        Copyright (c) 2022 Quentin Bossard
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        aprs.go: Routines for reading traffic from aprs
*/

package main

import (
        "bufio"
        "encoding/hex"
        "fmt"
        "log"
        "net"
        "regexp"
        "strconv"
        "strings"
        "time"
)

var aprsOutgoingMsgChan chan string = make(chan string, 100)
var aprsIncomingMsgChan chan string = make(chan string, 100)
var aprsExitChan chan bool = make(chan bool, 1)

var aprsRegex = regexp.MustCompile(
        `(?P&lt;protocol&gt;ICA|FLR|SKY|PAW|OGN|RND|FMT|MTK|XCG|FAN|FNT)(?P&lt;id&gt;[\dA-Z]{6})&gt;` + // protocol, id
                `[A-Z]+,qAS,([\d\w]+):[\/]` + //
                `(?P&lt;time&gt;\d{6})h(?P&lt;longitude&gt;\d*\.?\d*[NS])[\/\\](?P&lt;lattitude&gt;\d*\.?\d*[EW])` + // time, lon, lat
                `\D` + // sep
                `((?P&lt;track&gt;\d{3})\/(?P&lt;speed&gt;\d{3})\/A=(?P&lt;altitude&gt;\d*))*` + // optional track, speed, alt
                `(\s!W(?P&lt;lonlatprecision&gt;\d+)!\s)*` + // optional lon lat precision
                `(id(?P&lt;id&gt;[\dA-F]{8}))*`) // optional id

func authenticate(c net.Conn) <span class="cov0" title="0">{
        filter := ""
        if mySituation.GPSFixQuality &gt; 0 </span><span class="cov0" title="0">{
                filter = fmt.Sprintf(
                        "filter r/%.7f/%.7f/%d\r\n",
                        mySituation.GPSLatitude, mySituation.GPSLongitude,
                        globalSettings.RadarRange*2) // RadarRange is an int in NM, APRS wants an int in km and 2~=1.852
        }</span>
        <span class="cov0" title="0">auth := fmt.Sprintf("user OGNNOCALL pass -1 vers stratux %s %s\r\n", globalStatus.Version, filter)
        log.Printf(auth)
        fmt.Fprintf(c, auth)</span>
}

func keepalive(c net.Conn) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(240 * time.Second)
                for t := range ticker.C </span><span class="cov0" title="0">{
                        if globalStatus.APRS_connected </span><span class="cov0" title="0">{
                                fmt.Fprintf(c, "# stratux keepalive %s\n", t)
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                }
        }()
}

func updateFilter(c net.Conn) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(10 * time.Second)
                for range ticker.C </span><span class="cov0" title="0">{
                        if globalStatus.APRS_connected </span><span class="cov0" title="0">{
                                if mySituation.GPSFixQuality &gt; 0 </span><span class="cov0" title="0">{
                                        filter := fmt.Sprintf(
                                                "#filter r/%.7f/%.7f/%d\r\n",
                                                mySituation.GPSLatitude, mySituation.GPSLongitude,
                                                globalSettings.RadarRange*2) // RadarRange is an int in NM, APRS wants an int in km and 2~=1.852
                                        fmt.Fprintf(c, filter)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                break</span>
                        }
                }
        }()
}

func aprsListen() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if !globalSettings.APRS_Enabled || !isGPSValid() </span><span class="cov0" title="0">{
                        // wait until APRS is enabled
                        time.Sleep(1 * time.Second)
                        continue</span>
                }
                <span class="cov0" title="0">if globalSettings.DEBUG </span><span class="cov0" title="0">{
                        log.Printf("aprs connecting...")
                }</span>
                <span class="cov0" title="0">conn, err := net.Dial("tcp", "aprs.glidernet.org:14580")
                if err != nil </span><span class="cov0" title="0">{ // Local connection failed.
                        time.Sleep(3 * time.Second)
                        continue</span>
                }
                <span class="cov0" title="0">authenticate(conn)
                keepalive(conn)
                updateFilter(conn)

                aprsReader := bufio.NewReader(conn)

                log.Printf("APRS successfully connected")
                globalStatus.APRS_connected = true

                // Make sure the exit channel is empty, so we don't exit immediately
                for len(aprsExitChan) &gt; 0 </span><span class="cov0" title="0">{
                        &lt;-aprsExitChan
                }</span>

                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        scanner := bufio.NewScanner(aprsReader)
                        for scanner.Scan() </span><span class="cov0" title="0">{
                                var temp string = scanner.Text()
                                select </span>{
                                case aprsIncomingMsgChan &lt;- temp:<span class="cov0" title="0"></span> // Put in the channel unless it is full
                                default:<span class="cov0" title="0">
                                        if globalSettings.DEBUG </span><span class="cov0" title="0">{
                                                log.Println("aprsIncomingMsgChan full. Discarding " + temp)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">if scanner.Err() != nil </span><span class="cov0" title="0">{
                                log.Printf("APRS issue: " + scanner.Err().Error())
                        }</span>
                        <span class="cov0" title="0">aprsExitChan &lt;- true</span>
                }()

        <span class="cov0" title="0">loop:
                for globalSettings.APRS_Enabled </span><span class="cov0" title="0">{
                        select </span>{
                        case data := &lt;-aprsIncomingMsgChan:<span class="cov0" title="0">
                                TraceLog.Record(CONTEXT_APRS, []byte(data))
                                parseAprsMessage(data, false)</span>

                        case &lt;-aprsExitChan:<span class="cov0" title="0">
                                break loop</span>
                        }
                }
                <span class="cov0" title="0">globalStatus.APRS_connected = false
                log.Printf("closing connection")
                conn.Close()
                time.Sleep(3 * time.Second)</span>
        }
}

func parseAprsMessage(data string, fakeCurrentTime bool) <span class="cov0" title="0">{

        if globalSettings.DEBUG </span><span class="cov0" title="0">{
                log.Printf("%+v\n", data)
        }</span>

        // APRS,qAS: aircraft beacon
        // APRS,TCPIP*,qAC: ground station beacon
        <span class="cov0" title="0">res := aprsRegex.FindStringSubmatch(data)
        if res == nil </span><span class="cov0" title="0">{ // no match
                if strings.Contains(data, "TCPIP*") </span>{<span class="cov0" title="0">
                        // log.Printf("GW data: " + data)
                }</span> else<span class="cov0" title="0"> {
                        if globalSettings.DEBUG </span><span class="cov0" title="0">{
                                log.Printf("No match for: " + data)
                        }</span>
                }
                <span class="cov0" title="0">return</span>
        } else<span class="cov0" title="0"> if len(res) &lt; 15 </span><span class="cov0" title="0">{ // too few captures
                log.Printf("Invalid APRS data format: " + data)
        }</span> else<span class="cov0" title="0"> if len(res[14]) &gt; 0 </span><span class="cov0" title="0">{
                ts := time.Now().UTC()
                hh, _ := strconv.ParseInt(res[4][:2], 10, 8)
                mm, _ := strconv.ParseInt(res[4][2:4], 10, 8)
                ss, err := strconv.ParseInt(res[4][4:], 10, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">ts = time.Date(ts.Year(), ts.Month(), ts.Day(), int(hh), int(mm), int(ss), 0, time.UTC)

                lat, err := strconv.ParseFloat(res[5][:2], 64)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">lat_m, err := strconv.ParseFloat(res[5][2:len(res[5])-1], 64)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">lat_m3d, err := strconv.ParseFloat(res[12][:1], 64)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if strings.Contains(res[5], "S") </span><span class="cov0" title="0">{
                        lat = -lat
                }</span>
                <span class="cov0" title="0">lon, err := strconv.ParseFloat(res[6][:3], 64)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">lon_m, err := strconv.ParseFloat(res[6][3:len(res[6])-1], 64)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">lon_m3d, err := strconv.ParseFloat(res[12][1:], 64)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if strings.Contains(res[6], "W") </span><span class="cov0" title="0">{
                        lon = -lon
                }</span>

                <span class="cov0" title="0">track, err := strconv.ParseFloat(res[8], 64)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">speed, err := strconv.ParseFloat(res[9], 64)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">alt, err := strconv.ParseFloat(res[10], 64)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">details, err := hex.DecodeString(res[14][:2])
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">detail_byte := details[0]
                addr_type := detail_byte &amp; 0b00000011
                acft_type := (detail_byte &amp; 0b00111100) &gt;&gt; 2

                msg := OgnMessage{
                        Sys:       res[1],
                        Time:      float64(ts.Unix()),
                        Addr:      res[2],
                        Addr_type: int32(addr_type),
                        Acft_type: fmt.Sprintf("%d", acft_type),
                        Lat_deg:   float32(lat + lat_m/60 + lat_m3d/60000),
                        Lon_deg:   float32(lon + lon_m/60 + lon_m3d/60000),
                        Alt_msl_m: float32(alt * 0.3048),
                        Track_deg: track,
                        Speed_mps: speed * 0.514444}

                if globalSettings.DEBUG </span><span class="cov0" title="0">{
                        // log.Printf("%+v\n", res)
                        log.Printf("%+v\n", msg)
                }</span>

                <span class="cov0" title="0">importOgnTrafficMessage(msg, data, fakeCurrentTime)</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
        Copyright (c) 2020 Adrian Batzill
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        ogn.go: Routines for reading traffic from ogn-rx-eu
*/

package main

import (
        "bufio"
        "encoding/binary"
        "encoding/hex"
        "encoding/json"
        "io/ioutil"
        "log"
        "net"
        "strconv"
        "strings"
        "time"

        "github.com/stratux/stratux/common"
)

// {"sys":"OGN","addr":"395F39","addr_type":3,"acft_type":"1","lat_deg":51.7657533,"lon_deg":-1.1918533,"alt_msl_m":124,"alt_std_m":63,"track_deg":0.0,"speed_mps":0.3,"climb_mps":-0.5,"turn_dps":0.0,"DOP":1.5}
type OgnMessage struct {
        Sys       string
        Time      float64
        Addr      string
        Addr_type int32
        Acft_type string
        Acft_cat  string
        Reg       string
        Lat_deg   float32
        Lon_deg   float32
        Alt_msl_m float32
        Alt_hae_m float32
        Alt_std_m float32
        Track_deg float64
        Speed_mps float64
        Climb_mps float64
        Turn_dps  float64
        DOP       float64
        SNR_dB    float64
        Rx_err    int32
        Hard      string

        // Status message (Sys=status):
        Bkg_noise_db float32
        Gain_db      float32
        Tx_enabled   bool
}

func ognPublishNmea(nmea string) <span class="cov0" title="0">{
        if globalStatus.OGN_connected </span><span class="cov0" title="0">{
                if !strings.HasSuffix(nmea, "\r\n") </span><span class="cov0" title="0">{
                        nmea += "\r\n"
                }</span>
                <span class="cov0" title="0">ognOutgoingMsgChan &lt;- nmea</span>
        }
}

var ognOutgoingMsgChan chan string = make(chan string, 100)
var ognIncomingMsgChan chan string = make(chan string, 100)
var ognExitChan chan bool = make(chan bool, 1)

func ognListen() <span class="cov0" title="0">{
        //go predTest()
        for </span><span class="cov0" title="0">{
                if !globalSettings.OGN_Enabled || OGNDev == nil </span><span class="cov0" title="0">{
                        // wait until OGN is enabled
                        time.Sleep(1 * time.Second)
                        continue</span>
                }
                // log.Printf("ogn-rx-eu connecting...")
                <span class="cov0" title="0">ognAddr := "127.0.0.1:30010"
                conn, err := net.Dial("tcp", ognAddr)
                if err != nil </span><span class="cov0" title="0">{ // Local connection failed.
                        time.Sleep(3 * time.Second)
                        continue</span>
                }
                <span class="cov0" title="0">log.Printf("ogn-rx-eu successfully connected")
                ognReadWriter := bufio.NewReadWriter(bufio.NewReader(conn), bufio.NewWriter(conn))
                globalStatus.OGN_connected = true

                // Make sure the exit channel is empty, so we don't exit immediately
                for len(ognExitChan) &gt; 0 </span><span class="cov0" title="0">{
                        &lt;-ognExitChan
                }</span>

                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        scanner := bufio.NewScanner(ognReadWriter.Reader)
                        for scanner.Scan() </span><span class="cov0" title="0">{
                                ognIncomingMsgChan &lt;- scanner.Text()
                        }</span>
                        <span class="cov0" title="0">if scanner.Err() != nil </span><span class="cov0" title="0">{
                                log.Printf("ogn-rx-eu connection lost: " + scanner.Err().Error())
                        }</span>
                        <span class="cov0" title="0">ognExitChan &lt;- true</span>
                }()

                <span class="cov0" title="0">pgrmzTimer := time.NewTicker(100 * time.Millisecond)

        loop:
                for globalSettings.OGN_Enabled </span><span class="cov0" title="0">{
                        select </span>{
                        case data := &lt;-ognOutgoingMsgChan:<span class="cov0" title="0">
                                //fmt.Printf(data)
                                ognReadWriter.Write([]byte(data))
                                ognReadWriter.Flush()</span>
                        case data := &lt;-ognIncomingMsgChan:<span class="cov0" title="0">
                                TraceLog.Record(CONTEXT_OGN_RX, []byte(data))
                                parseOgnMessage(data, false)</span>
                        case &lt;-pgrmzTimer.C:<span class="cov0" title="0">
                                if isTempPressValid() &amp;&amp; mySituation.BaroSourceType != BARO_TYPE_NONE &amp;&amp; mySituation.BaroSourceType != BARO_TYPE_ADSBESTIMATE </span><span class="cov0" title="0">{
                                        ognOutgoingMsgChan &lt;- makePGRMZString()
                                }</span>
                        case &lt;-ognExitChan:<span class="cov0" title="0">
                                break loop</span>

                        }
                }
                <span class="cov0" title="0">globalStatus.OGN_connected = false
                conn.Close()
                time.Sleep(3 * time.Second)</span>
        }
}

func parseOgnMessage(data string, fakeCurrentTime bool) <span class="cov0" title="0">{
        var thisMsg msg
        thisMsg.MessageClass = MSGCLASS_OGN
        thisMsg.TimeReceived = stratuxClock.Time
        thisMsg.Data = data

        var msg OgnMessage
        err := json.Unmarshal([]byte(data), &amp;msg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Invalid Data from OGN: " + data + " -&gt; " + err.Error())
                return
        }</span>

        <span class="cov0" title="0">if msg.Sys == "status" </span><span class="cov0" title="0">{
                importOgnStatusMessage(msg)
        }</span> else<span class="cov0" title="0"> {
                globalStatus.OGN_messages_total++
                msgLogAppend(thisMsg)
                logMsg(thisMsg) // writes to replay logs
                importOgnTrafficMessage(msg, data, fakeCurrentTime)
        }</span>
}

func importOgnStatusMessage(msg OgnMessage) <span class="cov0" title="0">{
        globalStatus.OGN_noise_db = msg.Bkg_noise_db
        globalStatus.OGN_gain_db = msg.Gain_db
        globalStatus.OGN_tx_enabled = msg.Tx_enabled

        // If we have an RFM95 or OGN Tracker connected, provide the config to ogn-rx-eu, so that it sends the same ID (either via RFM95 or internet)
        if msg.Tx_enabled || globalStatus.GPS_detected_type&amp;GPS_TYPE_OGNTRACKER &gt; 0 </span><span class="cov0" title="0">{
                ognPublishNmea(formatOgnTrackerConfigString())
        }</span>
}

func importOgnTrafficMessage(msg OgnMessage, data string, fakeCurrentTime bool) <span class="cov0" title="0">{
        var ti TrafficInfo
        addressBytes, _ := hex.DecodeString(msg.Addr)
        addressBytes = append([]byte{0}, addressBytes...) // prepend 0 byte
        if len(addressBytes) != 4 </span><span class="cov0" title="0">{
                log.Printf("Ignoring invalid ogn address: " + msg.Addr)
                return
        }</span>
        <span class="cov0" title="0">address := binary.BigEndian.Uint32(addressBytes)

        // GDL90 only knows 2 address types. ICAO and non-ICAO, so we map to those.
        // for OGN: 1=ICAO. For us: 0=ICAO, 1="ADS-B with Self-assigned address"
        addrType := uint8(1) // Non-ICAO Address
        otherAddrType := uint8(0)
        if msg.Addr_type == 1 </span><span class="cov0" title="0">{ // ICAO Address
                addrType = 0
                otherAddrType = 1
        }</span>
        // Store in higher-order bytes in front of the 24 bit address so we can handle address collinsions gracefully.
        // For ICAO it will be 0, so traffic is merged. For others it will be 1, so traffic is kept seperately
        // Only issue: PAW and FANET don't know the concept of address types. So for those, we need to be more tolerant.
        // There are 2 cases here:
        // - If non-PAW/FNT is received first, we can simply merge PAW/FNT onto that
        // - If PAW/FNT is received first, we might need to update the traffic type later on
        // To make the code a bit simpler, we don't actually update the existing traffic in the second case, but just let it time out
        // and - from then on - only update the one with the correct AddrType

        <span class="cov0" title="0">key := uint32(addrType)&lt;&lt;24 | address
        otherKey := uint32(otherAddrType)&lt;&lt;24 | address

        trafficMutex.Lock()
        defer trafficMutex.Unlock()

        if msg.Sys == "PAW" || msg.Sys == "FNT" </span><span class="cov0" title="0">{
                // First, assume the AddrType guess is wrong and try to merge.. Only if that fails we use our guessed AddrType
                _, otherAddrTypeOk := traffic[otherKey]
                if otherAddrTypeOk </span><span class="cov0" title="0">{
                        key = otherKey
                        addrType = otherAddrType
                }</span>
        }

        <span class="cov0" title="0">if fakeCurrentTime </span><span class="cov0" title="0">{
                msg.Time = float64(time.Now().UTC().Unix())
        }</span>

        <span class="cov0" title="0">if existingTi, ok := traffic[key]; ok </span><span class="cov0" title="0">{
                ti = existingTi
                // ogn-rx sends 2 types of messages.. normal ones with coords etc, and ones that only supply additional info (registration, Hardware, ...). These usually don't have
                // coords, so we can't validate them easily. Therefore, this is handled before other validations and only if we already received the traffic earlier
                hasInfo := false
                if len(msg.Reg) &gt; 0 </span><span class="cov0" title="0">{
                        ti.Tail = msg.Reg
                        hasInfo = true
                }</span>
                <span class="cov0" title="0">if msg.Hard == "STX" </span><span class="cov0" title="0">{
                        ti.IsStratux = true
                        hasInfo = true
                }</span>
                <span class="cov0" title="0">if hasInfo </span><span class="cov0" title="0">{
                        traffic[key] = ti
                }</span>
                <span class="cov0" title="0">if msg.Time &gt; 0 &amp;&amp; !ti.Timestamp.IsZero() </span><span class="cov0" title="0">{
                        msgtime := time.Unix(int64(msg.Time), 0)
                        if ti.Position_valid &amp;&amp; ti.Last_source == TRAFFIC_SOURCE_OGN &amp;&amp; msgtime.Before(ti.Timestamp) </span><span class="cov0" title="0">{
                                return // We already have a newer message for this target. This message was probably relayed by another tracker -- skip
                        }</span>
                }

        }

        // Sometimes there seems to be wildly invalid lat/lons, which can trip over distRect's normailization..
        <span class="cov0" title="0">if msg.Lat_deg &gt; 360 || msg.Lat_deg &lt; -360 || msg.Lon_deg &gt; 360 || msg.Lon_deg &lt; -360 </span><span class="cov0" title="0">{
                return
        }</span>

        // Basic plausibility check:
        <span class="cov0" title="0">dist, _, _, _ := common.DistRect(float64(mySituation.GPSLatitude), float64(mySituation.GPSLongitude), float64(msg.Lat_deg), float64(msg.Lon_deg))
        if (isGPSValid() &amp;&amp; dist &gt;= 50000) || (msg.Lat_deg == 0 &amp;&amp; msg.Lon_deg == 0) </span><span class="cov0" title="0">{
                // more than 50km away? Ignore. Most likely invalid data
                return
        }</span>

        <span class="cov0" title="0">ti.Icao_addr = address
        ti.Addr_type = addrType

        if len(ti.Tail) == 0 </span><span class="cov0" title="0">{
                ti.Tail = getTailNumber(msg.Addr, msg.Sys)
        }</span>
        <span class="cov0" title="0">ti.Last_source = TRAFFIC_SOURCE_OGN
        if msg.Time &gt; 0 </span><span class="cov0" title="0">{
                if msg.Time &lt; float64(ti.Timestamp.Unix()) </span><span class="cov0" title="0">{
                        //log.Printf("Discarding traffic message from %d as it is %fs too old", ti.Icao_addr, ti.Timestamp.Unix() - msg.Time)
                        return
                }</span>
                <span class="cov0" title="0">ti.Timestamp = time.Unix(int64(msg.Time), 0)</span>
        } else<span class="cov0" title="0"> {
                ti.Timestamp = time.Now().UTC()
        }</span>
        <span class="cov0" title="0">ti.Age = time.Now().UTC().Sub(ti.Timestamp).Seconds()
        if ti.Age &gt; 30 || ti.Age &lt; -2 </span><span class="cov0" title="0">{
                log.Printf("Discarding likely invalid OGN target: %s", data)
                return
        }</span>

        // set altitude
        // To keep the rest of the system as simple as possible, we want to work with barometric altitude everywhere.
        // To do so, we use our own known geoid separation and pressure difference to compute the expected barometric altitude of the traffic.
        // Some OGN trackers are equiped with a baro sensor, but older firmwares send wrong data, so we usually can't rely on it.
        <span class="cov0" title="0">alt := msg.Alt_msl_m * 3.28084
        if alt == 0 </span><span class="cov0" title="0">{
                alt = msg.Alt_hae_m*3.28084 - mySituation.GPSGeoidSep
        }</span>
        <span class="cov0" title="0">if isGPSValid() &amp;&amp; isTempPressValid() </span><span class="cov0" title="0">{
                ti.Alt = int32(alt - mySituation.GPSAltitudeMSL + mySituation.BaroPressureAltitude)
                ti.AltIsGNSS = false
        }</span> else<span class="cov0" title="0"> if msg.Alt_std_m != 0 </span><span class="cov0" title="0">{
                // Fall back to received baro alt
                ti.Alt = int32(msg.Alt_std_m * 3.28084)
                ti.AltIsGNSS = false
        }</span> else<span class="cov0" title="0"> {
                // Fall back to GNSS alt
                ti.Alt = int32(alt)
                ti.AltIsGNSS = true
        }</span>

        // Maybe the sender has baro AND GNS altitude.. in that case we can use that to estimage GnssBaroDiff to guess our own baro altitude
        // TODO: don't do that because of invalid baro alts from old OGN trackers.
        /*if msg.Alt_msl_m != 0 &amp;&amp; msg.Alt_std_m != 0 {
                ti.Last_GnssDiffAlt = ti.Alt
                hae := msg.Alt_msl_m + mySituation.GPSGeoidSep
                ti.GnssDiffFromBaroAlt = int32((hae - msg.Alt_std_m) * 3.28084)
                ti.Last_GnssDiff = stratuxClock.Time
        } else if msg.Alt_hae_m != 0 &amp;&amp; msg.Alt_std_m != 0 {
                ti.Last_GnssDiffAlt = ti.Alt
                ti.GnssDiffFromBaroAlt = int32((msg.Alt_hae_m - msg.Alt_std_m) * 3.28084)
                ti.Last_GnssDiff = stratuxClock.Time
        }*/

        <span class="cov0" title="0">ti.TurnRate = float32(msg.Turn_dps)
        if ti.TurnRate &gt; 360 || ti.TurnRate &lt; -360 </span><span class="cov0" title="0">{
                ti.TurnRate = 0
        }</span>
        <span class="cov0" title="0">ti.Vvel = int16(msg.Climb_mps * 196.85)
        ti.Lat = msg.Lat_deg
        ti.Lng = msg.Lon_deg
        ti.Track = float32(msg.Track_deg)
        ti.Speed = uint16(msg.Speed_mps * 1.94384)
        ti.Speed_valid = true
        ti.SignalLevel = msg.SNR_dB

        if isGPSValid() </span><span class="cov0" title="0">{
                ti.Distance, ti.Bearing = common.Distance(float64(mySituation.GPSLatitude), float64(mySituation.GPSLongitude), float64(ti.Lat), float64(ti.Lng))
                ti.BearingDist_valid = true
        }</span>
        <span class="cov0" title="0">ti.Position_valid = true
        ti.ExtrapolatedPosition = false
        ti.Last_seen = stratuxClock.Time
        ageMs := int64(ti.Age * 1000)
        ti.Last_seen = ti.Last_seen.Add(-time.Duration(ageMs) * time.Millisecond)
        ti.Last_alt = ti.Last_seen
        ti.Last_speed = ti.Last_seen

        emitter, err := strconv.ParseInt(msg.Acft_cat, 16, 8)
        if len(msg.Acft_cat) == 2 &amp;&amp; err == nil </span><span class="cov0" title="0">{
                ti.Emitter_category = uint8(emitter)
        }</span> else<span class="cov0" title="0"> {
                ti.Emitter_category = nmeaAircraftTypeToGdl90(msg.Acft_type)
        }</span>

        <span class="cov0" title="0">traffic[key] = ti
        postProcessTraffic(&amp;ti)
        registerTrafficUpdate(ti)
        seenTraffic[key] = true

        if globalSettings.DEBUG </span><span class="cov0" title="0">{
                txt, _ := json.Marshal(ti)
                log.Printf("OGN traffic imported: " + string(txt))
        }</span>
}

var ognTailNumberCache = make(map[string]string)

func lookupOgnTailNumber(ognid string) string <span class="cov0" title="0">{
        if len(ognTailNumberCache) == 0 </span><span class="cov0" title="0">{
                log.Printf("Parsing OGN device db")
                ddb, err := ioutil.ReadFile(STRATUX_HOME + "/ogn/ddb.json")
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to read OGN device db")
                        return ognid
                }</span>
                <span class="cov0" title="0">var data map[string]interface{}
                err = json.Unmarshal(ddb, &amp;data)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to parse OGN device db")
                        return ognid
                }</span>
                <span class="cov0" title="0">devlist := data["devices"].([]interface{})
                for i := 0; i &lt; len(devlist); i++ </span><span class="cov0" title="0">{
                        dev := devlist[i].(map[string]interface{})
                        ognid := dev["device_id"].(string)
                        tail := dev["registration"].(string)
                        ognTailNumberCache[ognid] = tail
                }</span>
                <span class="cov0" title="0">log.Printf("Successfully parsed OGN device db")</span>
        }
        <span class="cov0" title="0">if tail, ok := ognTailNumberCache[ognid]; ok </span><span class="cov0" title="0">{
                return tail
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func getTailNumber(ognid string, sys string) string <span class="cov0" title="0">{
        tail := lookupOgnTailNumber(ognid)
        if globalSettings.DisplayTrafficSource </span><span class="cov0" title="0">{
                if sys == "" </span><span class="cov0" title="0">{
                        sys = "un"
                }</span>
                <span class="cov0" title="0">sys = strings.ToLower(sys)[0:2]
                tail = sys + tail</span>
        }
        <span class="cov0" title="0">return tail</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
        Copyright (c) 2016 uAvionix
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        ping.go: uAvionix Ping ADS-B monitoring and management.
    2023 Added PingUSB MavLink support device 0403:6015
*/

package main

import (
        "bufio"
        //"fmt"
        "log"
        "os"
        "strings"
        "sync"

        //"sync/atomic"
        "net"
        "os/exec"
        "time"

        // Using forked version of tarm/serial to force Linux
        // instead of posix code, allowing for higher baud rates

        "github.com/stratux/stratux/common"
        "github.com/uavionix/serial"
)

// Ping device data
var pingSerialConfig *serial.Config
var pingSerialPort *serial.Port
var pingWG *sync.WaitGroup
var closeCh chan int

// 0 =&gt; pingEFB - 1090ES
// 1 =&gt; pingUSB - MavLink
var pingDeviceModel int
var pingDeviceSuccessfullyWorking bool

func initPingSerial() bool <span class="cov0" title="0">{
        var device string
        baudrate := int(2000000)

        pingDeviceModel = 0
        log.Printf("Configuring Ping ADS-B\n")

        if _, err := os.Stat("/dev/ping"); err == nil </span><span class="cov0" title="0">{
                device = "/dev/ping"
        }</span> else<span class="cov0" title="0"> if _, err := os.Stat("/dev/softrf"); err == nil </span><span class="cov0" title="0">{
                device = "/dev/softrf"
                baudrate = int(38400)
        }</span> else<span class="cov0" title="0"> if _, err := os.Stat("/dev/pingusb"); err == nil </span><span class="cov0" title="0">{
                // 99-uavionix.rules 0403:6015
                device = "/dev/pingusb"
                baudrate = int(57600)
                pingDeviceModel = 1
        }</span> else<span class="cov0" title="0"> {
                log.Printf("No suitable Ping device found.\n")
                return false
        }</span>
        <span class="cov0" title="0">log.Printf("Using %s for Ping\n", device)

        // Open port
        // No timeout specified as Ping does not heartbeat
        pingSerialConfig = &amp;serial.Config{Name: device, Baud: baudrate}
        p, err := serial.OpenPort(pingSerialConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error opening serial port: %s\n", err.Error())
                return false
        }</span>
        <span class="cov0" title="0">log.Printf("Ping opened serial port")

        // No device configuration is needed, we should be ready

        pingSerialPort = p
        return true</span>
}

func pingNetworkRepeater() <span class="cov0" title="0">{
        defer pingWG.Done()
        log.Println("Entered Ping network repeater ...")
        cmd := exec.Command(STRATUX_HOME+"/bin/dump1090", "--net-only", "--net-stratux-port", "30006")
        stdout, _ := cmd.StdoutPipe()
        stderr, _ := cmd.StderrPipe()

        err := cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing "+STRATUX_HOME+"/bin/dump1090: %s\n", err)
                // don't return immediately, use the proper shutdown procedure
                shutdownPing = true
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-closeCh:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                time.Sleep(1 * time.Second)</span>
                        }
                }
        }

        <span class="cov0" title="0">log.Println("Executed " + cmd.String() + " successfully...")

        scanStdout := bufio.NewScanner(stdout)
        scanStderr := bufio.NewScanner(stderr)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-closeCh:<span class="cov0" title="0">
                        log.Println("Ping network repeater: shutdown msg received, calling cmd.Process.Kill() ...")
                        err := cmd.Process.Kill()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("\t couldn't kill dump1090: %s\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                cmd.Wait()
                                log.Println("\t kill successful...")
                        }</span>
                        <span class="cov0" title="0">return</span>
                default:<span class="cov0" title="0">
                        for scanStdout.Scan() </span><span class="cov0" title="0">{
                                m := Dump1090TermMessage{Text: scanStdout.Text(), Source: "stdout"}
                                logDump1090TermMessage(m)
                        }</span>
                        <span class="cov0" title="0">if err := scanStdout.Err(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("scanStdout error: %s\n", err)
                        }</span>

                        <span class="cov0" title="0">for scanStderr.Scan() </span><span class="cov0" title="0">{
                                m := Dump1090TermMessage{Text: scanStderr.Text(), Source: "stderr"}
                                logDump1090TermMessage(m)
                                if shutdownES != true </span><span class="cov0" title="0">{
                                        shutdownES = true
                                }</span>
                        }
                        <span class="cov0" title="0">if err := scanStderr.Err(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("scanStderr error: %s\n", err)
                        }</span>

                        <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
                }
        }
}

var dump1090Connection net.Conn = nil
var connectionError error

func pingNetworkConnection() <span class="cov0" title="0">{
        // Send to dump1090 on port 30001
        dump1090Addr := "127.0.0.1:30001"
        dump1090Connection, connectionError = net.Dial("tcp", dump1090Addr)
        // RCB monitor for connection failure and redial
}</span>

func pingSerialReader() <span class="cov0" title="0">{
        //defer pingWG.Done()
        defer pingSerialPort.Close()
        // RCB TODO channel control for terminate

        log.Printf("Starting Ping serial reader")

        scanner := bufio.NewScanner(pingSerialPort)
        for scanner.Scan() &amp;&amp; globalStatus.Ping_connected &amp;&amp; globalSettings.Ping_Enabled </span><span class="cov0" title="0">{
                pingDeviceSuccessfullyWorking = true
                s := scanner.Text()
                // Trimspace removes newlines as well as whitespace
                s = strings.TrimSpace(s)
                //logString := fmt.Sprintf("Ping received: %s", s)
                //log.Println(logString)
                if s[0] == '*' </span><span class="cov0" title="0">{
                        // 1090ES report
                        // Ping appends a signal strength at the end of the message
                        // e.g. *8DC01C2860C37797E9732E555B23;ss=049D;
                        // Remove this before forwarding to dump1090
                        // We currently aren't doing anything with this information
                        // and need to develop a scaling equation - we're using a
                        // log detector for power so it should have a logarithmic
                        // relationship. In one example, at -25dBm input (upper limit
                        // of RX) we saw ~0x500. At -95dBm input (lower limit of RX)
                        // we saw 0x370
                        report := strings.Split(s, ";")
                        //replayLog(s, MSGCLASS_DUMP1090);
                        if dump1090Connection == nil </span><span class="cov0" title="0">{
                                log.Println("Starting dump1090 network connection")
                                pingNetworkConnection()
                        }</span>
                        <span class="cov0" title="0">if len(report[0]) != 0 &amp;&amp; dump1090Connection != nil </span><span class="cov0" title="0">{
                                globalStatus.ES_messages_total++
                                dump1090Connection.Write([]byte(report[0] + ";\r\n"))
                                //log.Println("Relaying 1090ES message")
                                //logString := fmt.Sprintf("Relaying 1090ES: %s;", report[0]);
                                //log.Println(logString)
                        }</span>
                } else<span class="cov0" title="0"> if s[0] == '+' || s[0] == '-' </span><span class="cov0" title="0">{
                        // UAT report
                        // Ping appends a signal strength and RS bit errors corrected
                        // at the end of the message
                        // e.g. -08A5DFDF3907E982585F029B00040080105C3AB4BC5C240700A206000000000000003A13C82F96C80A63191F05FCB231;rs=1;ss=A2;
                        // We need to rescale the signal strength for interpretation by dump978,
                        // which expects a 0-1000 base 10 (linear?) scale
                        // RSSI is in hex and represents an int8 with -128 (0x80) representing an
                        // errored measurement. There will be some offset from actual due to loss
                        // in the path. In one example we measured 0x93 (-98) when injecting a
                        // -102dBm signal
                        o, msgtype := parseInput(s)
                        if o != nil &amp;&amp; msgtype != 0 </span><span class="cov0" title="0">{
                                //logString = fmt.Sprintf("Relaying message, type=%d", msgtype)
                                //log.Println(logString)
                                relayMessage(msgtype, o)
                        }</span> else<span class="cov0" title="0"> if o == nil </span>{<span class="cov0" title="0">
                                //log.Println("Not relaying message, o == nil")
                        }</span> else <span class="cov0" title="0">{
                                //log.Println("Not relaying message, msgtype == 0")
                        }</span>
                }
        }
        <span class="cov0" title="0">globalStatus.Ping_connected = false
        log.Printf("Exiting Ping serial reader")
        return</span>
}

func pingShutdown() <span class="cov0" title="0">{
        log.Println("Entered Ping shutdown() ...")
        //close(closeCh)
        //log.Println("Ping shutdown(): calling pingWG.Wait() ...")
        //pingWG.Wait() // Wait for the goroutine to shutdown
        //log.Println("Ping shutdown(): pingWG.Wait() returned...")
        // Serial Port Gracefully Close and Read() returns
        //globalStatus.Ping_connected = false
        if globalStatus.Ping_connected == true </span><span class="cov0" title="0">{
                pingSerialPort.Close()
        }</span>
}

func pingKill() <span class="cov0" title="0">{
        // Send signal to shutdown to pingWatcher().
        shutdownPing = true
        // Spin until device has been de-initialized.
        for globalStatus.Ping_connected != false </span><span class="cov0" title="0">{
                time.Sleep(1 * time.Second)
        }</span>
}

// to keep our sync primitives synchronized, only exit a read
// method's goroutine via the close flag channel check, to
// include catastrophic dongle failures
var shutdownPing bool

// Watch for config/device changes.
func pingWatcher() <span class="cov0" title="0">{
        prevPingEnabled := false
        pingDeviceSuccessfullyWorking = false

        for </span><span class="cov0" title="0">{
                time.Sleep(1 * time.Second)

                // true when a serial call fails
                if shutdownPing </span><span class="cov0" title="0">{
                        pingShutdown()
                        shutdownPing = false
                        // Shutdown this reconnection loop
                        break</span>
                }
                // Autoreconnect the device
                <span class="cov0" title="0">if pingDeviceSuccessfullyWorking == true &amp;&amp; globalSettings.Ping_Enabled &amp;&amp; !globalStatus.Ping_connected </span><span class="cov0" title="0">{
                        prevPingEnabled = false
                }</span>

                <span class="cov0" title="0">if prevPingEnabled == globalSettings.Ping_Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Global settings have changed, reconfig
                <span class="cov0" title="0">if globalSettings.Ping_Enabled &amp;&amp; !globalStatus.Ping_connected </span><span class="cov0" title="0">{
                        globalStatus.Ping_connected = initPingSerial()
                        // This will retry next loop to connect again to the device
                        if globalStatus.Ping_connected == false </span><span class="cov0" title="0">{
                                // Relaxed polling to wait the device to be discovered
                                time.Sleep(10 * time.Second)
                                continue</span>
                        }
                        //count := 0
                        // pingEFB - 1090
                        <span class="cov0" title="0">if globalStatus.Ping_connected &amp;&amp; pingDeviceModel == 0 </span><span class="cov0" title="0">{
                                //pingWG.Add(1)
                                go pingNetworkRepeater()
                                //pingNetworkConnection()
                                go pingSerialReader()
                                // Emulate SDR count
                                //count = 2
                        }</span>
                        // pingUSB - MavLink
                        <span class="cov0" title="0">if globalStatus.Ping_connected &amp;&amp; pingDeviceModel == 1 </span><span class="cov0" title="0">{
                                go pingUSBSerialReader()
                        }</span>
                        //atomic.StoreUint32(&amp;globalStatus.Devices, uint32(count))
                } else<span class="cov0" title="0"> if !globalSettings.Ping_Enabled </span><span class="cov0" title="0">{
                        pingShutdown()
                }</span>

                <span class="cov0" title="0">prevPingEnabled = globalSettings.Ping_Enabled</span>
        }
}

func pingInit() <span class="cov0" title="0">{
        go pingWatcher()
}</span>

type MavlinkTrafficMessageFormat struct {
        ICAO_address  uint32
        lat           int32
        lon           int32
        altitude      int32
        heading       uint16
        hor_velocity  uint16
        ver_velocity  int16
        validFlags    uint16
        squawk        uint16
        altitude_type uint8
        callsign      [9]byte
        emitter_type  uint8
        tslc          uint8
}

func mavLinkFormat(x []byte) <span class="cov0" title="0">{
        msglenMavLink := x[1]
        msgtypeMavLink := x[5]
        if msgtypeMavLink == 246 &amp;&amp; msglenMavLink &gt;= 38 </span><span class="cov0" title="0">{
                mavLink := MavlinkTrafficMessageFormat{}
                pingUsbHeaderLen := 6
                pingUsbHeaderCursor := 0
                mavLink.ICAO_address = uint32(x[3+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;24 | uint32(x[2+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;16 | uint32(x[1+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;8 | uint32(x[0+pingUsbHeaderLen+pingUsbHeaderCursor])
                pingUsbHeaderCursor = 4
                mavLink.lat = int32(uint32(x[3+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;24 | uint32(x[2+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;16 | uint32(x[1+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;8 | uint32(x[0+pingUsbHeaderLen+pingUsbHeaderCursor]))
                pingUsbHeaderCursor = 8
                mavLink.lon = int32(uint32(x[3+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;24 | uint32(x[2+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;16 | uint32(x[1+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;8 | uint32(x[0+pingUsbHeaderLen+pingUsbHeaderCursor]))
                pingUsbHeaderCursor = 12
                mavLink.altitude = int32(uint32(x[3+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;24 | uint32(x[2+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;16 | uint32(x[1+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;8 | uint32(x[0+pingUsbHeaderLen+pingUsbHeaderCursor]))
                pingUsbHeaderCursor = 16
                mavLink.heading = (uint16(x[1+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;8 | uint16(x[0+pingUsbHeaderLen+pingUsbHeaderCursor]))
                pingUsbHeaderCursor = 18
                mavLink.hor_velocity = (uint16(x[1+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;8 | uint16(x[0+pingUsbHeaderLen+pingUsbHeaderCursor]))
                pingUsbHeaderCursor = 20
                mavLink.ver_velocity = int16(uint16(x[1+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;8 | uint16(x[0+pingUsbHeaderLen+pingUsbHeaderCursor]))
                pingUsbHeaderCursor = 22
                mavLink.validFlags = (uint16(x[1+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;8 | uint16(x[0+pingUsbHeaderLen+pingUsbHeaderCursor]))
                pingUsbHeaderCursor = 24
                mavLink.squawk = (uint16(x[1+pingUsbHeaderLen+pingUsbHeaderCursor])&lt;&lt;8 | uint16(x[0+pingUsbHeaderLen+pingUsbHeaderCursor]))
                pingUsbHeaderCursor = 26
                mavLink.altitude_type = x[0+pingUsbHeaderLen+pingUsbHeaderCursor]
                pingUsbHeaderCursor = 27

                for j := 0; j &lt; 9; j++ </span><span class="cov0" title="0">{
                        mavLink.callsign[j] = 0
                }</span>
                <span class="cov0" title="0">for a, b := range x[0+pingUsbHeaderLen+pingUsbHeaderCursor:] </span><span class="cov0" title="0">{
                        if a &gt; 8 || b == ' ' </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">mavLink.callsign[a] = b</span>
                }
                <span class="cov0" title="0">pingUsbHeaderCursor = 36
                mavLink.emitter_type = x[0+pingUsbHeaderLen+pingUsbHeaderCursor]
                pingUsbHeaderCursor = 37
                mavLink.tslc = x[0+pingUsbHeaderLen+pingUsbHeaderCursor]
                if globalSettings.DEBUG </span><span class="cov0" title="0">{
                        log.Printf("ICAO_address %06X lat: %d lon: %d alt: %d head: %d call: %s vspeed: %d speed: %d", mavLink.ICAO_address, mavLink.lat, mavLink.lon, mavLink.altitude, mavLink.heading, mavLink.callsign, mavLink.ver_velocity, mavLink.hor_velocity)
                }</span>
                <span class="cov0" title="0">var ti TrafficInfo
                trafficMutex.Lock()
                signalLevelSimulated := -1
                if val, ok := traffic[mavLink.ICAO_address]; ok </span><span class="cov0" title="0">{ // if we've already seen it, copy it in to do updates as it may contain some useful information like "tail" from 1090ES.
                        ti = val
                }</span> else<span class="cov0" title="0"> {
                        // New
                        ti.Last_seen = stratuxClock.Time
                }</span>
                <span class="cov0" title="0">if mavLink.heading != 0 </span><span class="cov0" title="0">{
                        ti.Track = float32(mavLink.heading / 100)
                }</span> else<span class="cov0" title="0"> {
                        signalLevelSimulated -= 5
                }</span>
                <span class="cov0" title="0">ti.ReceivedMsgs += 1
                ti.Icao_addr = mavLink.ICAO_address
                ti.OnGround = false
                ti.Addr_type = 0
                if mavLink.squawk != 0 </span><span class="cov0" title="0">{
                        ti.Squawk = int(mavLink.squawk)
                }</span>
                <span class="cov0" title="0">ti.TargetType = TARGET_TYPE_ADSB
                if mavLink.emitter_type != 0 </span><span class="cov0" title="0">{
                        ti.Emitter_category = uint8(mavLink.emitter_type)
                }</span>
                <span class="cov0" title="0">if mavLink.lat != 0 &amp;&amp; mavLink.lon != 0 </span><span class="cov0" title="0">{
                        lat := float32(mavLink.lat) / 10000000.0
                        lng := float32(mavLink.lon) / 10000000.0
                        // Low signal may involve into a freeze location, update only if it really changes
                        if lng != ti.Lng &amp;&amp; lat != ti.Lat </span><span class="cov0" title="0">{
                                ti.Lat = lat
                                ti.Lng = lng
                                if isGPSValid() </span><span class="cov0" title="0">{
                                        lat := float64(mySituation.GPSLatitude)
                                        lng := float64(mySituation.GPSLongitude)
                                        ti.Distance, ti.Bearing = common.Distance(float64(lat), float64(lng), float64(ti.Lat), float64(ti.Lng))
                                        ti.BearingDist_valid = true
                                }</span> else<span class="cov0" title="0"> {
                                        ti.BearingDist_valid = false
                                }</span>
                                <span class="cov0" title="0">ti.Position_valid = true
                                ti.ExtrapolatedPosition = false
                                ti.Last_seen = stratuxClock.Time
                                ti.Timestamp = time.Now().UTC()</span>
                        }
                } else<span class="cov0" title="0"> {
                        ti.Position_valid = false
                        signalLevelSimulated -= 5
                }</span>
                <span class="cov0" title="0">altitudeFoot := int32(float32(mavLink.altitude) / 304.8)
                if altitudeFoot &gt; 0 &amp;&amp; altitudeFoot &lt; 70000 </span><span class="cov0" title="0">{
                        // Low signal may involve into a freeze location, update only if it really changes
                        if ti.Alt != altitudeFoot </span><span class="cov0" title="0">{
                                ti.Alt = altitudeFoot
                                ti.Last_alt = stratuxClock.Time
                                ti.Last_seen = stratuxClock.Time
                                ti.Timestamp = time.Now().UTC()
                        }</span>
                } else<span class="cov0" title="0"> {
                        signalLevelSimulated -= 5
                }</span>
                <span class="cov0" title="0">if mavLink.altitude_type &gt; 0 </span><span class="cov0" title="0">{
                        ti.AltIsGNSS = true
                }</span>
                <span class="cov0" title="0">if mavLink.hor_velocity &gt; 0 </span><span class="cov0" title="0">{
                        ti.Speed = uint16(float32(mavLink.hor_velocity) * 36 / 1852)
                        ti.Speed_valid = true
                        ti.Last_speed = stratuxClock.Time
                }</span> else<span class="cov0" title="0"> {
                        ti.Speed_valid = false
                        signalLevelSimulated -= 5
                }</span>
                <span class="cov0" title="0">ti.Vvel = int16(float32(mavLink.ver_velocity) * 60.0 / 10.0 / 3.048)
                var callsignLen = 0
                for a, b := range mavLink.callsign </span><span class="cov0" title="0">{
                        if b == ' ' || b == '\u0000' </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">callsignLen = a + 1</span>
                }
                <span class="cov0" title="0">thisReg, validReg := icao2reg(ti.Icao_addr)
                if validReg </span><span class="cov0" title="0">{
                        ti.Reg = thisReg
                }</span>
                <span class="cov0" title="0">if callsignLen &gt; 0 </span><span class="cov0" title="0">{
                        ti.Tail = string(mavLink.callsign[:callsignLen])
                }</span> else<span class="cov0" title="0"> {
                        signalLevelSimulated -= 5
                        if validReg </span><span class="cov0" title="0">{
                                ti.Tail = thisReg
                        }</span>
                }
                // Timestamp and Last_seen are updated only if Location or Altitude changes
                <span class="cov0" title="0">ti.NACp = 8
                ti.NIC = 8
                ti.Last_source = TRAFFIC_SOURCE_1090ES
                ti.SignalLevel = float64(signalLevelSimulated)
                postProcessTraffic(&amp;ti)
                traffic[ti.Icao_addr] = ti
                registerTrafficUpdate(ti)
                seenTraffic[ti.Icao_addr] = true
                trafficMutex.Unlock()</span>
        }
}

func mavLinkParse(mavLinkFrame []byte) bool <span class="cov0" title="0">{
        if mavLinkFrame[0] != 0xfe || len(mavLinkFrame) &gt; 1024 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if len(mavLinkFrame) &lt; 9 || mavLinkFrame[0] != 0xfe || int(mavLinkFrame[1]+8) != len(mavLinkFrame) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">mavLinkFormat(mavLinkFrame)
        pingDeviceSuccessfullyWorking = true
        return true</span>
}

func pingUSBSerialReader() <span class="cov0" title="0">{
        defer pingSerialPort.Close()
        // RCB TODO channel control for terminate
        log.Printf("Starting PingUSB serial reader")
        data := make([]byte, 4096)
        mavLinkFrame := make([]byte, 4096)
        mavLinkFrameLastIndex := 0
        for globalStatus.Ping_connected &amp;&amp; globalSettings.Ping_Enabled </span><span class="cov0" title="0">{
                n, err := pingSerialPort.Read(data)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">for _, b := range data[:n] </span><span class="cov0" title="0">{
                        if b == 0xfe &amp;&amp; mavLinkFrameLastIndex &gt; 0 </span><span class="cov0" title="0">{
                                if mavLinkFrameLastIndex &gt; 0 </span><span class="cov0" title="0">{
                                        if mavLinkParse(mavLinkFrame[:mavLinkFrameLastIndex]) </span><span class="cov0" title="0">{
                                                mavLinkFrameLastIndex = 0
                                        }</span>
                                        <span class="cov0" title="0">mavLinkFrame[mavLinkFrameLastIndex] = b
                                        mavLinkFrameLastIndex += 1</span>
                                }
                        } else<span class="cov0" title="0"> {
                                mavLinkFrame[mavLinkFrameLastIndex] = b
                                mavLinkFrameLastIndex += 1
                        }</span>
                }
                <span class="cov0" title="0">continue</span>
        }
        <span class="cov0" title="0">globalStatus.Ping_connected = false
        log.Printf("Exiting PingUSB serial reader")
        return</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
        pong.go: uAvionix Pong ADS-B monitoring and management.
        Added 1/2026
*/

package main

import (
        "bufio"
        "fmt"
        "log"
        "os"
        "strings"
        "sync"

        //"sync/atomic"
        "net"
        "os/exec"
        "time"

        // Using forked version of tarm/serial to force Linux
        // instead of posix code, allowing for higher baud rates
        "github.com/stratux/serial"
)

// pong device data
var pongSerialConfig *serial.Config
var pongSerialPort *serial.Port
var pongWG *sync.WaitGroup
var closeChpong chan int
var pongUpdateMode bool
var pongDeviceSuccessfullyWorking bool

type PongTermMessage struct {
        Text   string
        Source string
}

func initPongSerial() bool <span class="cov0" title="0">{
        var device string
        baudrate := int(3000000)

        log.Printf("Configuring Pong ADS-B\n")

        if _, err := os.Stat("/dev/pong"); err == nil </span><span class="cov0" title="0">{
                device = "/dev/pong"
        }</span> else<span class="cov0" title="0"> {
                log.Printf("No suitable Pong device found.\n")
                return false
        }</span>
        <span class="cov0" title="0">log.Printf("Using %s for Pong\n", device)

        // Open port
        // No timeout specified as Pong does not heartbeat
        pongSerialConfig = &amp;serial.Config{Name: device, Baud: baudrate}
        p, err := serial.OpenPort(pongSerialConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error opening serial port: %s\n", err.Error())
                return false
        }</span>
        <span class="cov0" title="0">errRts := p.ClearRTS()
        if errRts != nil </span><span class="cov0" title="0">{
                log.Printf("Clearing RTS returned %s\n", errRts.Error())
        }</span>

        <span class="cov0" title="0">log.Printf("Pong opened serial port at %d baud\n", baudrate)

        // No device configuration is needed, we should be ready
        globalStatus.Pong_Heartbeats = 0

        pongSerialPort = p
        return true</span>
}

func pongNetworkRepeater() <span class="cov0" title="0">{
        defer pongWG.Done()
        log.Println("Entered Pong network repeater ...")
        cmd := exec.Command(STRATUX_HOME+"/bin/dump1090", "--net-only", "--net-stratux-port", "30006")
        stdout, _ := cmd.StdoutPipe()
        stderr, _ := cmd.StderrPipe()

        err := cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing "+STRATUX_HOME+"/bin/dump1090: %s\n", err)
                // don't return immediately, use the proper shutdown procedure
                shutdownPong = true
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-closeChpong:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                time.Sleep(1 * time.Second)</span>
                        }
                }
        }

        <span class="cov0" title="0">log.Println("Executed " + cmd.String() + " successfully...")

        scanStdout := bufio.NewScanner(stdout)
        scanStderr := bufio.NewScanner(stderr)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-closeChpong:<span class="cov0" title="0">
                        log.Println("Pong network repeater: shutdown msg received, calling cmd.Process.Kill() ...")
                        err := cmd.Process.Kill()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("\t couldn't kill dump1090: %s\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                cmd.Wait()
                                log.Println("\t kill successful...")
                        }</span>
                        <span class="cov0" title="0">return</span>
                default:<span class="cov0" title="0">
                        for scanStdout.Scan() </span><span class="cov0" title="0">{
                                m := Dump1090TermMessage{Text: scanStdout.Text(), Source: "stdout"}
                                logDump1090TermMessage(m)
                        }</span>
                        <span class="cov0" title="0">if err := scanStdout.Err(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("scanStdout error: %s\n", err)
                        }</span>

                        <span class="cov0" title="0">for scanStderr.Scan() </span><span class="cov0" title="0">{
                                m := Dump1090TermMessage{Text: scanStderr.Text(), Source: "stderr"}
                                logDump1090TermMessage(m)
                        }</span>
                        <span class="cov0" title="0">if err := scanStderr.Err(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("scanStderr error: %s\n", err)
                        }</span>
                        <span class="cov0" title="0">for scanStderr.Scan() </span><span class="cov0" title="0">{
                                m := Dump1090TermMessage{Text: scanStderr.Text(), Source: "stderr"}
                                logDump1090TermMessage(m)
                                if shutdownES != true </span><span class="cov0" title="0">{
                                        shutdownES = true
                                }</span>
                        }
                        <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
                }
        }
}

var dump1090ConnectionPong net.Conn = nil
var connectionErrorPong error

func pongNetworkConnection() <span class="cov0" title="0">{
        // Send to dump1090 on port 30001
        dump1090Addr := "127.0.0.1:30001"
        dump1090ConnectionPong, connectionErrorPong = net.Dial("tcp", dump1090Addr)
        // RCB monitor for connection failure and redial
}</span>

func pongSerialReader() <span class="cov0" title="0">{
        //defer pongWG.Done()
        defer pongSerialPort.Close()
        // RCB TODO channel control for terminate

        log.Printf("Starting Pong serial reader")

        scanner := bufio.NewScanner(pongSerialPort)
        for scanner.Scan() &amp;&amp; globalStatus.Pong_connected &amp;&amp; globalSettings.Pong_Enabled </span><span class="cov0" title="0">{
                pongDeviceSuccessfullyWorking = true
                s := scanner.Text()
                // Trimspace removes newlines as well as whitespace
                s = strings.TrimSpace(s)
                if s[0] == '\'' </span><span class="cov0" title="0">{
                        report := strings.Split(s, "'")
                        logString := fmt.Sprintf("Pong ASCII: %s", report[1])
                        log.Println(logString)
                }</span> else<span class="cov0" title="0"> if s[0] == '.' </span><span class="cov0" title="0">{
                        //log.Println("Pong heartbeat\n")
                        globalStatus.Pong_Heartbeats++
                }</span> else<span class="cov0" title="0"> if s[0] == '*' </span><span class="cov0" title="0">{
                        // 1090ES report
                        // Pong appends a signal strength at the end of the message
                        // e.g. *8DC01C2860C37797E9732E555B23;ss=049D;
                        // Remove this before forwarding to dump1090
                        // We currently aren't doing anything with this information
                        // and need to develop a scaling equation - we're using a
                        // log detector for power so it should have a logarithmic
                        // relationship. In one example, at -25dBm input (upper limit
                        // of RX) we saw ~0x500. At -95dBm input (lower limit of RX)
                        // we saw 0x370
                        report := strings.Split(s, ";")
                        //replayLog(s, MSGCLASS_DUMP1090);
                        if dump1090ConnectionPong == nil </span><span class="cov0" title="0">{
                                log.Println("Starting dump1090 network connection")
                                pongNetworkConnection()
                        }</span>
                        <span class="cov0" title="0">if len(report[0]) != 0 &amp;&amp; dump1090ConnectionPong != nil </span><span class="cov0" title="0">{
                                globalStatus.ES_messages_total++
                                dump1090ConnectionPong.Write([]byte(report[0] + ";\r\n"))
                                //logString := fmt.Sprintf("Relaying 1090ES: %s;", report[0])
                                //log.Println(logString)
                        }</span>
                } else<span class="cov0" title="0"> if s[0] == '+' || s[0] == '-' </span><span class="cov0" title="0">{
                        // UAT report
                        // Pong appends a signal strength and RS bit errors corrected
                        // at the end of the message
                        // e.g. -08A5DFDF3907E982585F029B00040080105C3AB4BC5C240700A206000000000000003A13C82F96C80A63191F05FCB231;rs=1;ss=A2;
                        // We need to rescale the signal strength for interpretation by dump978,
                        // which expects a 0-1000 base 10 (linear?) scale
                        // RSSI is in hex and represents an int8 with -128 (0x80) representing an
                        // errored measurement. There will be some offset from actual due to loss
                        // in the path. In one example we measured 0x93 (-98) when injecting a
                        // -102dBm signal
                        o, msgtype := parseInput(s)
                        if o != nil &amp;&amp; msgtype != 0 </span><span class="cov0" title="0">{
                                logString := fmt.Sprintf("Relaying UAT, type=%d: %s", msgtype, s)
                                log.Println(logString)
                                relayMessage(msgtype, o)
                        }</span> else<span class="cov0" title="0"> if o == nil </span><span class="cov0" title="0">{
                                log.Println("Not relaying message, o == nil")
                        }</span> else<span class="cov0" title="0"> {
                                log.Println("Not relaying message, msgtype == 0")
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Printf("Pong ASCII: %s", s)
                        if strings.Contains(s, "ERROR SPI") </span><span class="cov0" title="0">{
                                log.Printf("SPI error sent from Pong. Restarting Pong")
                        }</span>
                }
        }
        <span class="cov0" title="0">globalStatus.Pong_connected = false
        log.Printf("Exiting Pong serial reader")
        return</span>
}

func pongShutdown() <span class="cov0" title="0">{
        log.Println("Entered Pong shutdown() ...")
        if globalStatus.Pong_connected == true </span><span class="cov0" title="0">{
                pongSerialPort.Close()
        }</span>
}

func pongSetUpdateMode() <span class="cov0" title="0">{
        pongUpdateMode = true
}</span>

func pongRunUpdateWithOutput() error <span class="cov0" title="0">{
        /*
                out, err2 := exec.Command("/bin/bash","-c", "\"/tmp/updpong/util/updatepong.sh\"").Output()
                if err2 != nil {
                        return err2
                } else {
                        log.Printf("Update ran ok:\n%s\n",out)
                }
                return nil
        */
        cmd := exec.Command("/bin/bash", "-c", "\"/tmp/updpong/util/updatepong.sh\"")
        stdout, _ := cmd.StdoutPipe()
        //stderr, _ := cmd.StderrPipe()

        err := cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing updatepong.sh: %s\n", err)
                return err
        }</span>
        <span class="cov0" title="0">log.Println("Executed " + cmd.String() + " successfully...")

        scanStdout := bufio.NewScanner(stdout)
        for scanStdout.Scan() </span><span class="cov0" title="0">{
                m := PongTermMessage{Text: scanStdout.Text(), Source: "stdout"}
                logPongTermMessage(m)
                log.Printf("Pong Updater: %s\n", m.Text)
        }</span>

        <span class="cov0" title="0">if err := scanStdout.Err(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Pong Updater error: %s\n", err)
        }</span>

        <span class="cov0" title="0">if err := cmd.Wait(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Update pong completed with success\n")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func pongKill() <span class="cov0" title="0">{
        // Send signal to shutdown to pongWatcher().
        shutdownPong = true
        // Spin until device has been de-initialized.
        for globalStatus.Pong_connected != false </span><span class="cov0" title="0">{
                time.Sleep(1 * time.Second)
        }</span>
}

// to keep our sync primitives synchronized, only exit a read
// method's goroutine via the close flag channel check, to
// include catastrophic dongle failures
var shutdownPong bool

// Watch for config/device changes.
func pongWatcher() <span class="cov0" title="0">{
        pongDownCount := 0
        prevPongEnabled := false
        // Clear pong update mode
        pongUpdateMode = false
        pongDeviceSuccessfullyWorking = false
        for </span><span class="cov0" title="0">{
                time.Sleep(1 * time.Second)
                // true when a serial call fails
                if shutdownPong </span><span class="cov0" title="0">{
                        pongShutdown()
                        shutdownPong = false
                        // Shutdown this reconnection loop
                        break</span>
                }
                // Autoreconnect the device
                <span class="cov0" title="0">if pongDeviceSuccessfullyWorking == true &amp;&amp; globalSettings.Pong_Enabled &amp;&amp; !globalStatus.Pong_connected </span><span class="cov0" title="0">{
                        prevPongEnabled = false
                }</span>

                <span class="cov0" title="0">if pongUpdateMode </span><span class="cov0" title="0">{
                        log.Printf("PONG UPDATE MODE SET run the steps we need to update it here!")
                        // File should be in /tmp/update_pong.zip
                        pongUpdateMode = false
                        // Lets shut down the pong thread and run the update script
                        pongShutdown()
                        time.Sleep(5 * time.Second)
                        log.Printf("Run update process\n")
                        _, err := exec.Command("/usr/bin/unzip", "/tmp/update_pong.zip", "-d", "/tmp/updpong").Output()
                        if err == nil </span><span class="cov0" title="0">{
                                err2 := pongRunUpdateWithOutput()
                                if err2 != nil </span><span class="cov0" title="0">{
                                        log.Printf("Failed to run pongRunUpdateWithOutput(): %s\n", err2.Error())
                                }</span>
                        } else<span class="cov0" title="0"> {
                                log.Printf("Could not unpack the update file /tmp/update_pong.zip: %s\n", err.Error())
                        }</span>

                        <span class="cov0" title="0">time.Sleep(1 * time.Second)
                        log.Printf("update process complete - continue\n")</span>
                }
                // Keep a counter of how long its been down
                <span class="cov0" title="0">if prevPongEnabled == false &amp;&amp; globalSettings.Pong_Enabled == false </span><span class="cov0" title="0">{
                        pongDownCount++
                }</span> else<span class="cov0" title="0"> {
                        pongDownCount = 0
                }</span>
                // Autodetect Pong
                <span class="cov0" title="0">if !globalSettings.Pong_Enabled &amp;&amp; !prevPongEnabled &amp;&amp; pongDownCount &gt; 10 </span><span class="cov0" title="0">{
                        if _, err := os.Stat("/dev/pong"); err == nil </span><span class="cov0" title="0">{
                                log.Printf("Pong device file detected - Enabling the pong radio\n")
                                globalSettings.Pong_Enabled = true
                                saveSettings()
                        }</span>
                }

                <span class="cov0" title="0">if prevPongEnabled == globalSettings.Pong_Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Global settings have changed, reconfig
                <span class="cov0" title="0">if globalSettings.Pong_Enabled &amp;&amp; !globalStatus.Pong_connected </span><span class="cov0" title="0">{
                        globalStatus.Pong_connected = initPongSerial()
                        // This will retry next loop to connect again to the device
                        if globalStatus.Pong_connected == false </span><span class="cov0" title="0">{
                                // Relaxed polling to wait the device to be discovered
                                time.Sleep(10 * time.Second)
                                continue</span>
                        }
                        <span class="cov0" title="0">if globalStatus.Pong_connected </span><span class="cov0" title="0">{
                                go pongNetworkRepeater()
                                go pongSerialReader()
                        }</span>
                        //atomic.StoreUint32(&amp;globalStatus.Devices, uint32(count))
                } else<span class="cov0" title="0"> if !globalSettings.Pong_Enabled </span><span class="cov0" title="0">{
                        pongShutdown()
                }</span>
                <span class="cov0" title="0">prevPongEnabled = globalSettings.Pong_Enabled</span>
        }
}

func pongInit() <span class="cov0" title="0">{
        go pongWatcher()
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
        Copyright (c) 2015-2016 Christopher Young
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        sdr.go: SDR monitoring, SDR management, data input from UAT/1090ES channels.
*/

package main

import (
        "bufio"
        "log"
        "os/exec"
        "regexp"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "syscall"
        "time"

        rtl "github.com/jpoirier/gortlsdr"
        "github.com/stratux/stratux/godump978"
)

// Device holds per dongle values and attributes
type Device struct {
        dev     *rtl.Context
        wg      *sync.WaitGroup
        closeCh chan int
        indexID int
        ppm     int
        gain    float64
        serial  string
        idSet   bool
}

// UAT is a 978 MHz device
type UAT Device

// ES is a 1090 MHz device
type ES Device

// OGN is an 868 MHz device
type OGN Device

// AIS is an 161 MHz device
type AIS Device

// UATDev holds a 978 MHz dongle object
var UATDev *UAT

// ESDev holds a 1090 MHz dongle object
var ESDev *ES

// OGNDev holds an 868 MHz dongle object
var OGNDev *OGN

// AISDev holds a 162 MHz dongle object
var AISDev *AIS

type Dump1090TermMessage struct {
        Text   string
        Source string
}

type AISTermMessage struct {
        Text   string
        Source string
}

func (e *ES) read() <span class="cov0" title="0">{
        defer e.wg.Done()
        log.Println("Entered ES read() ...")
        // RTL SDR Standard Gains: 0.0 0.9 1.4 2.7 3.7 7.7 8.7 12.5 14.4 15.7 16.6 19.7 20.7 22.9 25.4 28.0 29.7 32.8 33.8 36.4 37.2 38.6 40.2 42.1 43.4 43.9 44.5 48.0 49.6
        if e.gain &lt; 0.9 </span><span class="cov0" title="0">{
                e.gain = 37.2
        }</span>
        <span class="cov0" title="0">cmd := exec.Command(STRATUX_HOME+"/bin/dump1090", "--fix", "--net-stratux-port", "30006", "--net", "--device-index", strconv.Itoa(e.indexID),
                "--ppm", strconv.Itoa(e.ppm),
                "--gain", strconv.FormatFloat(e.gain, 'f', -1, 32),
                "--mlat") // display raw messages in Beast ascii mode
        stdout, _ := cmd.StdoutPipe()
        stderr, _ := cmd.StderrPipe()

        err := cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing "+STRATUX_HOME+"/bin/dump1090: %s\n", err)
                // don't return immediately, use the proper shutdown procedure
                shutdownES = true
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-e.closeCh:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                time.Sleep(1 * time.Second)</span>
                        }
                }
        }

        <span class="cov0" title="0">log.Println("Executed " + cmd.String() + " successfully...")

        done := make(chan bool)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        case &lt;-e.closeCh:<span class="cov0" title="0">
                                log.Println("ES read(): shutdown msg received, calling cmd.Process.Kill() ...")
                                err := cmd.Process.Kill()
                                if err == nil </span><span class="cov0" title="0">{
                                        log.Println("kill successful...")
                                }</span>
                                <span class="cov0" title="0">return</span>
                        default:<span class="cov0" title="0">
                                time.Sleep(1 * time.Second)</span>
                        }
                }
        }()

        <span class="cov0" title="0">stdoutBuf := make([]byte, 1024)
        stderrBuf := make([]byte, 1024)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                n, err := stdout.Read(stdoutBuf)
                                if err == nil &amp;&amp; n &gt; 0 </span><span class="cov0" title="0">{
                                        m := Dump1090TermMessage{Text: string(stdoutBuf[:n]), Source: "stdout"}
                                        logDump1090TermMessage(m)
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                n, err := stderr.Read(stderrBuf)
                                if err == nil &amp;&amp; n &gt; 0 </span><span class="cov0" title="0">{
                                        m := Dump1090TermMessage{Text: string(stderrBuf[:n]), Source: "stderr"}
                                        logDump1090TermMessage(m)
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">cmd.Wait()

        // we get here if A) the dump1090 process died
        // on its own or B) cmd.Process.Kill() was called
        // from within the goroutine, either way close
        // the "done" channel, which ensures we don't leak
        // goroutines...
        close(done)</span>
}

func (u *UAT) read() <span class="cov0" title="0">{
        defer u.wg.Done()
        log.Println("Entered UAT read() ...")
        var buffer = make([]uint8, rtl.DefaultBufLength)

        for </span><span class="cov0" title="0">{
                select </span>{
                default:<span class="cov0" title="0">
                        nRead, err := u.dev.ReadSync(buffer, rtl.DefaultBufLength)
                        if err != nil </span><span class="cov0" title="0">{
                                if globalSettings.DEBUG </span><span class="cov0" title="0">{
                                        log.Printf("\tReadSync Failed - error: %s\n", err)
                                }</span>
                                <span class="cov0" title="0">if shutdownUAT != true </span><span class="cov0" title="0">{
                                        shutdownUAT = true
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }

                        <span class="cov0" title="0">if nRead &gt; 0 </span><span class="cov0" title="0">{
                                buf := buffer[:nRead]
                                godump978.InChan &lt;- buf
                        }</span>
                case &lt;-u.closeCh:<span class="cov0" title="0">
                        log.Println("UAT read(): shutdown msg received...")
                        return</span>
                }
        }
}

func (f *OGN) read() <span class="cov0" title="0">{
        defer f.wg.Done()
        log.Println("Entered OGN read() ...")

        // ogn-rx doesn't like the time jumping forward while running.. delay initial startup until we have a valid system time
        if !isGPSClockValid() </span><span class="cov0" title="0">{
                log.Printf("Delaying ogn-rx start until we have a valid GPS time")
        loop:
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-f.closeCh:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                if isGPSClockValid() </span><span class="cov0" title="0">{
                                        break loop</span>
                                } else<span class="cov0" title="0"> {
                                        time.Sleep(1 * time.Second)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">args := []string{"-d", strconv.Itoa(f.indexID), "-p", strconv.Itoa(f.ppm), "-L/var/log/"}
        if !globalSettings.OGNI2CTXEnabled </span><span class="cov0" title="0">{
                args = append(args, "-t", "off")
        }</span>
        <span class="cov0" title="0">cmd := exec.Command(STRATUX_HOME+"/bin/ogn-rx-eu", args...)
        stdout, _ := cmd.StdoutPipe()
        stderr, _ := cmd.StderrPipe()
        autoRestart := true // automatically restart crashing child process

        err := cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("OGN: Error executing ogn-rx-eu: %s\n", err)
                // don't return immediately, use the proper shutdown procedure
                shutdownOGN = true
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-f.closeCh:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                time.Sleep(1 * time.Second)</span>
                        }
                }
        }

        <span class="cov0" title="0">log.Println("OGN: Executed ogn-rx-eu successfully...")

        done := make(chan bool)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        case &lt;-f.closeCh:<span class="cov0" title="0">
                                log.Println("OGN read(): shutdown msg received, calling cmd.Process.Kill() ...")
                                autoRestart = false
                                err := cmd.Process.Kill()
                                if err == nil </span><span class="cov0" title="0">{
                                        log.Println("kill successful...")
                                }</span>
                                <span class="cov0" title="0">return</span>
                        default:<span class="cov0" title="0">
                                time.Sleep(1 * time.Second)</span>
                        }
                }
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                reader := bufio.NewReader(stdout)
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                line, err := reader.ReadString('\n')
                                line = strings.TrimSpace(line)
                                if err == nil &amp;&amp; len(line) &gt; 0 /* &amp;&amp; globalSettings.DEBUG */ </span><span class="cov0" title="0">{
                                        log.Println("OGN: ogn-rx-eu stdout: ", line)
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                reader := bufio.NewReader(stderr)
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                line, err := reader.ReadString('\n')
                                if err == nil </span><span class="cov0" title="0">{
                                        log.Println("OGN: ogn-rx-eu stderr: ", strings.TrimSpace(line))
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">cmd.Wait()

        log.Println("OGN: ogn-rx-eu terminated...")

        // we get here if A) the ogn-rx-eu process died
        // on its own or B) cmd.Process.Kill() was called
        // from within the goroutine, either way close
        // the "done" channel, which ensures we don't leak
        // goroutines...
        close(done)

        if autoRestart &amp;&amp; !shutdownOGN </span><span class="cov0" title="0">{
                time.Sleep(5 * time.Second)
                log.Println("OGN: restarting crashed ogn-rx-eu")
                f.wg.Add(1)
                go f.read()
        }</span>
}

func (e *AIS) read() <span class="cov0" title="0">{
        defer e.wg.Done()
        log.Println("Entered AIS read() ...")
        cmd := exec.Command(STRATUX_HOME+"/bin/rtl_ais", "-T", "-k", "-p", strconv.Itoa(e.ppm), "-d", strconv.Itoa(e.indexID))
        stdout, _ := cmd.StdoutPipe()
        stderr, _ := cmd.StderrPipe()

        err := cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing "+STRATUX_HOME+"/bin/rtl_ais: %s\n", err)
                // don't return immediately, use the proper shutdown procedure
                shutdownES = true
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-e.closeCh:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                time.Sleep(1 * time.Second)</span>
                        }
                }
        }

        <span class="cov0" title="0">log.Println("Executed " + cmd.String() + " successfully...")

        done := make(chan bool)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        case &lt;-e.closeCh:<span class="cov0" title="0">
                                log.Println("AIS read(): shutdown msg received, calling cmd.Process.Kill() ...")
                                err := cmd.Process.Kill()
                                if err == nil </span><span class="cov0" title="0">{
                                        log.Println("kill successful...")
                                }</span>
                                <span class="cov0" title="0">return</span>
                        default:<span class="cov0" title="0">
                                time.Sleep(1 * time.Second)</span>
                        }
                }
        }()

        <span class="cov0" title="0">stdoutBuf := make([]byte, 1024)
        stderrBuf := make([]byte, 1024)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                n, err := stdout.Read(stdoutBuf)
                                if err == nil &amp;&amp; n &gt; 0 </span><span class="cov0" title="0">{
                                        m := AISTermMessage{Text: string(stdoutBuf[:n]), Source: "stdout"}
                                        logAISTermMessage(m)
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                n, err := stderr.Read(stderrBuf)
                                if err == nil &amp;&amp; n &gt; 0 </span><span class="cov0" title="0">{
                                        m := AISTermMessage{Text: string(stderrBuf[:n]), Source: "stderr"}
                                        logAISTermMessage(m)
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">cmd.Wait()

        // we get here if A) the rvt_ais process died
        // on its own or B) cmd.Process.Kill() was called
        // from within the goroutine, either way close
        // the "done" channel, which ensures we don't leak
        // goroutines...
        close(done)</span>
}

func getPPM(serial string) int <span class="cov0" title="0">{
        r, err := regexp.Compile("str?a?t?u?x:\\d+:?(-?\\d*)")
        if err != nil </span><span class="cov0" title="0">{
                return globalSettings.PPM
        }</span>

        <span class="cov0" title="0">arr := r.FindStringSubmatch(serial)
        if arr == nil </span><span class="cov0" title="0">{
                return globalSettings.PPM
        }</span>

        <span class="cov0" title="0">ppm, err := strconv.Atoi(arr[1])
        if err != nil </span><span class="cov0" title="0">{
                return globalSettings.PPM
        }</span>

        <span class="cov0" title="0">return ppm</span>
}

func (e *ES) sdrConfig() (err error) <span class="cov0" title="0">{
        e.ppm = getPPM(e.serial)
        e.gain = globalSettings.Dump1090Gain
        log.Printf("===== ES Device Serial: %s PPM %d Gain %.1f =====\n", e.serial, e.ppm, e.gain)
        return
}</span>

func (f *OGN) sdrConfig() (err error) <span class="cov0" title="0">{
        f.ppm = getPPM(f.serial)
        log.Printf("===== OGN Device Serial: %s PPM %d =====\n", f.serial, f.ppm)
        return
}</span>

func (f *AIS) sdrConfig() (err error) <span class="cov0" title="0">{
        f.ppm = getPPM(f.serial)
        log.Printf("===== AIS Device Serial: %s PPM %d =====\n", f.serial, f.ppm)
        return
}</span>

// 978 UAT configuration settings
const (
        TunerGain    = 480
        SampleRate   = 2083334
        NewRTLFreq   = 28800000
        NewTunerFreq = 28800000
        CenterFreq   = 978000000
        Bandwidth    = 1000000
)

func (u *UAT) sdrConfig() (err error) <span class="cov0" title="0">{
        log.Printf("===== UAT Device Name  : %s =====\n", rtl.GetDeviceName(u.indexID))
        log.Printf("===== UAT Device Serial: %s=====\n", u.serial)

        if u.dev, err = rtl.Open(u.indexID); err != nil </span><span class="cov0" title="0">{
                log.Printf("\tUAT Open Failed...\n")
                return
        }</span>
        <span class="cov0" title="0">log.Printf("\tGetTunerType: %s\n", u.dev.GetTunerType())

        //---------- Set Tuner Gain ----------
        err = u.dev.SetTunerGainMode(true)
        if err != nil </span><span class="cov0" title="0">{
                u.dev.Close()
                log.Printf("\tSetTunerGainMode Failed - error: %s\n", err)
                return
        }</span>
        <span class="cov0" title="0">log.Printf("\tSetTunerGainMode Successful\n")

        err = u.dev.SetTunerGain(TunerGain)
        if err != nil </span><span class="cov0" title="0">{
                u.dev.Close()
                log.Printf("\tSetTunerGain Failed - error: %s\n", err)
                return
        }</span>
        <span class="cov0" title="0">log.Printf("\tSetTunerGain Successful\n")

        tgain := u.dev.GetTunerGain()
        log.Printf("\tGetTunerGain: %d\n", tgain)

        //---------- Get/Set Sample Rate ----------
        err = u.dev.SetSampleRate(SampleRate)
        if err != nil </span><span class="cov0" title="0">{
                u.dev.Close()
                log.Printf("\tSetSampleRate Failed - error: %s\n", err)
                return
        }</span>
        <span class="cov0" title="0">log.Printf("\tSetSampleRate - rate: %d\n", SampleRate)

        log.Printf("\tGetSampleRate: %d\n", u.dev.GetSampleRate())

        //---------- Get/Set Xtal Freq ----------
        rtlFreq, tunerFreq, err := u.dev.GetXtalFreq()
        if err != nil </span><span class="cov0" title="0">{
                u.dev.Close()
                log.Printf("\tGetXtalFreq Failed - error: %s\n", err)
                return
        }</span>
        <span class="cov0" title="0">log.Printf("\tGetXtalFreq - Rtl: %d, Tuner: %d\n", rtlFreq, tunerFreq)

        err = u.dev.SetXtalFreq(NewRTLFreq, NewTunerFreq)
        if err != nil </span><span class="cov0" title="0">{
                u.dev.Close()
                log.Printf("\tSetXtalFreq Failed - error: %s\n", err)
                return
        }</span>
        <span class="cov0" title="0">log.Printf("\tSetXtalFreq - Center freq: %d, Tuner freq: %d\n",
                NewRTLFreq, NewTunerFreq)

        //---------- Get/Set Center Freq ----------
        err = u.dev.SetCenterFreq(CenterFreq)
        if err != nil </span><span class="cov0" title="0">{
                u.dev.Close()
                log.Printf("\tSetCenterFreq 978MHz Failed, error: %s\n", err)
                return
        }</span>
        <span class="cov0" title="0">log.Printf("\tSetCenterFreq 978MHz Successful\n")

        log.Printf("\tGetCenterFreq: %d\n", u.dev.GetCenterFreq())

        //---------- Set Bandwidth ----------
        log.Printf("\tSetting Bandwidth: %d\n", Bandwidth)
        if err = u.dev.SetTunerBw(Bandwidth); err != nil </span><span class="cov0" title="0">{
                u.dev.Close()
                log.Printf("\tSetTunerBw %d Failed, error: %s\n", Bandwidth, err)
                return
        }</span>
        <span class="cov0" title="0">log.Printf("\tSetTunerBw %d Successful\n", Bandwidth)

        if err = u.dev.ResetBuffer(); err != nil </span><span class="cov0" title="0">{
                u.dev.Close()
                log.Printf("\tResetBuffer Failed - error: %s\n", err)
                return
        }</span>
        <span class="cov0" title="0">log.Printf("\tResetBuffer Successful\n")

        //---------- Get/Set Freq Correction ----------
        freqCorr := u.dev.GetFreqCorrection()
        log.Printf("\tGetFreqCorrection: %d\n", freqCorr)

        u.ppm = getPPM(u.serial)
        err = u.dev.SetFreqCorrection(u.ppm)
        if err != nil </span><span class="cov0" title="0">{
                u.dev.Close()
                log.Printf("\tSetFreqCorrection %d Failed, error: %s\n", u.ppm, err)
                return
        }</span>
        <span class="cov0" title="0">log.Printf("\tSetFreqCorrection %d Successful\n", u.ppm)

        return</span>
}

// Read from the godump978 channel - on or off.
func uatReader() <span class="cov0" title="0">{
        log.Println("Entered uatReader() ...")
        for </span><span class="cov0" title="0">{
                uat := &lt;-godump978.OutChan
                TraceLog.Record(CONTEXT_GODUMP978, []byte(uat))
                handleUatMessage(uat)
        }</span>
}

func handleUatMessage(uat string) <span class="cov0" title="0">{
        o, msgtype := parseInput(uat)
        if o != nil &amp;&amp; msgtype != 0 </span><span class="cov0" title="0">{
                relayMessage(msgtype, o)
        }</span>
}

func (u *UAT) writeID() error <span class="cov0" title="0">{
        info, err := u.dev.GetHwInfo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">info.Serial = "stratux:978"
        return u.dev.SetHwInfo(info)</span>
}

func (e *ES) writeID() error <span class="cov0" title="0">{
        info, err := e.dev.GetHwInfo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">info.Serial = "stratux:1090"
        return e.dev.SetHwInfo(info)</span>
}

func (f *OGN) writeID() error <span class="cov0" title="0">{
        info, err := f.dev.GetHwInfo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">info.Serial = "stratux:868"
        return f.dev.SetHwInfo(info)</span>
}

func (f *AIS) writeID() error <span class="cov0" title="0">{
        info, err := f.dev.GetHwInfo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">info.Serial = "stratux:162"
        return f.dev.SetHwInfo(info)</span>
}

func (u *UAT) shutdown() <span class="cov0" title="0">{
        log.Println("Entered UAT shutdown() ...")
        close(u.closeCh) // signal to shutdown
        log.Println("UAT shutdown(): calling u.wg.Wait() ...")
        u.wg.Wait() // Wait for the goroutine to shutdown
        log.Println("UAT shutdown(): u.wg.Wait() returned...")
        log.Println("UAT shutdown(): closing device ...")
        u.dev.Close() // preempt the blocking ReadSync call
        log.Println("UAT shutdown() complete ...")
}</span>

func (e *ES) shutdown() <span class="cov0" title="0">{
        log.Println("Entered ES shutdown() ...")
        close(e.closeCh) // signal to shutdown
        log.Println("ES shutdown(): calling e.wg.Wait() ...")
        e.wg.Wait() // Wait for the goroutine to shutdown
        log.Println("ES shutdown() complete ...")
}</span>

func (f *OGN) shutdown() <span class="cov0" title="0">{
        log.Println("Entered OGN shutdown() ...")
        close(f.closeCh) // signal to shutdown
        log.Println("signal shutdown(): calling f.wg.Wait() ...")
        f.wg.Wait() // Wait for the goroutine to shutdown
        log.Println("signal shutdown() complete ...")
}</span>

func (f *AIS) shutdown() <span class="cov0" title="0">{
        log.Println("Entered AIS shutdown() ...")
        close(f.closeCh) // signal to shutdown
        log.Println("signal shutdown(): calling f.wg.Wait() ...")
        f.wg.Wait() // Wait for the goroutine to shutdown
        log.Println("signal shutdown() complete ...")
}</span>

var sdrShutdown bool

func sdrKill() <span class="cov0" title="0">{
        // Send signal to shutdown to sdrWatcher().
        sdrShutdown = true
        // Spin until all devices have been de-initialized.
        for UATDev != nil || ESDev != nil || OGNDev != nil || AISDev != nil </span><span class="cov0" title="0">{
                time.Sleep(1 * time.Second)
        }</span>
}

func reCompile(s string) *regexp.Regexp <span class="cov10" title="4">{
        // note , compile returns a nil pointer on error
        r, _ := regexp.Compile(s)
        return r
}</span>

type regexUAT regexp.Regexp
type regexES regexp.Regexp
type regexOGN regexp.Regexp
type regexAIS regexp.Regexp

var rUAT = (*regexUAT)(reCompile("str?a?t?u?x:978"))
var rES = (*regexES)(reCompile("str?a?t?u?x:1090"))
var rOGN = (*regexES)(reCompile("str?a?t?u?x:868"))
var rAIS = (*regexAIS)(reCompile("str?a?t?u?x:162"))

func (r *regexUAT) hasID(serial string) bool <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return strings.HasPrefix(serial, "stratux:978")
        }</span>
        <span class="cov0" title="0">return (*regexp.Regexp)(r).MatchString(serial)</span>
}

func (r *regexES) hasID(serial string) bool <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return strings.HasPrefix(serial, "stratux:1090")
        }</span>
        <span class="cov0" title="0">return (*regexp.Regexp)(r).MatchString(serial)</span>
}

func (r *regexOGN) hasID(serial string) bool <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return strings.HasPrefix(serial, "stratux:868")
        }</span>
        <span class="cov0" title="0">return (*regexp.Regexp)(r).MatchString(serial)</span>
}

func (r *regexAIS) hasID(serial string) bool <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return strings.HasPrefix(serial, "stratux:162")
        }</span>
        <span class="cov0" title="0">return (*regexp.Regexp)(r).MatchString(serial)</span>
}

func createUATDev(id int, serial string, idSet bool) error <span class="cov0" title="0">{
        UATDev = &amp;UAT{indexID: id, serial: serial}
        if err := UATDev.sdrConfig(); err != nil </span><span class="cov0" title="0">{
                log.Printf("UATDev.sdrConfig() failed: %s\n", err)
                UATDev = nil
                return err
        }</span>
        <span class="cov0" title="0">UATDev.wg = &amp;sync.WaitGroup{}
        UATDev.idSet = idSet
        UATDev.closeCh = make(chan int)
        UATDev.wg.Add(1)
        go UATDev.read()
        return nil</span>
}

func createESDev(id int, serial string, idSet bool) error <span class="cov0" title="0">{
        ESDev = &amp;ES{indexID: id, serial: serial}
        if err := ESDev.sdrConfig(); err != nil </span><span class="cov0" title="0">{
                log.Printf("ESDev.sdrConfig() failed: %s\n", err)
                ESDev = nil
                return err
        }</span>
        <span class="cov0" title="0">ESDev.wg = &amp;sync.WaitGroup{}
        ESDev.idSet = idSet
        ESDev.closeCh = make(chan int)
        ESDev.wg.Add(1)
        go ESDev.read()
        return nil</span>
}

func createOGNDev(id int, serial string, idSet bool) error <span class="cov0" title="0">{
        OGNDev = &amp;OGN{indexID: id, serial: serial}
        if err := OGNDev.sdrConfig(); err != nil </span><span class="cov0" title="0">{
                log.Printf("OGNDev.sdrConfig() failed: %s\n", err)
                OGNDev = nil
                return err
        }</span>
        <span class="cov0" title="0">OGNDev.wg = &amp;sync.WaitGroup{}
        OGNDev.idSet = idSet
        OGNDev.closeCh = make(chan int)
        OGNDev.wg.Add(1)
        go OGNDev.read()
        return nil</span>
}

func createAISDev(id int, serial string, idSet bool) error <span class="cov0" title="0">{
        AISDev = &amp;AIS{indexID: id, serial: serial}
        if err := AISDev.sdrConfig(); err != nil </span><span class="cov0" title="0">{
                log.Printf("AISDev.sdrConfig() failed: %s\n", err)
                AISDev = nil
                return err
        }</span>
        <span class="cov0" title="0">AISDev.wg = &amp;sync.WaitGroup{}
        AISDev.idSet = idSet
        AISDev.closeCh = make(chan int)
        AISDev.wg.Add(1)
        go AISDev.read()
        return nil</span>
}

func configDevices(count int, esEnabled, uatEnabled, ognEnabled, aisEnabled bool) <span class="cov0" title="0">{
        // once the tagged dongles have been assigned, explicitly range over
        // the remaining IDs and assign them to any anonymous dongles
        unusedIDs := make(map[int]string)

        // loop 1: assign tagged dongles
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                _, _, s, err := rtl.GetDeviceUsbStrings(i)
                if err == nil </span><span class="cov0" title="0">{
                        //FIXME: Trim NULL from the serial. Best done in gortlsdr, but putting this here for now.
                        s = strings.Trim(s, "\x00")
                        // no need to check if createXDev returned an error; if it
                        // failed to config the error is logged and we can ignore
                        // it here so it doesn't get queued up again
                        if uatEnabled &amp;&amp; UATDev == nil &amp;&amp; rUAT.hasID(s) </span><span class="cov0" title="0">{
                                createUATDev(i, s, true)
                        }</span> else<span class="cov0" title="0"> if esEnabled &amp;&amp; ESDev == nil &amp;&amp; rES.hasID(s) </span><span class="cov0" title="0">{
                                createESDev(i, s, true)
                        }</span> else<span class="cov0" title="0"> if ognEnabled &amp;&amp; OGNDev == nil &amp;&amp; rOGN.hasID(s) </span><span class="cov0" title="0">{
                                createOGNDev(i, s, true)
                        }</span> else<span class="cov0" title="0"> if aisEnabled &amp;&amp; AISDev == nil &amp;&amp; rAIS.hasID(s) </span><span class="cov0" title="0">{
                                createAISDev(i, s, true)
                        }</span> else<span class="cov0" title="0"> {
                                unusedIDs[i] = s
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Printf("rtl.GetDeviceUsbStrings id %d: %s\n", i, err)
                }</span>
        }

        // loop 2: assign anonymous dongles but sanity check the serial ids
        // so we don't cross config for dual assigned dongles. e.g. when two
        // dongles are set to the same stratux id and the unconsumed,
        // non-anonymous, dongle makes it to this loop.
        <span class="cov0" title="0">for i, s := range unusedIDs </span><span class="cov0" title="0">{
                if uatEnabled &amp;&amp; !globalStatus.UATRadio_connected &amp;&amp; UATDev == nil &amp;&amp; !rES.hasID(s) &amp;&amp; !rOGN.hasID(s) </span><span class="cov0" title="0">{
                        createUATDev(i, s, false)
                }</span> else<span class="cov0" title="0"> if esEnabled &amp;&amp; ESDev == nil &amp;&amp; !rUAT.hasID(s) &amp;&amp; !rOGN.hasID(s) </span><span class="cov0" title="0">{
                        createESDev(i, s, false)
                }</span> else<span class="cov0" title="0"> if ognEnabled &amp;&amp; OGNDev == nil </span><span class="cov0" title="0">{
                        createOGNDev(i, s, false)
                }</span> else<span class="cov0" title="0"> if aisEnabled &amp;&amp; AISDev == nil </span><span class="cov0" title="0">{
                        createAISDev(i, s, false)
                }</span>
        }
}

// to keep our sync primitives synchronized, only exit a read
// method's goroutine via the close flag channel check, to
// include catastrophic dongle failures
var shutdownES bool
var shutdownUAT bool
var shutdownOGN bool
var shutdownAIS bool

// Watch for config/device changes.
func sdrWatcher() <span class="cov0" title="0">{
        prevCount := 0
        prevUATEnabled := false
        prevESEnabled := false
        prevOGNEnabled := false
        prevAISEnabled := false
        prevOGNTXEnabled := false
        prevdump1090Gain := globalSettings.Dump1090Gain

        // Get the system (RPi) uptime.
        info := syscall.Sysinfo_t{}
        err := syscall.Sysinfo(&amp;info)

        if err == nil &amp;&amp; info.Uptime &gt; 120 &amp;&amp; globalSettings.DeveloperMode </span><span class="cov0" title="0">{
                // Throw a "critical error" if developer mode is enabled. Alerts the developer that the daemon was restarted (possibly)
                //  unexpectedly.
                addSingleSystemErrorf("restart-warn", "System uptime %d seconds. Daemon was restarted.\n", info.Uptime)
        }</span>

        // Got system uptime. Delay SDR start for a bit to reduce noise for the GPS to get a fix.
        // Will give up waiting after 120s without fix
        <span class="cov0" title="0">for err == nil &amp;&amp; info.Uptime &lt; 120 &amp;&amp; !isGPSValid() </span><span class="cov0" title="0">{
                time.Sleep(1 * time.Second)
                err = syscall.Sysinfo(&amp;info)
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                time.Sleep(1 * time.Second)
                if sdrShutdown </span><span class="cov0" title="0">{
                        if UATDev != nil </span><span class="cov0" title="0">{
                                UATDev.shutdown()
                                UATDev = nil
                        }</span>
                        <span class="cov0" title="0">if ESDev != nil </span><span class="cov0" title="0">{
                                ESDev.shutdown()
                                ESDev = nil
                        }</span>
                        <span class="cov0" title="0">if OGNDev != nil </span><span class="cov0" title="0">{
                                OGNDev.shutdown()
                                OGNDev = nil
                        }</span>
                        <span class="cov0" title="0">if AISDev != nil </span><span class="cov0" title="0">{
                                AISDev.shutdown()
                                AISDev = nil
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                // true when a ReadSync call fails
                <span class="cov0" title="0">if shutdownUAT </span><span class="cov0" title="0">{
                        if UATDev != nil </span><span class="cov0" title="0">{
                                UATDev.shutdown()
                                UATDev = nil
                        }</span>
                        <span class="cov0" title="0">shutdownUAT = false</span>
                }
                // true when we get stderr output
                <span class="cov0" title="0">if shutdownES </span><span class="cov0" title="0">{
                        if ESDev != nil </span><span class="cov0" title="0">{
                                ESDev.shutdown()
                                ESDev = nil
                        }</span>
                        <span class="cov0" title="0">shutdownES = false</span>
                }
                // true when we get stderr output
                <span class="cov0" title="0">if shutdownOGN </span><span class="cov0" title="0">{
                        if OGNDev != nil </span><span class="cov0" title="0">{
                                OGNDev.shutdown()
                                OGNDev = nil
                        }</span>
                        <span class="cov0" title="0">shutdownOGN = false</span>
                }
                <span class="cov0" title="0">if shutdownAIS </span><span class="cov0" title="0">{
                        if AISDev != nil </span><span class="cov0" title="0">{
                                AISDev.shutdown()
                                AISDev = nil
                        }</span>
                        <span class="cov0" title="0">shutdownAIS = false</span>
                }

                // capture current state
                <span class="cov0" title="0">esEnabled := globalSettings.ES_Enabled
                uatEnabled := globalSettings.UAT_Enabled
                ognEnabled := globalSettings.OGN_Enabled
                aisEnabled := globalSettings.AIS_Enabled
                ognTXEnabled := globalSettings.OGNI2CTXEnabled
                dump1090Gain := globalSettings.Dump1090Gain
                count := rtl.GetDeviceCount()
                interfaceCount := count
                if globalStatus.UATRadio_connected </span><span class="cov0" title="0">{
                        interfaceCount++
                }</span>
                <span class="cov0" title="0">atomic.StoreUint32(&amp;globalStatus.Devices, uint32(interfaceCount))

                // support up to 3 dongles
                if count &gt; 3 </span><span class="cov0" title="0">{
                        count = 3
                }</span>

                <span class="cov0" title="0">if interfaceCount == prevCount &amp;&amp; prevESEnabled == esEnabled &amp;&amp; prevUATEnabled == uatEnabled &amp;&amp; prevOGNEnabled == ognEnabled &amp;&amp; prevAISEnabled == aisEnabled &amp;&amp;
                        prevOGNTXEnabled == ognTXEnabled &amp;&amp; prevdump1090Gain == dump1090Gain </span><span class="cov0" title="0">{
                        continue</span>
                }

                // the device count or the global settings have changed, reconfig
                <span class="cov0" title="0">if UATDev != nil </span><span class="cov0" title="0">{
                        UATDev.shutdown()
                        UATDev = nil
                }</span>
                <span class="cov0" title="0">if ESDev != nil </span><span class="cov0" title="0">{
                        ESDev.shutdown()
                        ESDev = nil
                }</span>
                <span class="cov0" title="0">if OGNDev != nil </span><span class="cov0" title="0">{
                        OGNDev.shutdown()
                        OGNDev = nil
                }</span>
                <span class="cov0" title="0">if AISDev != nil </span><span class="cov0" title="0">{
                        AISDev.shutdown()
                        AISDev = nil
                }</span>
                <span class="cov0" title="0">configDevices(count, esEnabled, uatEnabled, ognEnabled, aisEnabled)

                prevCount = interfaceCount
                prevUATEnabled = uatEnabled
                prevESEnabled = esEnabled
                prevOGNEnabled = ognEnabled
                prevAISEnabled = aisEnabled
                prevOGNTXEnabled = ognTXEnabled
                prevdump1090Gain = dump1090Gain

                countEnabled := 0

                if uatEnabled </span><span class="cov0" title="0">{
                        countEnabled++
                }</span>
                <span class="cov0" title="0">if esEnabled </span><span class="cov0" title="0">{
                        countEnabled++
                }</span>
                <span class="cov0" title="0">if ognEnabled </span><span class="cov0" title="0">{
                        countEnabled++
                }</span>
                <span class="cov0" title="0">if aisEnabled </span><span class="cov0" title="0">{
                        countEnabled++
                }</span>
                <span class="cov0" title="0">if countEnabled &gt; interfaceCount </span><span class="cov0" title="0">{
                        // User enabled too many protocols. Show error..
                        used := make([]string, 0)
                        if UATDev != nil </span><span class="cov0" title="0">{
                                used = append(used, "UAT")
                        }</span>
                        <span class="cov0" title="0">if ESDev != nil </span><span class="cov0" title="0">{
                                used = append(used, "1090ES")
                        }</span>
                        <span class="cov0" title="0">if OGNDev != nil </span><span class="cov0" title="0">{
                                used = append(used, "OGN")
                        }</span>
                        <span class="cov0" title="0">if AISDev != nil </span><span class="cov0" title="0">{
                                used = append(used, "AIS")
                        }</span>
                        <span class="cov0" title="0">addSingleSystemErrorf("sdrconfig", "You have enabled more protocols than you have receivers for. "+
                                "You have %d receivers, but enabled %d protocols. Please disable %d of them for things to work correctly. For now we are only using %s.",
                                count, countEnabled, countEnabled-count, strings.Join(used, ", "))</span>

                } else<span class="cov0" title="0"> {
                        removeSingleSystemError("sdrconfig")
                }</span>

        }
}

func sdrInit() <span class="cov0" title="0">{
        go sdrWatcher()
        go uatReader()
        go godump978.ProcessDataFromChannel()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package main

import (
        "fmt"
        "log"
        "math"
        "path/filepath"
        "strings"
        "time"

        "github.com/stratux/stratux/sensors/bmp388"

        "github.com/kidoman/embd"
        _ "github.com/kidoman/embd/host/all"
        "github.com/ricochet2200/go-disk-usage/du"
        "github.com/stratux/goflying/ahrs"
        "github.com/stratux/goflying/ahrsweb"
        "github.com/stratux/stratux/common"
        "github.com/stratux/stratux/sensors"
)

const (
        numRetries uint8 = 50
        calCLimit        = 0.15
        calDLimit        = 10.0

        // WHO_AM_I values to differentiate between the different IMUs.
        MPUREG_WHO_AM_I             = 0x75
        MPUREG_WHO_AM_I_VAL         = 0x71 // Expected value.
        MPUREG_WHO_AM_I_VAL_9255    = 0x73 // Expected value for MPU9255, seems to be compatible to 9250
        MPUREG_WHO_AM_I_VAL_6500    = 0x70 // Expected value for MPU6500, seems to be same as 9250 but without magnetometer
        MPUREG_WHO_AM_I_VAL_60X0    = 0x68 // Expected value for MPU6000 and MPU6050 (and MPU9150)
        MPUREG_WHO_AM_I_VAL_UNKNOWN = 0x75 // Unknown MPU found on recent batch of gy91 boards see discussion 182
        ICMREG_WHO_AM_I             = 0x00
        ICMREG_WHO_AM_I_VAL         = 0xEA             // Expected value.
        PRESSURE_WHO_AM_I           = bmp388.RegChipId // Expected address for bosch pressure sensors bmpXXX.
)

var (
        i2cbus           embd.I2CBus
        myPressureReader sensors.PressureReader
        myIMUReader      sensors.IMUReader
        cal              chan (string)
        analysisLogger   *ahrs.AHRSLogger
        ahrsCalibrating  bool
        logMap           map[string]interface{}
)

func initI2CSensors() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        // still want to update status in case external GPS delivers pressure data (OGN Tracker, SoftRF with BMP)
                        // This usually happens on X86, where there is no embd supported I2C
                        fmt.Println("Panic during i2c initialization!")
                        go updateAHRSStatus()
                }</span>
        }()
        <span class="cov0" title="0">embd.SetHost(embd.HostRPi, 3)
        i2cbus = embd.NewI2CBus(1)
        go pollSensors()
        go sensorAttitudeSender()
        go updateAHRSStatus()</span>
}

func pollSensors() <span class="cov0" title="0">{
        timer := time.NewTicker(4 * time.Second)
        for </span><span class="cov0" title="0">{
                &lt;-timer.C

                // If it's not currently connected, try connecting to pressure sensor
                if globalSettings.BMP_Sensor_Enabled &amp;&amp; !globalStatus.BMPConnected </span><span class="cov0" title="0">{
                        globalStatus.BMPConnected = initPressureSensor() // I2C temperature and pressure altitude.
                        go tempAndPressureSender()
                }</span>

                // If it's not currently connected, try connecting to IMU
                <span class="cov0" title="0">if globalSettings.IMU_Sensor_Enabled &amp;&amp; !globalStatus.IMUConnected </span><span class="cov0" title="0">{
                        globalStatus.IMUConnected = initIMU() // I2C accel/gyro/mag.
                }</span>
        }
}

func initPressureSensor() (ok bool) <span class="cov0" title="0">{

        v, err := i2cbus.ReadByteFromReg(0x76, PRESSURE_WHO_AM_I)

        if err != nil </span><span class="cov0" title="0">{
                v, err = i2cbus.ReadByteFromReg(0x77, PRESSURE_WHO_AM_I)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error identifying BMP: %s\n", err.Error())
                return false
        }</span>
        <span class="cov0" title="0">if v == bmp388.ChipId || v == bmp388.ChipId390 </span><span class="cov0" title="0">{
                log.Printf("BMP-388 detected")
                bmp, err := sensors.NewBMP388(&amp;i2cbus)
                if err == nil </span><span class="cov0" title="0">{
                        myPressureReader = bmp
                        return true
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("using BMP-280")
                bmp, err := sensors.NewBMP280(&amp;i2cbus, 100*time.Millisecond)
                if err == nil </span><span class="cov0" title="0">{
                        myPressureReader = bmp
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func tempAndPressureSender() <span class="cov0" title="0">{
        var (
                temp     float64
                press    float64
                altLast  = -9999.9
                altitude float64
                err      error
                dt       = 0.1
                failNum  uint8
        )

        // Initialize variables for rate of climb calc
        u := 5 / (5 + float32(dt)) // Use 5 sec decay time for rate of climb, slightly faster than typical VSI

        timer := time.NewTicker(time.Duration(1000*dt) * time.Millisecond)
        for globalSettings.BMP_Sensor_Enabled &amp;&amp; globalStatus.BMPConnected </span><span class="cov0" title="0">{
                &lt;-timer.C

                // Read temperature and pressure altitude.
                temp, err = myPressureReader.Temperature()
                if err != nil </span><span class="cov0" title="0">{
                        addSingleSystemErrorf("pressure-sensor-temp-read", "AHRS Error: Couldn't read temperature from sensor: %s", err)
                }</span>
                <span class="cov0" title="0">press, err = myPressureReader.Pressure()
                if press == 0 || err != nil </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                addSingleSystemErrorf("pressure-sensor-pressure-read", "AHRS Error: Couldn't read pressure from sensor: %s", err)
                        }</span>
                        <span class="cov0" title="0">failNum++
                        if failNum &gt; numRetries </span><span class="cov0" title="0">{
                                //                                log.Printf("AHRS Error: Couldn't read pressure from sensor %d times, closing BMP: %s", failNum, err)
                                myPressureReader.Close()
                                globalStatus.BMPConnected = false // Try reconnecting a little later
                                errStr := "Pressure is 0"
                                if err != nil </span><span class="cov0" title="0">{
                                        errStr = err.Error()
                                }</span>
                                <span class="cov0" title="0">addSingleSystemErrorf("pressure-sensor-pressure-read", "AHRS Error: Couldn't read pressure from sensor: %s", errStr)
                                break</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">altitude = common.CalcAltitude(press, globalSettings.AltitudeOffset)
                if altitude &gt; 70000 || (isGPSValid() &amp;&amp; mySituation.GPSAltitudeMSL != 0 &amp;&amp; math.Abs(float64(mySituation.GPSAltitudeMSL)-altitude) &gt; 5000) </span><span class="cov0" title="0">{
                        addSingleSystemErrorf("BaroBroken", "Barometric altitude %d' out of expected range. Ignoring. Pressure sensor potentially broken.", int32(altitude))
                        continue</span>
                }

                // Update the Situation data.
                <span class="cov0" title="0">mySituation.muBaro.Lock()
                mySituation.BaroLastMeasurementTime = stratuxClock.Time
                mySituation.BaroTemperature = float32(temp)
                mySituation.BaroPressureAltitude = float32(altitude)
                if altLast &lt; -2000 </span><span class="cov0" title="0">{
                        altLast = altitude // Initialize
                }</span>
                // Assuming timer is reasonably accurate, use a regular ewma
                <span class="cov0" title="0">mySituation.BaroVerticalSpeed = u*mySituation.BaroVerticalSpeed + (1-u)*float32(altitude-altLast)/(float32(dt)/60)
                mySituation.BaroSourceType = BARO_TYPE_BMP280
                mySituation.muBaro.Unlock()
                altLast = altitude</span>
        }
        //mySituation.BaroPressureAltitude = 99999
        //mySituation.BaroVerticalSpeed = 99999
}

func initIMU() (ok bool) <span class="cov0" title="0">{
        // Check if the chip is the ICM-20948 or MPU-9250.
        v, err := i2cbus.ReadByteFromReg(0x68, ICMREG_WHO_AM_I)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error identifying IMU: %s\n", err.Error())
                return false
        }</span>
        <span class="cov0" title="0">v2, err := i2cbus.ReadByteFromReg(0x68, MPUREG_WHO_AM_I)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error identifying IMU: %s\n", err.Error())
                return false
        }</span>

        <span class="cov0" title="0">if v == ICMREG_WHO_AM_I_VAL </span><span class="cov0" title="0">{
                log.Println("ICM-20948 detected.")
                imu, err := sensors.NewICM20948(&amp;i2cbus)
                if err == nil </span><span class="cov0" title="0">{
                        myIMUReader = imu
                        return true
                }</span>
        } else<span class="cov0" title="0"> if v2 == MPUREG_WHO_AM_I_VAL || v2 == MPUREG_WHO_AM_I_VAL_9255 || v2 == MPUREG_WHO_AM_I_VAL_6500 ||
                v2 == MPUREG_WHO_AM_I_VAL_60X0 || v2 == MPUREG_WHO_AM_I_VAL_UNKNOWN </span><span class="cov0" title="0">{

                log.Printf("MPU detected (%02x).\n", v2)
                imu, err := sensors.NewMPU9250(&amp;i2cbus)
                if err == nil </span><span class="cov0" title="0">{
                        myIMUReader = imu
                        return true
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("Could not identify MPU. v=%02x, v2=%02x.\n", v, v2)
                return false
        }</span>

        <span class="cov0" title="0">return false</span>
}

//FIXME: Shoud be moved to managementinterface.go and standardized on management interface port.

func sensorAttitudeSender() <span class="cov0" title="0">{
        var (
                t                    time.Time
                roll, pitch, heading float64
                mpuError, magError   error
                failNum              uint8
        )

        s := ahrs.NewSimpleAHRS()
        m := ahrs.NewMeasurement()
        cal = make(chan (string), 1)

        // Set up loggers for analysis
        ahrswebListener, err := ahrsweb.NewKalmanListener()
        if err != nil </span>{<span class="cov0" title="0">
                // addSingleSystemErrorf("ahrs-web-start", "AHRS Info: couldn't start ahrswebListener: %s\n", err.Error())
        }</span> else<span class="cov0" title="0"> {
                defer ahrswebListener.Close()
        }</span>

        // Need a sampling freq faster than 10Hz
        <span class="cov0" title="0">timer := time.NewTicker(50 * time.Millisecond) // ~20Hz update.
        for </span><span class="cov0" title="0">{
                // Set sensor gyro calibrations
                if c, d := &amp;globalSettings.C, &amp;globalSettings.D; d[0]*d[0]+d[1]*d[1]+d[2]*d[2] &gt; 0 </span><span class="cov0" title="0">{
                        s.SetCalibrations(c, d)
                        // log.Printf("AHRS Info: IMU Calibrations read from settings: accel %6f %6f %6f; gyro %6f %6f %6f\n",
                        //        c[0], c[1], c[2], d[0], d[1], d[2])
                }</span> else<span class="cov0" title="0"> {
                        // Do an initial calibration
                        select </span>{ // Don't block if cal isn't receiving: only need one calibration in the queue at a time.
                        case cal &lt;- "cal":<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0"></span>
                        }
                }

                // Set sensor quaternion
                <span class="cov0" title="0">if f := &amp;globalSettings.SensorQuaternion; f[0]*f[0]+f[1]*f[1]+f[2]*f[2]+f[3]*f[3] &gt; 0 </span><span class="cov0" title="0">{
                        s.SetSensorQuaternion(f)
                }</span> else<span class="cov0" title="0"> {
                        select </span>{ // Don't block if cal isn't receiving: only need one calibration in the queue at a time.
                        case cal &lt;- "level":<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0"></span>
                        }
                }

                <span class="cov0" title="0">failNum = 0
                &lt;-timer.C
                time.Sleep(950 * time.Millisecond)
                for globalSettings.IMU_Sensor_Enabled &amp;&amp; globalStatus.IMUConnected </span><span class="cov0" title="0">{
                        &lt;-timer.C

                        // Process calibration and level requests
                        select </span>{
                        case action := &lt;-cal:<span class="cov0" title="0">
                                log.Printf("AHRS Info: cal received action %s\n", action)
                                ahrsCalibrating = true
                                myIMUReader.Read() // Clear out the averages
                                var (
                                        nTries uint8
                                        cc, dd float64
                                )
                                for (math.Abs(cc-1) &gt; calCLimit || dd &gt; calDLimit) &amp;&amp; nTries &lt; numRetries </span><span class="cov0" title="0">{
                                        time.Sleep(1 * time.Second)
                                        _, d1, d2, d3, c1, c2, c3, _, _, _, mpuError, _ := myIMUReader.Read()
                                        cc = math.Sqrt(c1*c1 + c2*c2 + c3*c3)
                                        dd = math.Sqrt(d1*d1 + d2*d2 + d3*d3)
                                        nTries++
                                        log.Printf("AHRS Info: IMU calibration attempt #%d\n", nTries)
                                        if mpuError != nil </span><span class="cov0" title="0">{
                                                log.Printf("AHRS Info: Error reading IMU while calibrating: %s\n", mpuError)
                                        }</span> else<span class="cov0" title="0"> {
                                                if strings.Contains(action, "cal") </span><span class="cov0" title="0">{ // Calibrate gyros
                                                        globalSettings.D = [3]float64{d1, d2, d3}
                                                        s.SetCalibrations(nil, &amp;globalSettings.D)
                                                        log.Printf("AHRS Info: IMU gyro calibration: %3f %3f %3f\n", d1, d2, d3)
                                                }</span>
                                                <span class="cov0" title="0">if strings.Contains(action, "level") </span><span class="cov0" title="0">{ // Calibrate accel / level
                                                        globalSettings.C = [3]float64{c1, c2, c3}
                                                        s.SetCalibrations(&amp;globalSettings.C, nil)
                                                        globalSettings.SensorQuaternion = *makeOrientationQuaternion(globalSettings.C)
                                                        s.SetSensorQuaternion(&amp;globalSettings.SensorQuaternion)
                                                        s.Reset()
                                                        log.Printf("AHRS Info: IMU accel calibration: %3f %3f %3f\n", c1, c2, c3)
                                                        log.Printf("AHRS Info: Caged to quaternion %v\n", globalSettings.SensorQuaternion)
                                                }</span>
                                                <span class="cov0" title="0">saveSettings()</span>
                                        }
                                }
                                <span class="cov0" title="0">ahrsCalibrating = false
                                &lt;-timer.C</span> // Make sure we get data for the actual algorithm
                        default:<span class="cov0" title="0"></span>
                        }

                        // Make the IMU sensor measurements.
                        <span class="cov0" title="0">t = stratuxClock.Time
                        m.T = float64(t.UnixNano()/1000) / 1e6
                        _, m.B1, m.B2, m.B3, m.A1, m.A2, m.A3, m.M1, m.M2, m.M3, mpuError, magError = myIMUReader.Read()
                        m.SValid = mpuError == nil
                        m.MValid = magError == nil
                        if mpuError != nil </span><span class="cov0" title="0">{
                                log.Printf("AHRS Gyro/Accel Error: %s\n", mpuError)
                                failNum++
                                if failNum &gt; numRetries </span><span class="cov0" title="0">{
                                        log.Printf("AHRS Gyro/Accel Error: failed to read %d times, restarting: %s\n",
                                                failNum-1, mpuError)
                                        myIMUReader.Close()
                                        globalStatus.IMUConnected = false
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">failNum = 0
                        if magError != nil </span><span class="cov0" title="0">{
                                if globalSettings.DEBUG </span><span class="cov0" title="0">{
                                        log.Printf("AHRS Magnetometer Error, not using for this run: %s\n", magError)
                                }</span>
                                <span class="cov0" title="0">m.MValid = false</span>
                        }

                        // Make the GPS measurements.
                        <span class="cov0" title="0">m.TW = float64(mySituation.GPSLastGroundTrackTime.UnixNano()/1000) / 1e6
                        m.WValid = isGPSGroundTrackValid()
                        if m.WValid </span><span class="cov0" title="0">{
                                m.W1 = mySituation.GPSGroundSpeed * math.Sin(float64(mySituation.GPSTrueCourse)*ahrs.Deg)
                                m.W2 = mySituation.GPSGroundSpeed * math.Cos(float64(mySituation.GPSTrueCourse)*ahrs.Deg)
                                if globalSettings.BMP_Sensor_Enabled &amp;&amp; globalStatus.BMPConnected </span><span class="cov0" title="0">{
                                        m.W3 = float64(mySituation.BaroVerticalSpeed * 60 / 6076.12)
                                }</span> else<span class="cov0" title="0"> {
                                        m.W3 = float64(mySituation.GPSVerticalSpeed) * 3600 / 6076.12
                                }</span>
                        }

                        // Run the AHRS calculations.
                        <span class="cov0" title="0">s.Compute(m)

                        // If we have valid AHRS info, then update mySituation.
                        mySituation.muAttitude.Lock()
                        if s.Valid() </span><span class="cov0" title="0">{
                                roll, pitch, heading = s.RollPitchHeading()
                                mySituation.AHRSRoll = roll / ahrs.Deg
                                mySituation.AHRSPitch = pitch / ahrs.Deg
                                mySituation.AHRSGyroHeading = heading
                                if !isAHRSInvalidValue(heading) </span><span class="cov0" title="0">{
                                        mySituation.AHRSGyroHeading /= ahrs.Deg
                                }</span>

                                //TODO westphae: until magnetometer calibration is performed, no mag heading
                                <span class="cov0" title="0">mySituation.AHRSMagHeading = ahrs.Invalid
                                mySituation.AHRSSlipSkid = s.SlipSkid()
                                mySituation.AHRSTurnRate = s.RateOfTurn()
                                mySituation.AHRSGLoad = s.GLoad()
                                if mySituation.AHRSGLoad &lt; mySituation.AHRSGLoadMin || mySituation.AHRSGLoadMin == 0 </span><span class="cov0" title="0">{
                                        mySituation.AHRSGLoadMin = mySituation.AHRSGLoad
                                }</span>
                                <span class="cov0" title="0">if mySituation.AHRSGLoad &gt; mySituation.AHRSGLoadMax </span><span class="cov0" title="0">{
                                        mySituation.AHRSGLoadMax = mySituation.AHRSGLoad
                                }</span>

                                <span class="cov0" title="0">mySituation.AHRSLastAttitudeTime = t</span>
                        } else<span class="cov0" title="0"> {
                                mySituation.AHRSRoll = ahrs.Invalid
                                mySituation.AHRSPitch = ahrs.Invalid
                                mySituation.AHRSGyroHeading = ahrs.Invalid
                                mySituation.AHRSMagHeading = ahrs.Invalid
                                mySituation.AHRSSlipSkid = ahrs.Invalid
                                mySituation.AHRSTurnRate = ahrs.Invalid
                                mySituation.AHRSGLoad = ahrs.Invalid
                                mySituation.AHRSGLoadMin = ahrs.Invalid
                                mySituation.AHRSGLoadMax = 0
                                mySituation.AHRSLastAttitudeTime = time.Time{}
                                s.Reset()
                        }</span>
                        <span class="cov0" title="0">mySituation.muAttitude.Unlock()

                        makeAHRSGDL90Report() // Send whether or not valid - the function will invalidate the values as appropriate
                        makeAHRSSimReport()
                        makeAHRSLevilReport()

                        // Send to AHRS debugging server.
                        if ahrswebListener != nil </span><span class="cov0" title="0">{
                                if err = ahrswebListener.Send(s.GetState(), m); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("AHRS Error: couldn't write to ahrsweb: %s\n", err)
                                        ahrswebListener = nil
                                }</span>
                        }

                        // Log it to csv for later analysis.
                        <span class="cov0" title="0">if globalSettings.AHRSLog &amp;&amp; du.NewDiskUsage("/").Usage() &lt; 0.95 </span><span class="cov0" title="0">{
                                if analysisLogger == nil </span><span class="cov0" title="0">{
                                        analysisFilename := fmt.Sprintf("sensors_%s.csv", time.Now().Format("20060102_150405"))
                                        logMap = s.GetLogMap()
                                        updateExtraLogging()
                                        analysisLogger = ahrs.NewAHRSLogger(filepath.Join(logDirf, analysisFilename), logMap)
                                }</span>

                                <span class="cov0" title="0">if analysisLogger != nil </span><span class="cov0" title="0">{
                                        updateExtraLogging()
                                        analysisLogger.Log()
                                }</span>
                        } else<span class="cov0" title="0"> {
                                analysisLogger = nil
                        }</span>
                }
        }
}

func updateExtraLogging() <span class="cov0" title="0">{
        logMap["GPSNACp"] = float64(mySituation.GPSNACp)
        logMap["GPSTrueCourse"] = mySituation.GPSTrueCourse
        logMap["GPSVerticalAccuracy"] = mySituation.GPSVerticalAccuracy
        logMap["GPSHorizontalAccuracy"] = mySituation.GPSHorizontalAccuracy
        logMap["GPSAltitudeMSL"] = mySituation.GPSAltitudeMSL
        logMap["GPSFixQuality"] = float64(mySituation.GPSFixQuality)
        logMap["BaroPressureAltitude"] = float64(mySituation.BaroPressureAltitude)
        logMap["BaroVerticalSpeed"] = float64(mySituation.BaroVerticalSpeed)
}</span>

func makeOrientationQuaternion(g [3]float64) (f *[4]float64) <span class="cov0" title="0">{
        if globalSettings.IMUMapping[0] == 0 </span><span class="cov0" title="0">{ // if unset, default to some standard orientation
                globalSettings.IMUMapping[0] = -1 // +2 for RY836AI
        }</span>

        // This is the "forward direction" chosen during the orientation process.
        <span class="cov0" title="0">var x *[3]float64 = new([3]float64)
        if globalSettings.IMUMapping[0] &lt; 0 </span><span class="cov0" title="0">{
                x[-globalSettings.IMUMapping[0]-1] = -1
        }</span> else<span class="cov0" title="0"> {
                x[+globalSettings.IMUMapping[0]-1] = +1
        }</span>

        // Normalize the gravity vector to be 1 G.
        <span class="cov0" title="0">z, _ := ahrs.MakeUnitVector(g)

        rotmat, _ := ahrs.MakeHardSoftRotationMatrix(*z, *x, [3]float64{0, 0, 1}, [3]float64{1, 0, 0})
        f = new([4]float64)
        f[0], f[1], f[2], f[3] = ahrs.RotationMatrixToQuaternion(*rotmat)
        return</span>
}

// This is used in the orientation process where the user specifies the forward and up directions.
func getMinAccelDirection() (i int, err error) <span class="cov0" title="0">{
        _, _, _, _, a1, a2, a3, _, _, _, err, _ := myIMUReader.ReadOne()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Printf("AHRS Info: sensor orientation accels %1.3f %1.3f %1.3f\n", a1, a2, a3)
        switch </span>{
        case math.Abs(a1) &gt; math.Abs(a2) &amp;&amp; math.Abs(a1) &gt; math.Abs(a3):<span class="cov0" title="0">
                if a1 &gt; 0 </span><span class="cov0" title="0">{
                        i = 1
                }</span> else<span class="cov0" title="0"> {
                        i = -1
                }</span>
        case math.Abs(a2) &gt; math.Abs(a3) &amp;&amp; math.Abs(a2) &gt; math.Abs(a1):<span class="cov0" title="0">
                if a2 &gt; 0 </span><span class="cov0" title="0">{
                        i = 2
                }</span> else<span class="cov0" title="0"> {
                        i = -2
                }</span>
        case math.Abs(a3) &gt; math.Abs(a1) &amp;&amp; math.Abs(a3) &gt; math.Abs(a2):<span class="cov0" title="0">
                if a3 &gt; 0 </span><span class="cov0" title="0">{
                        i = 3
                }</span> else<span class="cov0" title="0"> {
                        i = -3
                }</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("couldn't determine biggest accel from %1.3f %1.3f %1.3f", a1, a2, a3)</span>
        }

        <span class="cov0" title="0">return</span>
}

// CageAHRS sends a signal to the AHRSProvider that it should recalibrate and reset its level orientation.
func CageAHRS() <span class="cov0" title="0">{
        cal &lt;- "level"
}</span>

// CageAHRS sends a signal to the AHRSProvider that it should recalibrate and reset its level orientation.
func CalibrateAHRS() <span class="cov0" title="0">{
        cal &lt;- "cal"
}</span>

// ResetAHRSGLoad resets the min and max to the current G load value.
func ResetAHRSGLoad() <span class="cov0" title="0">{
        mySituation.AHRSGLoadMax = mySituation.AHRSGLoad
        mySituation.AHRSGLoadMin = mySituation.AHRSGLoad
}</span>

func updateAHRSStatus() <span class="cov0" title="0">{
        var (
                msg    uint8
                imu    bool
                ticker *time.Ticker
        )

        ticker = time.NewTicker(250 * time.Millisecond)

        for </span><span class="cov0" title="0">{
                &lt;-ticker.C
                msg = 0

                // GPS ground track valid?
                if isGPSGroundTrackValid() </span><span class="cov0" title="0">{
                        msg++
                }</span>
                // IMU is being used
                <span class="cov0" title="0">imu = globalSettings.IMU_Sensor_Enabled &amp;&amp; globalStatus.IMUConnected
                if imu </span><span class="cov0" title="0">{
                        msg += 1 &lt;&lt; 1
                }</span>
                // BMP is being used
                <span class="cov0" title="0">if (globalSettings.BMP_Sensor_Enabled &amp;&amp; globalStatus.BMPConnected) || isTempPressValid() </span><span class="cov0" title="0">{
                        msg += 1 &lt;&lt; 2
                }</span>
                // IMU is doing a calibration
                <span class="cov0" title="0">if ahrsCalibrating </span><span class="cov0" title="0">{
                        msg += 1 &lt;&lt; 3
                }</span>
                // Logging to csv
                <span class="cov0" title="0">if imu &amp;&amp; analysisLogger != nil </span><span class="cov0" title="0">{
                        msg += 1 &lt;&lt; 4
                }</span>
                <span class="cov0" title="0">mySituation.AHRSStatus = msg</span>
        }
}

func isAHRSInvalidValue(val float64) bool <span class="cov0" title="0">{
        return math.Abs(val-ahrs.Invalid) &lt; 0.01
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright (c) 2023 Adrian Batzill
// Distributable under the terms of The "BSD New" License
// that can be found in the LICENSE file, herein included
// as part of this header.
// trace.go: record all incoming messages (GPS, dump1090, ...) for future replay

package main

import (
        "compress/gzip"
        "encoding/csv"
        "log"
        "os"
        "sync"
        "time"

        "github.com/ricochet2200/go-disk-usage/du"
        "golang.org/x/exp/slices"
)

type TraceLogger struct {
        fileHandle        *os.File
        gzWriter          *gzip.Writer
        csvWriter         *csv.Writer
        fileName          string
        hasProperFilename bool
        traceMutex        sync.Mutex
        isReplaying       bool
}

const (
        CONTEXT_AIS         = "ais"
        CONTEXT_NMEA        = "nmea"
        CONTEXT_APRS        = "aprs"
        CONTEXT_OGN_RX      = "ogn-rx"
        CONTEXT_DUMP1090    = "dump1090"
        CONTEXT_GODUMP978   = "godump978"
        CONTEXT_LOWPOWERUAT = "lowpower_uat"
)

var TraceLog TraceLogger

// At startup, we usually don't know the precise time to generate a good filename.
// Therefore, once we receive our first valid timestamp, we will rename the file to something more appropriate
func (tracer *TraceLogger) OnTimestamp(ts time.Time) <span class="cov0" title="0">{
        tracer.traceMutex.Lock()
        defer tracer.traceMutex.Unlock()
        if tracer.fileHandle == nil || tracer.hasProperFilename </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">formatted := ts.Format(time.RFC3339)
        fname := "/var/log/stratux/" + formatted + "_trace.txt.gz"
        if formatted != fname </span><span class="cov0" title="0">{
                err := os.Rename(tracer.fileName, fname)
                if err == nil </span><span class="cov0" title="0">{
                        tracer.fileName = fname
                }</span>
        }
        <span class="cov0" title="0">tracer.hasProperFilename = true</span>
}

// Context for now may be one of
func (tracer *TraceLogger) Record(context string, data []byte) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                tracer.traceMutex.Lock()
                defer tracer.traceMutex.Unlock()
                if tracer.fileHandle == nil || tracer.isReplaying </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">ts := stratuxClock.Time.Format(time.RFC3339Nano)
                tracer.csvWriter.Write([]string{ts, context, string(data)})</span>
        }()
}

func (tracer *TraceLogger) Flush() <span class="cov0" title="0">{
        tracer.traceMutex.Lock()
        defer tracer.traceMutex.Unlock()
        if tracer.fileHandle != nil </span><span class="cov0" title="0">{
                tracer.gzWriter.Flush()
                tracer.fileHandle.Sync()
        }</span>
}

func (tracer *TraceLogger) Start() <span class="cov0" title="0">{
        tracer.traceMutex.Lock()
        defer tracer.traceMutex.Unlock()
        ts := time.Now().UTC().Format(time.RFC3339)
        os.MkdirAll("/var/log/stratux", os.ModePerm)
        fname := "/var/log/stratux/" + ts + "_trace.txt.gz"

        fileHandle, err := os.OpenFile(fname, os.O_CREATE|os.O_WRONLY, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to open trace log file: %s", err.Error())
                return
        }</span>
        <span class="cov0" title="0">tracer.gzWriter = gzip.NewWriter(fileHandle)
        tracer.csvWriter = csv.NewWriter(tracer.gzWriter)
        tracer.fileHandle = fileHandle
        tracer.fileName = fname
        tracer.hasProperFilename = false</span>
}

func (tracer *TraceLogger) Stop() <span class="cov0" title="0">{
        tracer.traceMutex.Lock()
        defer tracer.traceMutex.Unlock()
        tracer.csvWriter.Flush()
        tracer.gzWriter.Close()
        tracer.fileHandle.Close()
        tracer.fileHandle = nil
        tracer.csvWriter = nil
        tracer.gzWriter = nil
}</span>

func (tracer *TraceLogger) IsActive() bool <span class="cov0" title="0">{
        return tracer.fileHandle != nil
}</span>

func (tracer *TraceLogger) IsReplaying() bool <span class="cov0" title="0">{
        return tracer.isReplaying
}</span>

func (tracer *TraceLogger) Replay(fname string, speedMultiplier float64, traceSkip int64, msgtypes []string) <span class="cov0" title="0">{
        fhandle, err := os.Open(fname)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to open trace file %s: %s", fname, err.Error())
                return
        }</span>
        <span class="cov0" title="0">tracer.isReplaying = true
        gzReader, err := gzip.NewReader(fhandle)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to open gzip stream for file %s: %s", fname, err.Error())
                return
        }</span>
        <span class="cov0" title="0">startTs := time.Time{}.Add(time.Duration(traceSkip) * time.Minute)
        csvReader := csv.NewReader(gzReader)
        for </span><span class="cov0" title="0">{
                fields, err := csvReader.Read()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Trace replay stopped: %s", err)
                        break</span>
                }
                <span class="cov0" title="0">if len(fields) != 3 </span><span class="cov0" title="0">{
                        log.Printf("Failed to parse trace line")
                        continue</span>
                }
                <span class="cov0" title="0">context := fields[1]
                if len(msgtypes) &gt; 0 &amp;&amp; !slices.Contains(msgtypes, context) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">ts, err := time.Parse(time.RFC3339Nano, fields[0])
                if ts.Before(startTs) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">ts = ts.Add(-time.Duration(traceSkip) * time.Minute)

                millis := float64(ts.Sub(time.Time{}).Milliseconds()) / speedMultiplier
                ts = time.Time{}.Add(time.Duration(millis) * time.Millisecond)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to parse trace log timestamp %s", fields[0])
                        continue</span>
                }
                <span class="cov0" title="0">injectTraceMessage(context, ts, []byte(fields[2]))</span>
        }
}

func injectTraceMessage(context string, ts time.Time, data []byte) <span class="cov0" title="0">{
        toWait := float64(ts.Sub(stratuxClock.Time).Nanoseconds())
        time.Sleep(time.Duration(toWait) * time.Nanosecond)

        if context == CONTEXT_AIS </span><span class="cov0" title="0">{
                parseAisMessage(string(data))
        }</span> else<span class="cov0" title="0"> if context == CONTEXT_NMEA </span><span class="cov0" title="0">{
                globalStatus.GPS_connected = true
                processNMEALineLow(string(data), true)
        }</span> else<span class="cov0" title="0"> if context == CONTEXT_APRS </span><span class="cov0" title="0">{
                parseAprsMessage(string(data), true)
        }</span> else<span class="cov0" title="0"> if context == CONTEXT_OGN_RX </span><span class="cov0" title="0">{
                parseOgnMessage(string(data), true)
        }</span> else<span class="cov0" title="0"> if context == CONTEXT_DUMP1090 </span><span class="cov0" title="0">{
                parseDump1090Message(string(data))
        }</span> else<span class="cov0" title="0"> if context == CONTEXT_GODUMP978 </span><span class="cov0" title="0">{
                handleUatMessage(string(data))
        }</span> else<span class="cov0" title="0"> if context == CONTEXT_LOWPOWERUAT </span><span class="cov0" title="0">{
                processRadioMessage(data)
        }</span>
}

func traceLoggerWatchdog() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if TraceLog.isReplaying </span><span class="cov0" title="0">{
                        time.Sleep(1 * time.Second)
                        continue</span>
                }

                <span class="cov0" title="0">if TraceLog.IsActive() </span><span class="cov0" title="0">{
                        usage := du.NewDiskUsage("/")
                        if usage.Free() &lt; 1024*1024*50 </span><span class="cov0" title="0">{
                                // less than 50mb free? deactivate
                                log.Printf("Space running out - disable trace logging for this run")
                                TraceLog.Stop()
                                break</span>
                        }
                }

                <span class="cov0" title="0">if TraceLog.IsActive() &amp;&amp; !globalSettings.TraceLog </span><span class="cov0" title="0">{
                        TraceLog.Stop()
                }</span> else<span class="cov0" title="0"> if !TraceLog.IsActive() &amp;&amp; globalSettings.TraceLog </span><span class="cov0" title="0">{
                        TraceLog.Start()
                }</span>
                <span class="cov0" title="0">time.Sleep(1 * time.Second)
                TraceLog.Flush()</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package main

import (
        "fmt"
        "log"
        "strconv"
        "strings"
        "time"

        "github.com/tarm/serial"
)

/*
        Copyright (c) 2024 Adrian Batzill
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        ---
        tracker.go: Implements handling and configuration of the various tracker devices (OGN Tracker, GXAirCom, SoftRF)

        TODO: SoftRF dongle is not yet considered a tracker, since we use the Moshe-Braner SoftRF fork
*/

var typeMappingOgn2Gx = [][]int{
        {1, 4},  // (Motor)glider
        {8, 5},  // Powered
        {3, 6},  // Helicopter
        {6, 2},  // Hang glider
        {7, 1},  // Paraglider
        {11, 3}, // Balloon
        {13, 7}, // UAV

        {2, 5},  // Tow-&gt;Powered
        {4, 1},  // Parachute-&gt;Paraglider
        {5, 5},  // Drop plane-&gt;Powered
        {9, 5},  // Jet -&gt; Powered
        {10, 0}, // Ufo -&gt; Other
        {12, 3}, // Airship -&gt; Balloon
        {14, 0}, // Ground support
        {15, 0}, // Static object
}

var typeMappingOgn2SoftRF = [][]int{
        {1, 1},   // (Motor)glider
        {2, 2},   // Tow
        {3, 3},   // Helicopter
        {6, 6},   // Hang glider
        {7, 7},   // Paraglider
        {8, 8},   // Powered
        {11, 11}, // Balloon
        {13, 13}, // UAV
        {14, 16}, // Ground support/winch
        {15, 15}, // Static object

        {4, 7},   // Parachute-&gt;Paraglider
        {5, 8},   // Drop plane-&gt;Powered
        {9, 8},   // Jet -&gt; Powered
        {10, 8},  // Ufo -&gt; Powered
        {12, 11}, // Airship -&gt; Balloon
}

func mapAircraftType(mapping [][]int, forward bool, acType int) int <span class="cov8" title="32">{
        for _, m := range mapping </span><span class="cov10" title="68">{
                if forward </span><span class="cov8" title="38">{
                        if m[0] == acType </span><span class="cov6" title="14">{
                                return m[1]
                        }</span>
                } else<span class="cov8" title="30"> {
                        if m[1] == acType </span><span class="cov5" title="10">{
                                return m[0]
                        }</span>
                }
        }
        <span class="cov5" title="8">return -1</span>
}

// Main interface that all tracker implementations need to implement
type Tracker interface {
        initNewConnection(serialPort *serial.Port)
        onNmea(serialPort *serial.Port, nmea []string) bool
        gpsTimeOffsetPps() time.Duration
        getGpsHardwareType() uint
        isDetected() bool
        isConfigRead() bool
        // How long should we wait after a write operation until we read back data
        writeReadDelay() time.Duration
        // Done on every new connection, return true if something was written
        writeInitialConfig(serialPort *serial.Port) bool

        requestTrackerConfig(serialPort *serial.Port)
        // Done only when user hits configure button, return true if something was written
        writeConfigFromSettings(serialPort *serial.Port) bool
}

func formatOgnTrackerConfigString() string <span class="cov0" title="0">{
        msg := fmt.Sprintf("$POGNS,Address=0x%s,AddrType=%d,AcftType=%d,Pilot=%s,Reg=%s,TxPower=%d,Hard=STX,Soft=%s",
                globalSettings.OGNAddr, globalSettings.OGNAddrType, globalSettings.OGNAcftType, globalSettings.OGNPilot, globalSettings.OGNReg, globalSettings.OGNTxPower, stratuxVersion[1:])
        msg = appendNmeaChecksum(msg)
        return msg + "\r\n"
}</span>

type OgnTracker struct {
        detected      bool
        trackerConfig []string
}

type GxAirCom struct {
        detected      bool
        trackerConfig []string
        // If we suspect GX, but don't know for sure, we send exactly one blind config request. If it responds, we know. Otherwise, we stop.
        blindAskedForConfig bool
}

type SoftRF struct {
        detected bool
        settings map[string]string
}

func (tracker *OgnTracker) initNewConnection(serialPort *serial.Port) <span class="cov0" title="0">{
        tracker.detected = false
        tracker.trackerConfig = nil
}</span>

func (tracker *OgnTracker) onNmea(serialPort *serial.Port, nmea []string) bool <span class="cov0" title="0">{
        if nmea[0] == "POGNR" </span><span class="cov0" title="0">{
                tracker.detected = true
                return true
        }</span>

        <span class="cov0" title="0">if nmea[0] == "POGNS" </span><span class="cov0" title="0">{
                tracker.trackerConfig = nmea

                // Tracker notified us of restart (crashed?) -&gt; ensure we configure it again
                if len(nmea) == 2 &amp;&amp; nmea[1] == "SysStart" </span><span class="cov0" title="0">{
                        tracker.writeInitialConfig(serialPort)
                        return true
                }</span>
                // OGN tracker sent us its configuration
                <span class="cov0" title="0">log.Printf("Received OGN Tracker configuration: " + strings.Join(nmea, ","))
                oldAddr := globalSettings.OGNAddr
                for i := 1; i &lt; len(nmea); i++ </span><span class="cov0" title="0">{
                        kv := strings.SplitN(nmea[i], "=", 2)
                        if len(kv) &lt; 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if kv[0] == "Address" </span><span class="cov0" title="0">{
                                addr, _ := strconv.ParseUint(kv[1], 0, 32)
                                globalSettings.OGNAddr = strings.ToUpper(fmt.Sprintf("%x", addr))
                        }</span> else<span class="cov0" title="0"> if kv[0] == "AddrType" </span><span class="cov0" title="0">{
                                addrtype, _ := strconv.ParseInt(kv[1], 0, 8)
                                globalSettings.OGNAddrType = int(addrtype)
                        }</span> else<span class="cov0" title="0"> if kv[0] == "AcftType" </span><span class="cov0" title="0">{
                                acfttype, _ := strconv.ParseInt(kv[1], 0, 8)
                                globalSettings.OGNAcftType = int(acfttype)
                        }</span> else<span class="cov0" title="0"> if kv[0] == "Pilot" </span><span class="cov0" title="0">{
                                globalSettings.OGNPilot = kv[1]
                        }</span> else<span class="cov0" title="0"> if kv[0] == "Reg" </span><span class="cov0" title="0">{
                                globalSettings.OGNReg = kv[1]
                        }</span> else<span class="cov0" title="0"> if kv[0] == "TxPower" </span><span class="cov0" title="0">{
                                pwr, _ := strconv.ParseInt(kv[1], 10, 16)
                                globalSettings.OGNTxPower = int(pwr)
                        }</span>
                }
                // OGN Tracker can change its address arbitrarily. However, if it does,
                // ownship detection would fail for the old target. Therefore we remove the old one from the traffic list
                <span class="cov0" title="0">if oldAddr != globalSettings.OGNAddr &amp;&amp; globalSettings.OGNAddrType == 0 </span><span class="cov0" title="0">{
                        globalStatus.OGNPrevRandomAddr = oldAddr
                        oldAddrInt, _ := strconv.ParseUint(oldAddr, 16, 32)
                        removeTarget(uint32(oldAddrInt))
                        // potentially other address type before
                        removeTarget(uint32((1 &lt;&lt; 24) | oldAddrInt))
                }</span>
        }
        <span class="cov0" title="0">return false</span>

}
func (tracker *OgnTracker) gpsTimeOffsetPps() time.Duration <span class="cov0" title="0">{
        return 200 * time.Millisecond
}</span>

func (tracker *OgnTracker) getGpsHardwareType() uint <span class="cov0" title="0">{
        return GPS_TYPE_OGNTRACKER

}</span>
func (tracker *OgnTracker) isDetected() bool <span class="cov0" title="0">{
        return tracker.detected
}</span>

func (tracker *OgnTracker) isConfigRead() bool <span class="cov0" title="0">{
        return tracker.trackerConfig != nil
}</span>

func (tracker *OgnTracker) writeReadDelay() time.Duration <span class="cov0" title="0">{
        return 1 * time.Second
}</span>

func (tracker *OgnTracker) writeInitialConfig(serialPort *serial.Port) bool <span class="cov0" title="0">{
        serialPort.Write([]byte(appendNmeaChecksum("$POGNS,NavRate=5") + "\r\n"))
        // Configuration for OGN Tracker T-Beam is similar to normal Ublox config
        writeUblox8ConfigCommands(serialPort)
        writeUbloxGenericCommands(5, serialPort)
        return true
}</span>

func (tracker *OgnTracker) requestTrackerConfig(serialPort *serial.Port) <span class="cov0" title="0">{
        serialPort.Write([]byte(appendNmeaChecksum("$POGNS") + "\r\n"))
}</span>

func (tracker *OgnTracker) writeConfigFromSettings(serialPort *serial.Port) bool <span class="cov0" title="0">{
        cfg := formatOgnTrackerConfigString()
        log.Printf("Configuring OGN Tracker: " + cfg)

        serialPort.Write([]byte(cfg))
        tracker.requestTrackerConfig(serialPort) // re-read settings from tracker
        return true
}</span>

func (tracker *GxAirCom) initNewConnection(serialPort *serial.Port) <span class="cov0" title="0">{
        tracker.detected = false
        tracker.trackerConfig = nil
        tracker.blindAskedForConfig = false
}</span>

func (tracker *GxAirCom) onNmea(serialPort *serial.Port, nmea []string) bool <span class="cov0" title="0">{
        // Only sent by GxAirCom tracker. We use this to detect that GxAirCom tracker is connected and configure it as needed
        if nmea[0] == "PFLAV" &amp;&amp; nmea[4] == "GXAircom" </span><span class="cov0" title="0">{
                tracker.detected = true
                return true
        }</span>
        <span class="cov0" title="0">if nmea[0] == "LK8EX1" &amp;&amp; !tracker.blindAskedForConfig </span><span class="cov0" title="0">{
                // Indicates potentially GxAirCom.. send a blind tracker config request. If it responds, we know for sure
                tracker.blindAskedForConfig = true
                tracker.requestTrackerConfig(serialPort)
                return true
        }</span>

        <span class="cov0" title="0">if nmea[0] == "PGXCF" &amp;&amp; nmea[1] == "1" </span><span class="cov0" title="0">{
                // $PGXCF,&lt;version&gt;,&lt;Output Serial&gt;,&lt;eMode&gt;,&lt;eOutputVario&gt;,&lt;output Fanet&gt;,&lt;output GPS&gt;,&lt;output FLARM&gt;,&lt;customGPSConfig&gt;,&lt;Aircraft Type (hex)&gt;,&lt;Address Type&gt;,&lt;Address (hex)&gt;,&lt;Pilot Name&gt;
                //  0      1         2               3       4              5            6              7                 8                     9              10              11             12
                log.Printf("Received GxAirCom Tracker configuration: " + strings.Join(nmea, ","))
                tracker.detected = true
                tracker.trackerConfig = nmea

                GXAcftType, _ := strconv.ParseInt(nmea[9], 16, 0)
                acftType := mapAircraftType(typeMappingOgn2Gx, false, int(GXAcftType))
                globalSettings.OGNAcftType = acftType

                GXAddrType, _ := strconv.Atoi(nmea[10])
                globalSettings.OGNAddrType = GXAddrType
                globalSettings.OGNAddr = nmea[11]
                globalSettings.OGNPilot = nmea[12]

                return true
        }</span>

        <span class="cov0" title="0">return false</span>

}
func (tracker *GxAirCom) gpsTimeOffsetPps() time.Duration <span class="cov0" title="0">{
        return 130 * time.Millisecond
}</span>

func (tracker *GxAirCom) getGpsHardwareType() uint <span class="cov0" title="0">{
        return GPS_TYPE_GXAIRCOM

}</span>
func (tracker *GxAirCom) isDetected() bool <span class="cov0" title="0">{
        return tracker.detected
}</span>

func (tracker *GxAirCom) isConfigRead() bool <span class="cov0" title="0">{
        return tracker.trackerConfig != nil
}</span>

func (tracker *GxAirCom) writeReadDelay() time.Duration <span class="cov0" title="0">{
        return 15 * time.Second
}</span>

func (tracker *GxAirCom) writeInitialConfig(serialPort *serial.Port) bool <span class="cov0" title="0">{
        if tracker.trackerConfig[2] != "1" || tracker.trackerConfig[5] == "0" || tracker.trackerConfig[6] == "0" || tracker.trackerConfig[7] == "0" || tracker.trackerConfig[8] == "0" </span><span class="cov0" title="0">{
                tracker.writeConfigFromSettings(serialPort) // force correct settings
                return true
        }</span> else<span class="cov0" title="0"> {
                log.Printf("GxAirCom tracker configuration ok!")
                return false
        }</span>
}

func (tracker *GxAirCom) requestTrackerConfig(serialPort *serial.Port) <span class="cov0" title="0">{
        serialPort.Write([]byte(appendNmeaChecksum("$PGXCF,?") + "\r\n")) // Request configuration
}</span>

func (tracker *GxAirCom) writeConfigFromSettings(serialPort *serial.Port) bool <span class="cov0" title="0">{
        // GX Addr type: 1=ICAO 2=FLARM
        addrType := globalSettings.OGNAddrType
        if addrType != 1 </span><span class="cov0" title="0">{
                addrType = 2 // all other address types to FLARM = non-ICAO
        }</span>

        <span class="cov0" title="0">acftType := mapAircraftType(typeMappingOgn2Gx, true, globalSettings.OGNAcftType)

        // $PGXCF,&lt;version&gt;,&lt;Output Serial&gt;,&lt;eMode&gt;,&lt;eOutputVario&gt;,&lt;output Fanet&gt;,&lt;output GPS&gt;,&lt;output FLARM&gt;,&lt;customGPSConfig&gt;,&lt;Aircraft Type (hex)&gt;,&lt;Address Type&gt;,&lt;Address (hex)&gt;,&lt;Pilot Name&gt;
        //  0      1         2               3              4              5            6              7                 8                     9              10              11      12
        requiredSentence := fmt.Sprintf("$PGXCF,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%s,%s",
                1, // PGXCF Version
                1, // Serial out
                0, // Airmode
                1, // Vario disabled // 0=noVario, 1= LK8EX1, 2=LXPW, we use it to try to identify GxAirCom
                1, // Fanet
                1, // GPS
                1, // Flarm
                1, // Stratux NMEA
                acftType,
                addrType,
                globalSettings.OGNAddr,
                globalSettings.OGNPilot)

        fullSentence := appendNmeaChecksum(requiredSentence)
        log.Printf("Configuring GxAirCom Tracker with: " + fullSentence)
        serialPort.Write([]byte(fullSentence + "\r\n")) // Set configuration
        return true</span>
}

func (tracker *SoftRF) initNewConnection(serialPort *serial.Port) <span class="cov0" title="0">{
        tracker.detected = false
        tracker.settings = make(map[string]string)
}</span>

func (tracker *SoftRF) onNmea(serialPort *serial.Port, nmea []string) bool <span class="cov0" title="0">{
        if nmea[0] == "PSRFH" </span><span class="cov0" title="0">{
                if tracker.detected &amp;&amp; !tracker.isConfigRead() </span><span class="cov0" title="0">{
                        // sometimes SoftRF doesn't seem to respond to settings request if we are too early after boot.. retry if we were already detected before but still don't have a config
                        tracker.requestTrackerConfig(serialPort)
                }</span>
                <span class="cov0" title="0">tracker.detected = true
                return true</span>
        }

        // See output of $PSRFS,0,?*4B
        <span class="cov0" title="0">if nmea[0] == "PSRFS" </span><span class="cov0" title="0">{
                key, value := nmea[2], nmea[3]
                log.Printf("Received SoftRF config %s=%s", key, value)
                tracker.settings[key] = value
                if key == "acft_type" </span><span class="cov0" title="0">{
                        acType, _ := strconv.Atoi(value)
                        acType = mapAircraftType(typeMappingOgn2SoftRF, false, acType)
                        globalSettings.OGNAcftType = acType
                }</span> else<span class="cov0" title="0"> if key == "id_method" </span><span class="cov0" title="0">{
                        globalSettings.OGNAddrType, _ = strconv.Atoi(value)
                }</span> else<span class="cov0" title="0"> if key == "aircraft_id" </span><span class="cov0" title="0">{
                        globalSettings.OGNAddr = value
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">return false</span>

}
func (tracker *SoftRF) gpsTimeOffsetPps() time.Duration <span class="cov0" title="0">{
        return 200 * time.Millisecond
}</span>

func (tracker *SoftRF) getGpsHardwareType() uint <span class="cov0" title="0">{
        return GPS_TYPE_SOFTRF

}</span>
func (tracker *SoftRF) isDetected() bool <span class="cov0" title="0">{
        return tracker.detected
}</span>

func (tracker *SoftRF) isConfigRead() bool <span class="cov0" title="0">{
        return len(tracker.settings) &gt;= 5 // need at least or 5 main settings: acft type, id method and id, as well as nmea1/2 mode
}</span>

func (tracker *SoftRF) writeReadDelay() time.Duration <span class="cov0" title="0">{
        return 15 * time.Second // SoftRF seems to take a while until it responds to config read after boot..?
}</span>

func (tracker *SoftRF) writeInitialConfig(serialPort *serial.Port) bool <span class="cov0" title="0">{
        if !tracker.isConfigRead() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">changed := false
        if tracker.settings["nmea_g"] != "0F" </span><span class="cov0" title="0">{
                msg := appendNmeaChecksum("$PSRFS,0,nmea_g,0F") + "\r\n"
                log.Printf("Configure SoftRF: %s", msg)
                serialPort.Write([]byte(msg))
                changed = true
        }</span>
        <span class="cov0" title="0">if tracker.settings["nmea2_g"] != "0F" </span><span class="cov0" title="0">{
                msg := appendNmeaChecksum("$PSRFS,0,nmea2_g,0F") + "\r\n"
                log.Printf("Configure SoftRF: %s", msg)
                serialPort.Write([]byte(msg))
                changed = true
        }</span>
        <span class="cov0" title="0">if changed </span><span class="cov0" title="0">{
                serialPort.Write([]byte(appendNmeaChecksum("$PSRFC,SAV") + "\r\n"))
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (tracker *SoftRF) requestTrackerConfig(serialPort *serial.Port) <span class="cov0" title="0">{
        serialPort.Write([]byte(appendNmeaChecksum("$PSRFS,0,nmea_g,?") + "\r\n"))
        serialPort.Write([]byte(appendNmeaChecksum("$PSRFS,0,nmea2_g,?") + "\r\n"))
        serialPort.Write([]byte(appendNmeaChecksum("$PSRFS,0,acft_type,?") + "\r\n"))
        serialPort.Write([]byte(appendNmeaChecksum("$PSRFS,0,aircraft_id,?") + "\r\n"))
        serialPort.Write([]byte(appendNmeaChecksum("$PSRFS,0,id_method,?") + "\r\n"))
}</span>

func (tracker *SoftRF) writeConfigFromSettings(serialPort *serial.Port) bool <span class="cov0" title="0">{
        if !tracker.isConfigRead() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">acType := strconv.Itoa(mapAircraftType(typeMappingOgn2SoftRF, true, globalSettings.OGNAcftType))
        addrType := strconv.Itoa(globalSettings.OGNAddrType)
        addr := globalSettings.OGNAddr

        var messages []string

        if s, ok := tracker.settings["acft_type"]; !ok || acType != s </span><span class="cov0" title="0">{
                messages = append(messages, appendNmeaChecksum("$PSRFS,0,acft_type,"+acType)+"\r\n")
        }</span>
        <span class="cov0" title="0">if s, ok := tracker.settings["id_method"]; !ok || addrType != s </span><span class="cov0" title="0">{
                messages = append(messages, appendNmeaChecksum("$PSRFS,0,id_method,"+addrType)+"\r\n")
        }</span>
        <span class="cov0" title="0">if s, ok := tracker.settings["aircraft_id"]; !ok || addr != s </span><span class="cov0" title="0">{
                messages = append(messages, appendNmeaChecksum("$PSRFS,0,aircraft_id,"+addr)+"\r\n")
        }</span>

        <span class="cov0" title="0">for _, msg := range messages </span><span class="cov0" title="0">{
                log.Printf("Configure SoftRF: %s", msg)
                serialPort.Write([]byte(msg))
        }</span>

        <span class="cov0" title="0">if len(messages) &gt; 0 </span><span class="cov0" title="0">{
                serialPort.Write([]byte(appendNmeaChecksum("$PSRFC,SAV") + "\r\n")) // Finally reboot
        }</span>

        <span class="cov0" title="0">return len(messages) &gt; 0</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
        Copyright (c) 2015-2016 Christopher Young
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        traffic.go: Target management, UAT downlink message processing, 1090ES source input, GDL90 traffic reports.
*/

package main

import (
        "bufio"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "log"
        "math"
        "net"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/stratux/stratux/common"
)

//-0b2b48fe3aef1f88621a0856110a31c01105c4e6c4e6c40a9a820300000000000000;rs=7;

/*

HDR:
 MDB Type:          1
 Address:           2B48FE (TIS-B track file address)
SV:
 NIC:               6
 Latitude:          +41.4380
 Longitude:         -84.1056
 Altitude:          2300 ft (barometric)
 N/S velocity:      -65 kt
 E/W velocity:      -98 kt
 Track:             236
 Speed:             117 kt
 Vertical rate:     0 ft/min (from barometric altitude)
 UTC coupling:      no
 TIS-B site ID:     1
MS:
 Emitter category:  No information
 Callsign:          unavailable
 Emergency status:  No emergency
 UAT version:       2
 SIL:               2
 Transmit MSO:      38
 NACp:              8
 NACv:              1
 NICbaro:           0
 Capabilities:
 Active modes:
 Target track type: true heading
AUXSV:
 Sec. altitude:     unavailable

*/

const (
        TRAFFIC_SOURCE_1090ES = 1
        TRAFFIC_SOURCE_UAT    = 2
        TRAFFIC_SOURCE_OGN    = 4
        TRAFFIC_SOURCE_AIS    = 8
        TARGET_TYPE_MODE_S    = 0
        TARGET_TYPE_ADSB      = 1
        TARGET_TYPE_ADSR      = 2
        // Assign next type to UAT messages with address qualifier == 2
        // (code corresponds to any UAT GBT targets with Mode S addresses.
        // These will be displayed with the airplane icon on the traffic UI page.
        // If we see a proper emitter category and NIC &gt; 7, they'll be reassigned to TYPE_ADSR.
        TARGET_TYPE_TISB_S = 3
        TARGET_TYPE_TISB   = 4
        TARGET_TYPE_AIS    = 5
)

type TrafficInfo struct {
        Icao_addr           uint32
        Reg                 string    // Registration. Calculated from Icao_addr for civil aircraft of US registry.
        Tail                string    // Callsign. Transmitted by aircraft.
        Emitter_category    uint8     // Formatted using GDL90 standard, e.g. in a Mode ES report, A7 becomes 0x07, B0 becomes 0x08, etc.
        SurfaceVehicleType  uint16    // Type of service vehicle (when Emitter_category==18) 0..255 is reserved for AIS vessels
        OnGround            bool      // Air-ground status. On-ground is "true".
        Addr_type           uint8     // UAT address qualifier. Used by GDL90 format, so translations for ES TIS-B/ADS-R are needed.
        TargetType          uint8     // types decribed in const above
        SignalLevel         float64   // Signal level, dB RSSI.
        SignalLevelHist     []float64 // last 8 values. For 1090ES we store the last 8 values here. SignalLevel will then become the minimum of these to get more stable data with antenna diversity
        Squawk              int       // Squawk code
        Position_valid      bool      //TODO: set when position report received. Unset after n seconds?
        Lat                 float32   // decimal common.Degrees, north positive
        Lng                 float32   // decimal common.Degrees, east positive
        Alt                 int32     // Pressure altitude, feet
        GnssDiffFromBaroAlt int32     // GNSS altitude above WGS84 datum. Reported in TC 20-22 messages
        AltIsGNSS           bool      // Pressure alt = 0; GNSS alt = 1
        NIC                 int       // Navigation Integrity Category.
        NACp                int       // Navigation Accuracy Category for Position.
        Track               float32   // common.Degrees true
        TurnRate            float32   // Turn rate in deg/sec (negative = turning left, positive = right)
        Speed               uint16    // knots
        Speed_valid         bool      // set when speed report received.
        Vvel                int16     // feet per minute
        Timestamp           time.Time // timestamp of traffic message, UTC
        PriorityStatus      uint8     // Emergency or priority code as defined in GDL90 spec, DO-260B (Type 28 msg) and DO-282B

        // Parameters starting at 'Age' are calculated from last message receipt on each call of sendTrafficUpdates().
        // Mode S transmits position and track in separate messages, and altitude can also be
        // received from interrogations.
        Age                  float64   // Age of last valid position fix or last Mode-S transmission, seconds ago.
        AgeLastAlt           float64   // Age of last altitude message, seconds ago.
        Last_seen            time.Time // Time of last position update (stratuxClock) or Mode-S transmission. Used for timing out expired data.
        Last_alt             time.Time // Time of last altitude update (stratuxClock).
        Last_GnssDiff        time.Time // Time of last GnssDiffFromBaroAlt update (stratuxClock).
        Last_GnssDiffAlt     int32     // Altitude at last GnssDiffFromBaroAlt update.
        Last_speed           time.Time // Time of last velocity and track update (stratuxClock).
        Last_source          uint8     // Last frequency on which this target was received.
        ExtrapolatedPosition bool      //TODO: True if Stratux is "coasting" the target from last known position.
        Last_extrapolation   time.Time
        AgeExtrapolation     float64
        Lat_fix              float32 // Last real, non-extrapolated latitude
        Lng_fix              float32 // Last real, non-extrapolated longitude
        Alt_fix              int32   // Last real, non-extrapolated altitude

        BearingDist_valid       bool      // set when bearing and distance information is valid
        Bearing                 float64   // Bearing in common.Degrees true to traffic from ownship, if it can be calculated. Units: common.Degrees.
        Distance                float64   // Distance to traffic from ownship, if it can be calculated. Units: meters.
        DistanceEstimated       float64   // Estimated distance of the target if real distance can't be calculated, Estimated from signal strength with exponential smoothing.
        DistanceEstimatedLastTs time.Time // Used to compute moving average
        ReceivedMsgs            uint64    // Number of messages received by this aircraft
        IsStratux               bool      // Target is equipped with a Stratux that transmits via OGN tracker
        //FIXME: Rename variables for consistency, especially "Last_".
}

type dump1090Data struct {
        Icao_addr           uint32
        DF                  int     // Mode S downlink format.
        CA                  int     // Lowest 3 bits of first byte of Mode S message (DF11 and DF17 capability; DF18 control field, zero for all other DF types)
        TypeCode            int     // Mode S type code
        SubtypeCode         int     // Mode S subtype code
        SBS_MsgType         int     // type of SBS message (used in "old" 1090 parsing)
        SignalLevel         float64 // Decimal RSSI (0-1 nominal) as reported by dump1090-mutability. Convert to dB RSSI before setting in TrafficInfo.
        Tail                *string
        Squawk              *int // 12-bit squawk code in octal format
        Emitter_category    *int
        OnGround            *bool
        Lat                 *float32
        Lng                 *float32
        Position_valid      bool
        NACp                *int
        Alt                 *int
        AltIsGNSS           bool   //
        GnssDiffFromBaroAlt *int16 // GNSS height above baro altitude in feet; valid range is -3125 to 3125. +/- 3138 indicates larger difference.
        Vvel                *int16
        Speed_valid         bool
        Speed               *uint16
        Track               *uint16
        Timestamp           time.Time // time traffic last seen, UTC
}

type esmsg struct {
        TimeReceived time.Time
        Data         string
}

var traffic map[uint32]TrafficInfo
var trafficMutex *sync.Mutex
var seenTraffic map[uint32]bool // Historical list of all ICAO addresses seen.

var OwnshipTrafficInfo TrafficInfo

func convertFeetToMeters(feet float32) float32 <span class="cov4" title="8">{
        return feet * 0.3048
}</span>

func convertMetersToFeet(meters float32) float32 <span class="cov3" title="4">{
        return meters / 0.3048
}</span>

func cleanupOldEntries() <span class="cov3" title="4">{
        for key, ti := range traffic </span><span class="cov3" title="5">{

                if ti.Last_source != TRAFFIC_SOURCE_AIS &amp;&amp; stratuxClock.Since(ti.Last_seen).Seconds() &gt; 60 </span><span class="cov1" title="1">{ // keep it in the database for up to 60 seconds, so we don't lose tail number, etc...
                        delete(traffic, key)
                }</span>

                <span class="cov3" title="5">if ti.Last_source == TRAFFIC_SOURCE_AIS &amp;&amp; stratuxClock.Since(ti.Last_seen).Seconds() &gt; 60*15 </span><span class="cov1" title="1">{ // keep it in the database for up to 15 minutes, so we don't lose tail number, etc...
                        delete(traffic, key)
                }</span>
        }
}

func removeTarget(id uint32) <span class="cov2" title="2">{
        trafficMutex.Lock()
        defer trafficMutex.Unlock()
        if val, ok := traffic[id]; ok </span><span class="cov1" title="1">{
                // Make sure the web interface times it out..
                val.Age = 60
                val.Position_valid = false
                registerTrafficUpdate(val)
                delete(traffic, id)
        }</span>
}

// Checks if the given TrafficInfo is our ownship. As the user can specify multiple ownship
// hex codes, this is able to smartly identify if it really is our ownship.
// If the ti is very close and at same altitude, it is considered to be us
// If it has no position information, we will not take it as ownship, but ignore its data (no mode-s detection for everything that is configured as ownship)
func isOwnshipTrafficInfo(ti TrafficInfo) (isOwnshipInfo bool, shouldIgnore bool) <span class="cov5" title="11">{
        // First, check if this is our own OGN tracker

        if (globalStatus.GPS_detected_type &amp; 0x0f) == GPS_TYPE_OGNTRACKER </span><span class="cov2" title="3">{
                ognTrackerCodeInt, _ := strconv.ParseUint(globalSettings.OGNAddr, 16, 32)
                prevTrackerCodeInt, _ := strconv.ParseUint(globalStatus.OGNPrevRandomAddr, 16, 32)
                if uint32(ognTrackerCodeInt) == ti.Icao_addr || uint32(prevTrackerCodeInt) == ti.Icao_addr </span><span class="cov2" title="3">{
                        isOwnshipInfo = !isGPSValid() // only use OGN tracker as ownship position if we are not equipped with a GPS..
                        shouldIgnore = true
                        return
                }</span>
        }

        <span class="cov4" title="8">codes := strings.Split(globalSettings.OwnshipModeS, ",")
        shouldIgnore = false

        for _, ownCode := range codes </span><span class="cov4" title="9">{
                ownCodeInt, _ := strconv.ParseInt(strings.Trim(ownCode, " "), 16, 32)
                if uint32(ownCodeInt) == ti.Icao_addr </span><span class="cov4" title="7">{
                        if !ti.Position_valid </span><span class="cov1" title="1">{
                                // Can't verify the ownship, ignore it for bearingless display
                                shouldIgnore = true
                                continue</span>
                        }

                        // User might have specified the address of another airplane that he regularly flys.
                        // If this airplane is currently in the air and we receive it, it gets priority over our ownship information.
                        // This is a sanity check to filter out such cases - only accept the ownship data if
                        // it somewhat matches our real data
                        // because of second-resolution in flarm we assume worst case of +1 second
                        <span class="cov4" title="6">timeDiff := math.Abs(ti.Age-stratuxClock.Since(mySituation.GPSLastGPSTimeStratuxTime).Seconds()) + 1
                        //if ti.ExtrapolatedPosition {
                        //        timeDiff = math.Abs(ti.AgeExtrapolation - stratuxClock.Since(mySituation.GPSLastGPSTimeStratuxTime).Seconds()) + 1
                        //}
                        speed := mySituation.GPSGroundSpeed
                        if ti.Speed_valid </span><span class="cov0" title="0">{
                                speed = math.Max(float64(ti.Speed), mySituation.GPSGroundSpeed)
                        }</span>
                        <span class="cov4" title="6">trafficDist := 0.0
                        if isGPSValid() </span><span class="cov4" title="6">{
                                trafficDist, _, _, _ = common.DistRect(float64(mySituation.GPSLatitude), float64(mySituation.GPSLongitude), float64(ti.Lat), float64(ti.Lng))
                        }</span>
                        <span class="cov4" title="6">altDiff := 99999.0
                        if ti.AltIsGNSS &amp;&amp; ti.Alt != 0 </span><span class="cov1" title="1">{
                                altDiff = math.Abs(float64(mySituation.GPSHeightAboveEllipsoid) - float64(ti.Alt))
                        }</span> else<span class="cov3" title="5"> if isTempPressValid() &amp;&amp; ti.Alt != 0 </span><span class="cov3" title="4">{
                                altDiff = math.Abs(float64(mySituation.BaroPressureAltitude - float32(ti.Alt)))
                        }</span> else<span class="cov1" title="1"> {
                                // Cant verify relative altitude.. ignore it but don't use
                                shouldIgnore = true
                                continue</span>
                        }

                        // Check if the distance to the ti is plausible
                        <span class="cov3" title="5">maxDistMetersIgnore := (timeDiff*speed*0.514444 + float64(mySituation.GPSHorizontalAccuracy) + 50) * 3
                        if trafficDist &gt; maxDistMetersIgnore </span><span class="cov1" title="1">{
                                log.Printf("Skipping ownship %s because it's too far away (%fm, speed=%f, max=%f)", ownCode, trafficDist, speed, maxDistMetersIgnore)
                                continue</span>
                        }

                        // If we have a pressure sensor, and the pressure altitude of traffic and ownship is too big, skip...
                        <span class="cov3" title="4">if altDiff &gt; 500 </span><span class="cov1" title="1">{
                                log.Printf("Skipping ownship %s because the altitude is off (%f ft)", ownCode, altDiff)
                                continue</span>
                        }

                        // To really use the information from the ownship traffic info, we have much more
                        // strict requirements. At most 5s old and must be much closer
                        <span class="cov2" title="3">maxDistMetersOwnship := (timeDiff*speed*0.514444 + float64(mySituation.GPSHorizontalAccuracy) + 20) * 1.4
                        if !isGPSValid() || (ti.Age &lt;= 5 &amp;&amp; trafficDist &lt; maxDistMetersOwnship) &amp;&amp; !ti.AltIsGNSS </span><span class="cov2" title="2">{
                                isOwnshipInfo = true
                        }</span>
                        <span class="cov2" title="3">if globalSettings.DEBUG </span><span class="cov0" title="0">{
                                log.Printf("Using ownship %s. MaxDistIgnore: %f, maxDistOwnShip: %f, dist: %f, altDiff: %f, speed: %f, timeDiffS: %f, useForInfo: %t",
                                        ownCode, maxDistMetersIgnore, maxDistMetersOwnship, trafficDist, altDiff, speed, timeDiff, isOwnshipInfo)
                        }</span>
                        <span class="cov2" title="3">shouldIgnore = true
                        return</span>
                }
        }
        <span class="cov3" title="5">isOwnshipInfo = false
        return</span>
}

func sendTrafficUpdates() <span class="cov0" title="0">{
        trafficMutex.Lock()
        defer trafficMutex.Unlock()
        cleanupOldEntries()

        // Summarize number of UAT and 1090ES traffic targets for reports that follow.
        globalStatus.UAT_traffic_targets_tracking = 0
        globalStatus.ES_traffic_targets_tracking = 0
        for _, traf := range traffic </span><span class="cov0" title="0">{
                switch traf.Last_source </span>{
                case TRAFFIC_SOURCE_1090ES:<span class="cov0" title="0">
                        globalStatus.ES_traffic_targets_tracking++</span>
                case TRAFFIC_SOURCE_UAT:<span class="cov0" title="0">
                        globalStatus.UAT_traffic_targets_tracking++</span>
                }
        }

        <span class="cov0" title="0">var currAlt float32
        currAlt = mySituation.BaroPressureAltitude
        if currAlt == 99999 </span><span class="cov0" title="0">{ // no valid BaroAlt, take GPS instead, better than nothing
                currAlt = mySituation.GPSAltitudeMSL
        }</span>

        <span class="cov0" title="0">var bestEstimate TrafficInfo
        var highestAlarmLevel uint8
        var highestAlarmTraffic TrafficInfo

        if globalSettings.DEBUG &amp;&amp; (stratuxClock.Time.Second()%15) == 0 </span><span class="cov0" title="0">{
                log.Printf("List of all aircraft being tracked:\n")
                log.Printf("==================================================================\n")
        }</span>
        <span class="cov0" title="0">for key, ti := range traffic </span><span class="cov0" title="0">{ // ForeFlight 7.5 chokes at ~1000-2000 messages depending on iDevice RAM. Practical limit likely around ~500 aircraft without filtering.
                if isGPSValid() &amp;&amp; ti.Position_valid </span><span class="cov0" title="0">{
                        // func distRect(lat1, lon1, lat2, lon2 float64) (dist, bearing, distN, distE float64) {
                        dist, bearing := common.Distance(float64(mySituation.GPSLatitude), float64(mySituation.GPSLongitude), float64(ti.Lat), float64(ti.Lng))
                        ti.Distance = dist
                        ti.Bearing = bearing
                        ti.BearingDist_valid = true
                }</span> else<span class="cov0" title="0"> {
                        ti.Distance = 0
                        ti.Bearing = 0
                        ti.BearingDist_valid = false
                }</span>
                <span class="cov0" title="0">ti.Age = stratuxClock.Since(ti.Last_seen).Seconds()
                ti.AgeExtrapolation = stratuxClock.Since(ti.Last_extrapolation).Seconds()
                ti.AgeLastAlt = stratuxClock.Since(ti.Last_alt).Seconds()

                // Keep non-extrapolated traffic for 6 seconds, but extrapolate for 20
                isCurrent := (ti.ExtrapolatedPosition &amp;&amp; ti.AgeExtrapolation &lt; 2 &amp;&amp; ti.Age &lt; 25) || (!ti.ExtrapolatedPosition &amp;&amp; ti.Age &lt; 6)

                isOwnshipTi, shouldIgnore := isOwnshipTrafficInfo(ti)

                // As bearingless targets, we show the closest estimated traffic that is between +-2000ft
                if !shouldIgnore &amp;&amp; !ti.Position_valid &amp;&amp; ti.DistanceEstimated &gt; 0 &amp;&amp;
                        (bestEstimate.DistanceEstimated == 0 || ti.DistanceEstimated &lt; bestEstimate.DistanceEstimated) </span><span class="cov0" title="0">{
                        if ti.Alt != 0 &amp;&amp; math.Abs(float64(ti.Alt)-float64(currAlt)) &lt; 2000 </span><span class="cov0" title="0">{
                                bestEstimate = ti
                        }</span>
                }

                // DEBUG: Print the list of all tracked targets (with data) to the log every 15 seconds if "DEBUG" option is enabled
                <span class="cov0" title="0">if globalSettings.DEBUG &amp;&amp; (stratuxClock.Time.Second()%15) == 0 </span><span class="cov0" title="0">{
                        s_out, err := json.Marshal(ti)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error generating output: %s\n", err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("%X =&gt; %s\n", ti.Icao_addr, string(s_out))
                        }</span>
                        // end of debug block
                }
                <span class="cov0" title="0">traffic[key] = ti // write the updated ti back to the map
                //log.Printf("Traffic age of %X is %f seconds\n",icao,ti.Age)
                if ti.Age &gt; 2 </span><span class="cov0" title="0">{ // if nothing polls an inactive ti, it won't push to the webUI, and its Age won't update.
                        trafficUpdate.SendJSON(ti)
                }</span>
                <span class="cov0" title="0">if !shouldIgnore &amp;&amp; isCurrent </span><span class="cov0" title="0">{
                        if float32(ti.Alt) &lt;= currAlt+float32(globalSettings.RadarLimits)*1.3 &amp;&amp; //take 30% more to see moving outs
                                float32(ti.Alt) &gt;= currAlt-float32(globalSettings.RadarLimits)*1.3 &amp;&amp; // altitude lower than upper boundary
                                (!ti.Position_valid || ti.Distance &lt; float64(globalSettings.RadarRange)*1852.0*1.3) </span><span class="cov0" title="0">{ //allow more so that aircraft moves out
                                radarUpdate.SendJSON(ti)
                        }</span>
                }
                <span class="cov0" title="0">if ti.Position_valid &amp;&amp; isCurrent </span><span class="cov0" title="0">{ // ... but don't pass stale data to the EFB.
                        //TODO: Coast old traffic? Need to determine how FF, WingX, etc deal with stale targets.
                        logTraffic(ti) // only add to the SQLite log if it's not stale

                        if isOwnshipTi </span><span class="cov0" title="0">{
                                if globalSettings.DEBUG </span><span class="cov0" title="0">{
                                        log.Printf("Ownship target detected for code %X\n", ti.Icao_addr)
                                }</span>
                                <span class="cov0" title="0">OwnshipTrafficInfo = ti</span>
                        } else<span class="cov0" title="0"> if !shouldIgnore </span><span class="cov0" title="0">{
                                priority := computeTrafficPriority(&amp;ti)
                                sendGDL90(makeTrafficReportMsg(ti), time.Second, priority)
                                thisMsgFLARM, validFLARM, alarmLevel := makeFlarmPFLAAString(ti)
                                if alarmLevel &gt; highestAlarmLevel </span><span class="cov0" title="0">{
                                        highestAlarmLevel = alarmLevel
                                        highestAlarmTraffic = ti
                                }</span>

                                <span class="cov0" title="0">var trafficCallsign string
                                if len(ti.Tail) &gt; 0 </span><span class="cov0" title="0">{
                                        trafficCallsign = ti.Tail
                                }</span> else<span class="cov0" title="0"> {
                                        trafficCallsign = fmt.Sprintf("%X_%d", ti.Icao_addr, ti.Squawk)
                                }</span>

                                // send traffic message to X-Plane
                                <span class="cov0" title="0">sendXPlane(createXPlaneTrafficMsg(ti.Icao_addr, ti.Lat, ti.Lng, ti.Alt, uint32(ti.Speed), int32(ti.Vvel), ti.OnGround, uint32(ti.Track), trafficCallsign), 1000, priority)
                                if validFLARM </span><span class="cov0" title="0">{
                                        sendNetFLARM(thisMsgFLARM, time.Second, priority)
                                }</span>
                        }
                }
        }

        // Also send the nearest best bearingless
        <span class="cov0" title="0">if bestEstimate.DistanceEstimated &gt; 0 &amp;&amp; bestEstimate.DistanceEstimated &lt; 15000 </span><span class="cov0" title="0">{
                if isGPSValid() </span><span class="cov0" title="0">{
                        if globalSettings.EstimateBearinglessDist </span><span class="cov0" title="0">{
                                fakeTargets := calculateModeSFakeTargets(bestEstimate)
                                fakeMsg := make([]byte, 0)
                                for _, ti := range fakeTargets </span><span class="cov0" title="0">{
                                        fakeMsg = append(fakeMsg, makeTrafficReportMsg(ti)...)
                                }</span>
                                <span class="cov0" title="0">prio := computeTrafficPriority(&amp;fakeTargets[0])
                                sendGDL90(fakeMsg, time.Second, prio)</span>
                        }
                        <span class="cov0" title="0">prio := computeTrafficPriority(&amp;bestEstimate)
                        msg, valid, _ := makeFlarmPFLAAString(bestEstimate)
                        if valid </span><span class="cov0" title="0">{
                                sendNetFLARM(msg, time.Second, prio)
                        }</span>
                }
        }

        <span class="cov0" title="0">msgPFLAU := makeFlarmPFLAUString(highestAlarmTraffic)
        sendNetFLARM(msgPFLAU, time.Second, 0)</span>
}

func computeTrafficPriority(ti *TrafficInfo) int32 <span class="cov4" title="6">{
        if !ti.BearingDist_valid || ti.Alt == 0 </span><span class="cov1" title="1">{
                return 9999999
        }</span>
        <span class="cov3" title="5">var myAlt float32
        if isTempPressValid() </span><span class="cov3" title="5">{
                myAlt = mySituation.BaroPressureAltitude
        }</span> else<span class="cov0" title="0"> {
                myAlt = mySituation.GPSAltitudeMSL
        }</span>
        <span class="cov3" title="5">altDiff := math.Abs(float64(myAlt) - float64(ti.Alt))
        // assumes 333ft vertical difference has same priority 1000m horizontal
        // This will usually produce priorities ranging from around 0-10
        return int32((altDiff/3.33 + ti.Distance) / 10000.0)</span>
}

// Used to tune to our radios. We compare our estimate to real values for ADS-B Traffic.
// If we tend to estimate too high, we reduce this value, otherwise we increase it.
// We also try to correct for different transponder transmit power, by assuming that aircraft that fly high are bigger aircraft
// and have a stronger transponder. Low aircraft are small aircraft with weak transmission power.
// This is only a wild guess, but seems to help a bit. To do so, we use different estimatedDistFactors for different
// altitude buckets: &lt;5000ft, 5000-10000ft, &gt;10000ft
var estimatedDistFactors [3]float64 = [3]float64{2500.0, 2800.0, 3000.0}

func estimateDistance(ti *TrafficInfo) <span class="cov10" title="164">{
        if ti.Last_source != TRAFFIC_SOURCE_1090ES </span><span class="cov2" title="2">{
                return
        }</span>
        <span class="cov9" title="162">altClass := int32(math.Max(0.0, math.Min(float64(ti.Alt/5000), 2.0)))
        dist := math.Pow(2.0, -ti.SignalLevel/6.0) * estimatedDistFactors[altClass] // distance approx. in meters, 6dB for double distance

        lambda := 0.2
        timeDiff := ti.Timestamp.Sub(ti.DistanceEstimatedLastTs).Seconds() * 1000
        ti.DistanceEstimatedLastTs = ti.Timestamp
        if timeDiff &lt; 0.0 </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov9" title="161">expon := math.Exp(-timeDiff / 100 * lambda)
        //log.Printf("timediff: %f, expon: %f", timeDiff, expon)
        ti.DistanceEstimated = ti.DistanceEstimated*expon + dist*(1-expon)

        // Only learn from 1090ES ADS-B targets
        // We ignore targets that are too far away (a lot of signal strength fluctuation), too close (non-reception cone or ownship)
        // and of course extrapolated targets and invalid signal levels
        if ti.BearingDist_valid &amp;&amp; ti.Distance &lt; 50000 &amp;&amp; ti.Distance &gt; 1500 &amp;&amp; ti.Last_source == TRAFFIC_SOURCE_1090ES &amp;&amp;
                ti.TargetType == TARGET_TYPE_ADSB &amp;&amp; ti.SignalLevel &gt; -30 &amp;&amp; ti.SignalLevel &lt; 0 &amp;&amp; !ti.ExtrapolatedPosition </span><span class="cov9" title="102">{
                var errorFactor float64
                if ti.DistanceEstimated &gt; ti.Distance </span><span class="cov9" title="100">{
                        errorFactor = -(ti.DistanceEstimated / ti.Distance)
                }</span> else<span class="cov2" title="2"> {
                        errorFactor = ti.Distance / ti.DistanceEstimated
                }</span>
                <span class="cov9" title="102">estimatedDistFactors[altClass] += errorFactor
                //log.Printf("Estimate off: %f, new factor: %f", errorFactor, estimatedDistFactor)
                if estimatedDistFactors[altClass] &lt; 1.0 </span><span class="cov9" title="100">{
                        estimatedDistFactors[altClass] = 1.0
                }</span>
        }

}

// calculates coordinates of a point defined by a location, a bearing, and a distance, thanks to 0x74-0x62
func calcLocationForBearingDistance(lat1, lon1, bearingDeg, distanceNm float64) (lat2, lon2 float64) <span class="cov6" title="19">{
        lat1Rad := common.Radians(lat1)
        lon1Rad := common.Radians(lon1)
        bearingRad := common.Radians(bearingDeg)
        distanceRad := distanceNm / (180 * 60 / math.Pi)

        lat2Rad := math.Asin(math.Sin(lat1Rad)*math.Cos(distanceRad) + math.Cos(lat1Rad)*math.Sin(distanceRad)*math.Cos(bearingRad))
        distanceLon := -math.Atan2(math.Sin(bearingRad)*math.Sin(distanceRad)*math.Cos(lat1Rad), math.Cos(distanceRad)-math.Sin(lat1Rad)*math.Sin(lat2Rad))
        lon2Rad := math.Mod(lon1Rad-distanceLon+math.Pi, 2.0*math.Pi) - math.Pi

        lat2 = common.Degrees(lat2Rad)
        lon2 = common.Degrees(lon2Rad)

        return
}</span>

func calculateModeSFakeTargets(bearinglessTi TrafficInfo) []TrafficInfo <span class="cov1" title="1">{
        result := make([]TrafficInfo, 8)
        for i := 0; i &lt; 8; i++ </span><span class="cov4" title="8">{
                ti := bearinglessTi
                lat, lon := calcLocationForBearingDistance(float64(mySituation.GPSLatitude), float64(mySituation.GPSLongitude), float64(i*45), bearinglessTi.DistanceEstimated/1852.0)
                ti.Lat = float32(lat)
                ti.Lng = float32(lon)
                ti.Icao_addr = uint32(i) // So that the EFB shows it as a different aircraft
                ti.Speed = 0
                ti.Speed_valid = true
                ti.Tail = "MODE S"
                result[i] = ti
        }</span>
        <span class="cov1" title="1">return result</span>
}

func postProcessTraffic(ti *TrafficInfo) <span class="cov7" title="50">{
        ti.ReceivedMsgs += 1
        estimateDistance(ti)
}</span>

// Send update to attached JSON client.
func registerTrafficUpdate(ti TrafficInfo) <span class="cov7" title="50">{
        //logTraffic(ti) // moved to sendTrafficUpdates() to reduce SQLite log size
        /*
                if !ti.Position_valid { // Don't send unless a valid position exists.
                        return
                }
        */ // Send all traffic to the websocket and let JS sort it out. This will provide user indication of why they see 1000 ES messages and no traffic.
        trafficUpdate.SendJSON(ti)
}</span>

func isTrafficAlertable(ti TrafficInfo) bool <span class="cov6" title="22">{
        // Set alert bit if possible and traffic is within some threshold
        // TODO: Could be more intelligent, taking into account headings etc.
        if !ti.BearingDist_valid </span><span class="cov5" title="17">{
                // If not able to calculate the distance to the target, let the alert bit be set always.
                return true
        }</span>
        <span class="cov3" title="5">if ti.BearingDist_valid &amp;&amp;
                ti.Distance &lt; 3704 </span><span class="cov2" title="2">{ // 3704 meters, 2 nm.
                return true
        }</span>

        <span class="cov2" title="3">return false</span>
}

func makeTrafficReportMsg(ti TrafficInfo) []byte <span class="cov6" title="19">{
        msg := make([]byte, 28)
        // See p.16.
        msg[0] = 0x14 // Message type "Traffic Report".

        // Address type
        msg[1] = ti.Addr_type

        // Set alert if needed
        if isTrafficAlertable(ti) </span><span class="cov5" title="17">{
                // Set the alert bit.  See pg. 18 of GDL90 ICD
                msg[1] |= 0x10
        }</span>

        // ICAO Address.
        <span class="cov6" title="19">msg[2] = byte((ti.Icao_addr &amp; 0x00FF0000) &gt;&gt; 16)
        msg[3] = byte((ti.Icao_addr &amp; 0x0000FF00) &gt;&gt; 8)
        msg[4] = byte((ti.Icao_addr &amp; 0x000000FF))

        lat := float32(ti.Lat)
        tmp := makeLatLng(lat)

        msg[5] = tmp[0] // Latitude.
        msg[6] = tmp[1] // Latitude.
        msg[7] = tmp[2] // Latitude.

        lng := float32(ti.Lng)
        tmp = makeLatLng(lng)

        msg[8] = tmp[0]  // Longitude.
        msg[9] = tmp[1]  // Longitude.
        msg[10] = tmp[2] // Longitude.

        // Altitude: OK
        // GDL 90 Data Interface Specification examples:
        // where 1,000 foot offset and 25 foot resolution (1,000 / 25 = 40)
        //    -1,000 feet               0x000
        //    0 feet                    0x028
        //    +1000 feet                0x050
        //    +101,350 feet             0xFFE
        //    Invalid or unavailable    0xFFF
        //
        // Algo example at: https://play.golang.org/p/VXCckSdsvT
        //
        // GDL90 expects barometric altitude in traffic reports
        var baroAlt int32
        if ti.AltIsGNSS &amp;&amp; isTempPressValid() </span><span class="cov1" title="1">{
                // Convert from GPS geoid height to barometric altitude
                baroAlt = ti.Alt - int32(mySituation.GPSGeoidSep)
                baroAlt = baroAlt - int32(mySituation.GPSAltitudeMSL) + int32(mySituation.BaroPressureAltitude)
        }</span> else<span class="cov6" title="18"> {
                baroAlt = ti.Alt
        }</span>
        <span class="cov6" title="19">var encodedAlt int16
        if baroAlt &lt; -1000 || baroAlt &gt; 101350 </span><span class="cov2" title="2">{
                encodedAlt = 0x0FFF
        }</span> else<span class="cov5" title="17"> {
                // output guaranteed to be between 0x0000 and 0x0FFE
                encodedAlt = int16((baroAlt / 25) + 40)
        }</span>
        <span class="cov6" title="19">msg[11] = byte((encodedAlt &amp; 0xFF0) &gt;&gt; 4) // Altitude.
        msg[12] = byte((encodedAlt &amp; 0x00F) &lt;&lt; 4)

        // "m" field. Lower four bits define indicator bits:
        // - - 0 0   "tt" (msg[17]) is not valid
        // - - 0 1   "tt" is true track
        // - - 1 0   "tt" is magnetic heading
        // - - 1 1   "tt" is true heading
        // - 0 - -   Report is updated (current data)
        // - 1 - -   Report is extrapolated
        // 0 - - -   On ground
        // 1 - - -   Airborne

        // Define tt type / validity
        if ti.Speed_valid </span><span class="cov1" title="1">{
                msg[12] = msg[12] | 0x01 // assume true track
        }</span>

        <span class="cov6" title="19">if ti.ExtrapolatedPosition </span><span class="cov1" title="1">{
                msg[12] = msg[12] | 0x04
        }</span>

        <span class="cov6" title="19">if !ti.OnGround </span><span class="cov6" title="18">{
                msg[12] = msg[12] | 0x08 // Airborne.
        }</span>

        // Position containment / navigational accuracy
        <span class="cov6" title="19">msg[13] = ((byte(ti.NIC) &lt;&lt; 4) &amp; 0xF0) | (byte(ti.NACp) &amp; 0x0F)

        // Horizontal velocity (speed).

        msg[14] = byte((ti.Speed &amp; 0x0FF0) &gt;&gt; 4)
        msg[15] = byte((ti.Speed &amp; 0x000F) &lt;&lt; 4)

        // Vertical velocity.
        vvel := ti.Vvel / 64 // 64fpm resolution.
        msg[15] = msg[15] | byte((vvel&amp;0x0F00)&gt;&gt;8)
        msg[16] = byte(vvel &amp; 0x00FF)

        // Track.
        trk := uint8(ti.Track / TRACK_RESOLUTION) // Resolution is ~1.4 common.Degrees.
        msg[17] = byte(trk)

        msg[18] = ti.Emitter_category

        // msg[19] to msg[26] are "call sign" (tail).
        for i := 0; i &lt; len(ti.Tail) &amp;&amp; i &lt; 8; i++ </span><span class="cov6" title="29">{
                c := byte(ti.Tail[i])
                if c != 0x20 &amp;&amp; !((c &gt;= 48) &amp;&amp; (c &lt;= 57)) &amp;&amp; !((c &gt;= 65) &amp;&amp; (c &lt;= 90)) &amp;&amp; c != 'e' &amp;&amp; c != 'u' &amp;&amp; c != 'a' &amp;&amp; c != 'r' &amp;&amp; c != 't' </span><span class="cov2" title="3">{ // See p.24, FAA ref.
                        c = byte(0x20)
                }</span>
                <span class="cov6" title="29">msg[19+i] = c</span>
        }

        //msg[27] is priority / emergency status per GDL90 spec (DO260B and DO282B are same codes)
        <span class="cov6" title="19">msg[27] = ti.PriorityStatus &lt;&lt; 4

        return prepareMessage(msg)</span>
}

// parseDownlinkReport decodes a UAT downlink message to extract identity, state vector, and mode status data.
// Decoded data is used to update a TrafficInfo object, keyed to the 24-bit ICAO code contained in the
// downlink message.
// Inputs are a checksum-verified hex string corresponding to the 18 or 34-byte UAT
// message, and an int representing UAT signal amplitude (0-1000).
func parseDownlinkReport(s string, signalLevel int) <span class="cov0" title="0">{

        var ti TrafficInfo
        s = s[1:]
        frame := make([]byte, len(s)/2)
        hex.Decode(frame, []byte(s))

        // Extract header
        msg_type := (uint8(frame[0]) &gt;&gt; 3) &amp; 0x1f
        addr_type := uint8(frame[0]) &amp; 0x07
        icao_addr := (uint32(frame[1]) &lt;&lt; 16) | (uint32(frame[2]) &lt;&lt; 8) | uint32(frame[3])

        trafficMutex.Lock()
        defer trafficMutex.Unlock()

        // Retrieve previous information on this ICAO code.
        if val, ok := traffic[icao_addr]; ok </span><span class="cov0" title="0">{ // if we've already seen it, copy it in to do updates as it may contain some useful information like "tail" from 1090ES.
                ti = val
                //log.Printf("Existing target %X imported for UAT update\n", icao_addr)
        }</span> else<span class="cov0" title="0"> {
                //log.Printf("New target %X created for UAT update\n", icao_addr)
                ti.Last_seen = stratuxClock.Time // need to initialize to current stratuxClock so it doesn't get cut before we have a chance to populate a position message
                ti.Icao_addr = icao_addr
                ti.ExtrapolatedPosition = false

                thisReg, validReg := icao2reg(icao_addr)
                if validReg </span><span class="cov0" title="0">{
                        ti.Reg = thisReg
                        ti.Tail = thisReg
                }</span>
        }

        <span class="cov0" title="0">ti.Addr_type = addr_type

        var uat_version byte // sent as part of MS element, byte 24

        // Extract parameters from Mode Status elements, if available.
        if msg_type == 1 || msg_type == 3 </span><span class="cov0" title="0">{

                // Determine UAT message version. This is needed for some capability decoding and is useful for debugging.
                uat_version = (frame[23] &gt;&gt; 2) &amp; 0x07

                // Extract emitter category.
                v := (uint16(frame[17]) &lt;&lt; 8) | (uint16(frame[18]))
                ti.Emitter_category = uint8((v / 1600) % 40)

                // Decode callsign or Flight Plan ID (i.e. squawk code)
                // If the CSID bit (byte 27, bit 7) is set to 1, all eight characters
                // encoded in bytes 18-23 represent callsign.
                // If the CSID bit is set to 0, the first four characters encoded in bytes 18-23
                // represent the Mode A squawk code.

                csid := (frame[26] &gt;&gt; 1) &amp; 0x01

                if csid == 1 </span><span class="cov0" title="0">{ // decode as callsign
                        base40_alphabet := string("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ  ..")
                        tail := ""

                        v := (uint16(frame[17]) &lt;&lt; 8) | uint16(frame[18])
                        tail += string(base40_alphabet[(v/40)%40])
                        tail += string(base40_alphabet[v%40])
                        v = (uint16(frame[19]) &lt;&lt; 8) | uint16(frame[20])
                        tail += string(base40_alphabet[(v/1600)%40])
                        tail += string(base40_alphabet[(v/40)%40])
                        tail += string(base40_alphabet[v%40])
                        v = (uint16(frame[21]) &lt;&lt; 8) | uint16(frame[22])
                        tail += string(base40_alphabet[(v/1600)%40])
                        tail += string(base40_alphabet[(v/40)%40])
                        tail += string(base40_alphabet[v%40])
                        tail = strings.Trim(tail, " ")
                        ti.Tail = tail

                }</span> else<span class="cov0" title="0"> if uat_version &gt;= 2 </span><span class="cov0" title="0">{ // decode as Mode 3/A code, if UAT version is at least 2
                        v := (uint16(frame[17]) &lt;&lt; 8) | uint16(frame[18])
                        squawk_a := (v / 40) % 40
                        squawk_b := v % 40
                        v = (uint16(frame[19]) &lt;&lt; 8) | uint16(frame[20])
                        squawk_c := (v / 1600) % 40
                        squawk_d := (v / 40) % 40
                        squawk := 1000*squawk_a + 100*squawk_b + 10*squawk_c + squawk_d
                        ti.Squawk = int(squawk)
                }</span>

                <span class="cov0" title="0">ti.NACp = int((frame[25] &gt;&gt; 4) &amp; 0x0F)
                ti.PriorityStatus = (frame[23] &gt;&gt; 5) &amp; 0x07

                // Following section is future-use for debugging and / or additional status info on UAT traffic. Message parsing needs testing.

                if globalSettings.DEBUG </span><span class="cov0" title="0">{
                        //declaration for mode status flags -- parse for debug logging
                        var status_sil byte
                        //var status_transmit_mso byte
                        var status_sda byte
                        var status_nacv byte
                        //var status_nicbaro byte
                        //var status_sil_supp byte
                        //var status_geom_vert_acc byte
                        //var status_sa_flag byte
                        var capability_uat_in bool
                        var capability_1090_in bool
                        //var capability_tcas bool
                        //var capability_cdti bool
                        //var opmode_tcas_active bool
                        //var opmode_ident_active bool
                        //var opmode_rec_atc_serv bool

                        // these are present in v1 and v2 messages
                        status_sil = frame[23] &amp; 0x03
                        //status_transmit_mso = frame[24] &gt;&gt; 2
                        status_nacv = (frame[25] &gt;&gt; 1) &amp; 0x07
                        //status_nicbaro = frame[25] &amp; 0x01

                        // other status and capability bits are different between v1 and v2
                        if uat_version == 2 </span><span class="cov0" title="0">{
                                status_sda = frame[24] &amp; 0x03
                                capability_uat_in = (frame[26] &gt;&gt; 7) != 0
                                capability_1090_in = ((frame[26] &gt;&gt; 6) &amp; 0x01) != 0
                                //capability_tcas = ((frame[26] &gt;&gt; 5) &amp; 0x01) != 0
                                //opmode_tcas_active = ((frame[26] &gt;&gt; 4) &amp; 0x01) != 0
                                //opmode_ident_active = ((frame[26] &gt;&gt; 3) &amp; 0x01) != 0
                                //opmode_rec_atc_serv = ((frame[26] &gt;&gt; 2) &amp; 0x01) != 0
                                //status_sil_supp = frame[26] &amp; 0x01
                                //status_geom_vert_acc = (frame[27] &gt;&gt; 6) &amp; 0x03
                                //status_sa_flag = (frame[27] &gt;&gt; 5) &amp; 0x01

                        }</span> else<span class="cov0" title="0"> if uat_version == 1 </span>{<span class="cov0" title="0">
                                //capability_cdti = (frame[26] &gt;&gt; 7) != 0
                                //capability_tcas = ((frame[26] &gt;&gt; 6) &amp; 0x01) != 0
                                //opmode_tcas_active = ((frame[26] &gt;&gt; 5) &amp; 0x01) != 0
                                //opmode_ident_active = ((frame[26] &gt;&gt; 4) &amp; 0x01) != 0
                                //opmode_rec_atc_serv = ((frame[26] &gt;&gt; 3) &amp; 0x01) != 0
                        }</span>

                        <span class="cov0" title="0">log.Printf("Supplemental UAT Mode Status for %06X: Version = %d; SIL = %d; SDA = %d; NACv = %d; 978 In = %v; 1090 In = %v\n", icao_addr, uat_version, status_sil, status_sda, status_nacv, capability_uat_in, capability_1090_in)</span>
                }
        }

        <span class="cov0" title="0">ti.NIC = int(frame[11] &amp; 0x0F)

        var power float64
        if signalLevel &gt; 0 </span><span class="cov0" title="0">{
                power = 20 * (math.Log10(float64(signalLevel) / 1000)) // reported amplitude is 0-1000. Normalize to max = 1 and do amplitude dB calculation (20 dB per decade)
        }</span> else<span class="cov0" title="0"> {
                power = -999
        }</span>
        //log.Printf("%s (%X) seen with amplitude of %d, corresponding to normalized power of %f.2 dB\n",ti.Tail,ti.Icao_addr,signalLevel,power)

        <span class="cov0" title="0">ti.SignalLevel = power

        if ti.Addr_type == 0 </span><span class="cov0" title="0">{
                ti.TargetType = TARGET_TYPE_ADSB
        }</span> else<span class="cov0" title="0"> if ti.Addr_type == 3 </span><span class="cov0" title="0">{
                ti.TargetType = TARGET_TYPE_TISB
        }</span> else<span class="cov0" title="0"> if ti.Addr_type == 6 </span><span class="cov0" title="0">{
                ti.TargetType = TARGET_TYPE_ADSR
        }</span> else<span class="cov0" title="0"> if ti.Addr_type == 2 </span><span class="cov0" title="0">{
                ti.TargetType = TARGET_TYPE_TISB_S
                if (ti.NIC &gt;= 7) &amp;&amp; (ti.Emitter_category &gt; 0) </span><span class="cov0" title="0">{ // If NIC is sufficiently high and emitter type is transmitted, we'll assume it's ADS-R.
                        ti.TargetType = TARGET_TYPE_ADSR
                }</span>
        }

        // This is a hack to show the source of the traffic on moving maps.
        <span class="cov0" title="0">if globalSettings.DisplayTrafficSource </span><span class="cov0" title="0">{
                type_code := " "
                switch ti.TargetType </span>{
                case TARGET_TYPE_ADSB:<span class="cov0" title="0">
                        type_code = "a"</span>
                case TARGET_TYPE_ADSR, TARGET_TYPE_TISB_S:<span class="cov0" title="0">
                        type_code = "r"</span>
                case TARGET_TYPE_TISB:<span class="cov0" title="0">
                        type_code = "t"</span>
                }

                <span class="cov0" title="0">if len(ti.Tail) == 0 </span><span class="cov0" title="0">{
                        ti.Tail = "u" + type_code
                }</span> else<span class="cov0" title="0"> if len(ti.Tail) &lt; 7 &amp;&amp; ti.Tail[0] != 'e' &amp;&amp; ti.Tail[0] != 'u' </span><span class="cov0" title="0">{
                        ti.Tail = "u" + type_code + ti.Tail
                }</span> else<span class="cov0" title="0"> if len(ti.Tail) == 7 &amp;&amp; ti.Tail[0] != 'e' &amp;&amp; ti.Tail[0] != 'u' </span><span class="cov0" title="0">{
                        ti.Tail = "u" + type_code + ti.Tail[1:]
                }</span> else<span class="cov0" title="0"> if len(ti.Tail) &gt; 1 </span><span class="cov0" title="0">{ // bounds checking
                        ti.Tail = "u" + type_code + ti.Tail[2:]
                }</span>
        }
        <span class="cov0" title="0">raw_lat := (uint32(frame[4]) &lt;&lt; 15) | (uint32(frame[5]) &lt;&lt; 7) | (uint32(frame[6]) &gt;&gt; 1)
        raw_lon := ((uint32(frame[6]) &amp; 0x01) &lt;&lt; 23) | (uint32(frame[7]) &lt;&lt; 15) | (uint32(frame[8]) &lt;&lt; 7) | (uint32(frame[9]) &gt;&gt; 1)

        lat := float32(0.0)
        lng := float32(0.0)

        position_valid := false
        if /*(ti.NIC != 0) &amp;&amp; */ (raw_lat != 0) &amp;&amp; (raw_lon != 0) </span><span class="cov0" title="0">{ // pass all traffic, and let the display determine if it will show NIC == 0. This will allow misconfigured or uncertified / portable emitters to be seen.
                position_valid = true
                lat = float32(raw_lat) * 360.0 / 16777216.0
                if lat &gt; 90 </span><span class="cov0" title="0">{
                        lat = lat - 180
                }</span>
                <span class="cov0" title="0">lng = float32(raw_lon) * 360.0 / 16777216.0
                if lng &gt; 180 </span><span class="cov0" title="0">{
                        lng = lng - 360
                }</span>
        }
        <span class="cov0" title="0">ti.Position_valid = position_valid
        if ti.Position_valid </span><span class="cov0" title="0">{
                ti.Lat = lat
                ti.Lng = lng
                if isGPSValid() </span><span class="cov0" title="0">{
                        ti.Distance, ti.Bearing = common.Distance(float64(mySituation.GPSLatitude), float64(mySituation.GPSLongitude), float64(ti.Lat), float64(ti.Lng))
                }</span>
                <span class="cov0" title="0">ti.Last_seen = stratuxClock.Time
                ti.ExtrapolatedPosition = false</span>
        }

        <span class="cov0" title="0">raw_alt := (int32(frame[10]) &lt;&lt; 4) | ((int32(frame[11]) &amp; 0xf0) &gt;&gt; 4)
        alt_geo := false // Default case (i.e. 'false') is barometric
        alt := int32(0)
        if raw_alt != 0 </span><span class="cov0" title="0">{
                alt_geo = (uint8(frame[9]) &amp; 1) != 0
                alt = ((raw_alt - 1) * 25) - 1000
        }</span>
        <span class="cov0" title="0">ti.Alt = alt
        ti.AltIsGNSS = alt_geo
        ti.Last_alt = stratuxClock.Time

        //OK.
        //        fmt.Printf("%d, %t, %f, %f, %t, %d\n", nic, position_valid, lat, lng, alt_geo, alt)

        airground_state := (uint8(frame[12]) &gt;&gt; 6) &amp; 0x03
        //OK.
        //        fmt.Printf("%d\n", airground_state)

        ns_vel := int32(0) // int16 won't work. Worst case (supersonic), we need 26 bits (25 bits + sign) for root sum of squares speed calculation
        ew_vel := int32(0)
        track := float32(0)
        speed_valid := false
        speed := uint16(0)
        vvel := int16(0)
        //        vvel_geo := false
        if airground_state == 0 || airground_state == 1 </span><span class="cov0" title="0">{ // Subsonic. Supersonic.
                ti.OnGround = false
                // N/S velocity.
                ns_vel_valid := false
                ew_vel_valid := false
                raw_ns := ((int16(frame[12]) &amp; 0x1f) &lt;&lt; 6) | ((int16(frame[13]) &amp; 0xfc) &gt;&gt; 2)
                if (raw_ns &amp; 0x3ff) != 0 </span><span class="cov0" title="0">{
                        ns_vel_valid = true
                        ns_vel = int32((raw_ns &amp; 0x3ff) - 1)
                        if (raw_ns &amp; 0x400) != 0 </span><span class="cov0" title="0">{
                                ns_vel = 0 - ns_vel
                        }</span>
                        <span class="cov0" title="0">if airground_state == 1 </span><span class="cov0" title="0">{ // Supersonic.
                                ns_vel = ns_vel * 4
                        }</span>
                }
                // E/W velocity.
                <span class="cov0" title="0">raw_ew := ((int16(frame[13]) &amp; 0x03) &lt;&lt; 9) | (int16(frame[14]) &lt;&lt; 1) | ((int16(frame[15] &amp; 0x80)) &gt;&gt; 7)
                if (raw_ew &amp; 0x3ff) != 0 </span><span class="cov0" title="0">{
                        ew_vel_valid = true
                        ew_vel = int32((raw_ew &amp; 0x3ff) - 1)
                        if (raw_ew &amp; 0x400) != 0 </span><span class="cov0" title="0">{
                                ew_vel = 0 - ew_vel
                        }</span>
                        <span class="cov0" title="0">if airground_state == 1 </span><span class="cov0" title="0">{ // Supersonic.
                                ew_vel = ew_vel * 4
                        }</span>
                }
                <span class="cov0" title="0">if ns_vel_valid &amp;&amp; ew_vel_valid </span><span class="cov0" title="0">{
                        if ns_vel != 0 || ew_vel != 0 </span><span class="cov0" title="0">{
                                //TODO: Track type
                                track = float32((360 + 90 - (int16(math.Atan2(float64(ns_vel), float64(ew_vel)) * 180 / math.Pi))) % 360)
                        }</span>
                        <span class="cov0" title="0">speed_valid = true
                        speed = uint16(math.Sqrt(float64((ns_vel * ns_vel) + (ew_vel * ew_vel))))</span>
                }

                // Vertical velocity.
                <span class="cov0" title="0">raw_vvel := ((int16(frame[15]) &amp; 0x7f) &lt;&lt; 4) | ((int16(frame[16]) &amp; 0xf0) &gt;&gt; 4)
                if (raw_vvel &amp; 0x1ff) != 0 </span><span class="cov0" title="0">{
                        //                        vvel_geo = (raw_vvel &amp; 0x400) == 0
                        vvel = ((raw_vvel &amp; 0x1ff) - 1) * 64
                        if (raw_vvel &amp; 0x200) != 0 </span><span class="cov0" title="0">{
                                vvel = 0 - vvel
                        }</span>
                }
        } else<span class="cov0" title="0"> if airground_state == 2 </span><span class="cov0" title="0">{ // Ground vehicle.
                ti.OnGround = true
                raw_gs := ((uint16(frame[12]) &amp; 0x1f) &lt;&lt; 6) | ((uint16(frame[13]) &amp; 0xfc) &gt;&gt; 2)
                if raw_gs != 0 </span><span class="cov0" title="0">{
                        speed_valid = true
                        speed = ((raw_gs &amp; 0x3ff) - 1)
                }</span>

                <span class="cov0" title="0">raw_track := ((uint16(frame[13]) &amp; 0x03) &lt;&lt; 9) | (uint16(frame[14]) &lt;&lt; 1) | ((uint16(frame[15]) &amp; 0x80) &gt;&gt; 7)
                //tt := ((raw_track &amp; 0x0600) &gt;&gt; 9)
                //FIXME: tt == 1 TT_TRACK. tt == 2 TT_MAG_HEADING. tt == 3 TT_TRUE_HEADING.
                track = float32((raw_track &amp; 0x1ff) * 360 / 512)</span>

                // Dimensions of vehicle - skip.
        }

        <span class="cov0" title="0">if msg_type == 1 || msg_type == 2 || msg_type == 5 || msg_type == 6 </span><span class="cov0" title="0">{
                // Read AUXSV.
                raw_alt := (int32(frame[29]) &lt;&lt; 4) | ((int32(frame[30]) &amp; 0xf0) &gt;&gt; 4)
                if raw_alt != 0 </span><span class="cov0" title="0">{
                        alt := ((raw_alt - 1) * 25) - 1000
                        if ti.AltIsGNSS </span><span class="cov0" title="0">{
                                // Current ti.Alt is GNSS. Swap it for the AUXSV alt, which is baro.
                                baro_alt := ti.Alt
                                ti.Alt = alt
                                alt = baro_alt
                                ti.AltIsGNSS = false
                        }</span>

                        <span class="cov0" title="0">ti.GnssDiffFromBaroAlt = alt - ti.Alt
                        ti.Last_GnssDiff = stratuxClock.Time
                        ti.Last_GnssDiffAlt = ti.Alt</span>

                }
        }

        <span class="cov0" title="0">ti.Track = track
        ti.Speed = speed
        ti.Vvel = vvel
        ti.Speed_valid = speed_valid
        if ti.Speed_valid </span><span class="cov0" title="0">{
                ti.Last_speed = stratuxClock.Time
        }</span>

        //        fmt.Printf("ns_vel %d, ew_vel %d, track %d, speed_valid %t, speed %d, vvel_geo %t, vvel %d\n", ns_vel, ew_vel, track, speed_valid, speed, vvel_geo, vvel)

        /*
                utc_coupled := false
                tisb_site_id := uint8(0)

                if (uint8(frame[0]) &amp; 7) == 2 || (uint8(frame[0]) &amp; 7) == 3 { //TODO: Meaning?
                        tisb_site_id = uint8(frame[16]) &amp; 0x0f
                } else {
                        utc_coupled = (uint8(frame[16]) &amp; 0x08) != 0
                }
        */

        //        fmt.Printf("tisb_site_id %d, utc_coupled %t\n", tisb_site_id, utc_coupled)

        <span class="cov0" title="0">ti.Timestamp = time.Now()

        ti.Last_source = TRAFFIC_SOURCE_UAT
        postProcessTraffic(&amp;ti)
        traffic[ti.Icao_addr] = ti
        registerTrafficUpdate(ti)
        seenTraffic[ti.Icao_addr] = true</span> // Mark as seen.
}

func esListen() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if !globalSettings.ES_Enabled &amp;&amp; !globalSettings.Ping_Enabled &amp;&amp; !globalSettings.Pong_Enabled </span><span class="cov0" title="0">{
                        time.Sleep(1 * time.Second) // Don't do much unless ES is actually enabled.
                        continue</span>
                }

                <span class="cov0" title="0">dump1090Addr := "127.0.0.1:30006"
                inConn, err := net.Dial("tcp", dump1090Addr)
                if err != nil </span><span class="cov0" title="0">{ // Local connection failed.
                        time.Sleep(1 * time.Second)
                        continue</span>
                }
                <span class="cov0" title="0">rdr := bufio.NewReader(inConn)
                for globalSettings.ES_Enabled || globalSettings.Ping_Enabled </span><span class="cov0" title="0">{
                        buf, err := rdr.ReadString('\n')
                        if err != nil </span><span class="cov0" title="0">{ // Must have disconnected?
                                break</span>
                        }
                        <span class="cov0" title="0">buf = strings.Trim(buf, "\r\n")
                        TraceLog.Record(CONTEXT_DUMP1090, []byte(buf))
                        parseDump1090Message(buf)</span>
                }
                <span class="cov0" title="0">for globalSettings.ES_Enabled || globalSettings.Pong_Enabled </span><span class="cov0" title="0">{
                        buf, err := rdr.ReadString('\n')
                        if err != nil </span><span class="cov0" title="0">{ // Must have disconnected?
                                break</span>
                        }
                        <span class="cov0" title="0">buf = strings.Trim(buf, "\r\n")
                        TraceLog.Record(CONTEXT_DUMP1090, []byte(buf))
                        parseDump1090Message(buf)</span>
                }
        }
}

func parseDump1090Message(buf string) <span class="cov7" title="48">{
        // Log the message to the message counter in any case.
        var thisMsg msg
        thisMsg.MessageClass = MSGCLASS_ES
        thisMsg.TimeReceived = stratuxClock.Time
        thisMsg.Data = buf
        msgLogAppend(thisMsg)

        var eslog esmsg
        eslog.TimeReceived = stratuxClock.Time
        eslog.Data = buf
        logESMsg(eslog) // log raw dump1090:30006 output to SQLite log
        // Only increment if using an SDR for 1090 traffic
        if !globalSettings.Ping_Enabled &amp;&amp; !globalSettings.Pong_Enabled </span><span class="cov7" title="48">{
                globalStatus.ES_messages_total++
        }</span>
        <span class="cov7" title="48">var newTi *dump1090Data
        err := json.Unmarshal([]byte(buf), &amp;newTi)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("can't read ES traffic information from %s: %s\n", buf, err.Error())
                return
        }</span>

        <span class="cov7" title="48">if newTi.Icao_addr == 0x07FFFFFF </span><span class="cov0" title="0">{ // used to signal heartbeat
                if globalSettings.DEBUG </span><span class="cov0" title="0">{
                        log.Printf("No traffic last 60 seconds. Heartbeat message from dump1090: %s\n", buf)
                }</span>
                <span class="cov0" title="0">return</span> // don't process heartbeat messages
        }

        <span class="cov7" title="48">if (newTi.Icao_addr &amp; 0x01000000) != 0 </span><span class="cov0" title="0">{ // bit 25 used by dump1090 to signal non-ICAO address
                newTi.Icao_addr = newTi.Icao_addr &amp; 0x00FFFFFF
                if globalSettings.DEBUG </span><span class="cov0" title="0">{
                        log.Printf("Non-ICAO address %X sent by dump1090. This is typical for TIS-B.\n", newTi.Icao_addr)
                }</span>
        }
        <span class="cov7" title="48">icao := uint32(newTi.Icao_addr)
        var ti TrafficInfo

        trafficMutex.Lock()

        // Retrieve previous information on this ICAO code.
        if val, ok := traffic[icao]; ok </span><span class="cov7" title="32">{ // if we've already seen it, copy it in to do updates
                ti = val
                //log.Printf("Existing target %X imported for ES update\n", icao)
        }</span> else<span class="cov5" title="16"> {
                //log.Printf("New target %X created for ES update\n",newTi.Icao_addr)
                ti.Last_seen = stratuxClock.Time // need to initialize to current stratuxClock so it doesn't get cut before we have a chance to populate a position message
                ti.Last_alt = stratuxClock.Time  // ditto.
                ti.Icao_addr = icao
                ti.ExtrapolatedPosition = false
                ti.Last_source = TRAFFIC_SOURCE_1090ES

                thisReg, validReg := icao2reg(icao)
                if validReg </span><span class="cov5" title="16">{
                        ti.Reg = thisReg
                        ti.Tail = thisReg
                }</span>
        }

        <span class="cov7" title="48">if newTi.SignalLevel &gt; 0 </span><span class="cov7" title="48">{
                power := 10 * math.Log10(newTi.SignalLevel)
                ti.SignalLevelHist = append(ti.SignalLevelHist, power)
                if len(ti.SignalLevelHist) &gt; 8 </span><span class="cov0" title="0">{
                        ti.SignalLevelHist = ti.SignalLevelHist[len(ti.SignalLevelHist)-8:]
                }</span>
                <span class="cov7" title="48">ti.SignalLevel = -999
                for _, level := range ti.SignalLevelHist </span><span class="cov9" title="96">{
                        if level &gt; ti.SignalLevel </span><span class="cov8" title="80">{
                                ti.SignalLevel = level
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                ti.SignalLevel = -999
        }</span>

        // generate human readable summary of message types for debug
        //TODO: Use for ES message statistics?
        /*
                var s1 string
                if newTi.DF == 17 {
                        s1 = "ADS-B"
                }
                if newTi.DF == 18 {
                        s1 = "ADS-R / TIS-B"
                }

                if newTi.DF == 4 || newTi.DF == 20 {
                        s1 = "Surveillance, Alt. Reply"
                }

                if newTi.DF == 5 || newTi.DF == 21 {
                        s1 = "Surveillance, Ident. Reply"
                }

                if newTi.DF == 11 {
                        s1 = "All-call Reply"
                }

                if newTi.DF == 0 {
                        s1 = "Short Air-Air Surv."
                }

                if newTi.DF == 16 {
                        s1 = "Long Air-Air Surv."
                }
        */
        //log.Printf("Mode S message from icao=%X, DF=%02d, CA=%02d, TC=%02d (%s)\n", ti.Icao_addr, newTi.DF, newTi.CA, newTi.TypeCode, s1)

        // Altitude will be sent by dump1090 for ES ADS-B/TIS-B (DF=17 and DF=18)
        // and Mode S messages (DF=0, DF = 4, and DF = 20).

        <span class="cov7" title="48">ti.AltIsGNSS = newTi.AltIsGNSS

        if newTi.Alt != nil </span><span class="cov7" title="48">{
                ti.Alt = int32(*newTi.Alt)
                ti.Last_alt = stratuxClock.Time
        }</span>

        <span class="cov7" title="48">if newTi.GnssDiffFromBaroAlt != nil </span><span class="cov0" title="0">{
                ti.GnssDiffFromBaroAlt = int32(*newTi.GnssDiffFromBaroAlt) // we can estimate pressure altitude from GNSS height with this parameter!
                ti.Last_GnssDiff = stratuxClock.Time
                ti.Last_GnssDiffAlt = ti.Alt
        }</span>

        // Position updates are provided only by ES messages (DF=17 and DF=18; multiple TCs)
        <span class="cov7" title="48">if newTi.Position_valid </span><span class="cov7" title="48">{ // i.e. DF17 or DF18 message decoded successfully by dump1090
                valid_position := true
                var lat, lng float32

                if newTi.Lat != nil </span><span class="cov7" title="48">{
                        lat = float32(*newTi.Lat)
                }</span> else<span class="cov0" title="0"> { // dump1090 send a valid message, but Stratux couldn't figure it out for some reason.
                        valid_position = false
                        //log.Printf("Missing latitude in DF=17/18 airborne position message\n")
                }</span>

                <span class="cov7" title="48">if newTi.Lng != nil </span><span class="cov7" title="48">{
                        lng = float32(*newTi.Lng)
                }</span> else<span class="cov0" title="0"> { //
                        valid_position = false
                        //log.Printf("Missing longitude in DF=17 airborne position message\n")
                }</span>

                <span class="cov7" title="48">if valid_position </span><span class="cov7" title="48">{
                        ti.Lat = lat
                        ti.Lng = lng
                        if isGPSValid() </span><span class="cov0" title="0">{
                                ti.Distance, ti.Bearing = common.Distance(float64(mySituation.GPSLatitude), float64(mySituation.GPSLongitude), float64(ti.Lat), float64(ti.Lng))
                                ti.BearingDist_valid = true
                        }</span>
                        <span class="cov7" title="48">ti.Position_valid = true
                        ti.ExtrapolatedPosition = false
                        ti.Last_seen = stratuxClock.Time</span> // only update "last seen" data on position updates
                }
        } else<span class="cov0" title="0"> {
                // Old traffic had no position and update doesn't have a position either -&gt; assume Mode-S only
                if !ti.Position_valid </span><span class="cov0" title="0">{
                        ti.Last_seen = ti.Last_alt
                }</span>
        }

        <span class="cov7" title="48">if newTi.Speed_valid </span><span class="cov7" title="48">{ // i.e. DF17 or DF18, TC 19 message decoded successfully by dump1090
                valid_speed := true
                var speed uint16
                var track float32

                if newTi.Track != nil </span><span class="cov7" title="48">{
                        track = float32(*newTi.Track)
                }</span> else<span class="cov0" title="0"> { // dump1090 send a valid message, but Stratux couldn't figure it out for some reason.
                        valid_speed = false
                        //log.Printf("Missing track in DF=17/18 TC19 airborne velocity message\n")
                }</span>

                <span class="cov7" title="48">if newTi.Speed != nil </span><span class="cov7" title="48">{
                        speed = uint16(*newTi.Speed)
                }</span> else<span class="cov0" title="0"> { //
                        valid_speed = false
                        //log.Printf("Missing speed in DF=17/18 TC19 airborne velocity message\n")
                }</span>

                <span class="cov7" title="48">if newTi.Vvel != nil </span><span class="cov7" title="48">{
                        ti.Vvel = int16(*newTi.Vvel)
                }</span> else <span class="cov0" title="0">{ // we'll still make the message without a valid vertical speed.
                        //log.Printf("Missing vertical speed in DF=17/18 TC19 airborne velocity message\n")
                }</span>

                <span class="cov7" title="48">if valid_speed </span><span class="cov7" title="48">{
                        ti.Track = track
                        ti.Speed = speed
                        ti.Speed_valid = true
                        ti.Last_speed = stratuxClock.Time // only update "last seen" data on position updates
                }</span>
        } else<span class="cov0" title="0"> if ((newTi.DF == 17) || (newTi.DF == 18)) &amp;&amp; (newTi.TypeCode == 19) </span><span class="cov0" title="0">{ // invalid speed on velocity message only
                ti.Speed_valid = false
        }</span>

        // Determine NIC (navigation integrity category) from type code and subtype code
        <span class="cov7" title="48">if ((newTi.DF == 17) || (newTi.DF == 18)) &amp;&amp; (newTi.TypeCode &gt;= 5 &amp;&amp; newTi.TypeCode &lt;= 22) &amp;&amp; (newTi.TypeCode != 19) </span><span class="cov7" title="48">{
                nic := 0 // default for unknown or missing NIC
                switch newTi.TypeCode </span>{
                case 0, 8, 18, 22:<span class="cov0" title="0">
                        nic = 0</span>
                case 17:<span class="cov0" title="0">
                        nic = 1</span>
                case 16:<span class="cov0" title="0">
                        if newTi.SubtypeCode == 1 </span><span class="cov0" title="0">{
                                nic = 3
                        }</span> else<span class="cov0" title="0"> {
                                nic = 2
                        }</span>
                case 15:<span class="cov0" title="0">
                        nic = 4</span>
                case 14:<span class="cov0" title="0">
                        nic = 5</span>
                case 13:<span class="cov0" title="0">
                        nic = 6</span>
                case 12:<span class="cov0" title="0">
                        nic = 7</span>
                case 11:<span class="cov7" title="48">
                        if newTi.SubtypeCode == 1 </span><span class="cov0" title="0">{
                                nic = 9
                        }</span> else<span class="cov7" title="48"> {
                                nic = 8
                        }</span>
                case 10, 21:<span class="cov0" title="0">
                        nic = 10</span>
                case 9, 20:<span class="cov0" title="0">
                        nic = 11</span>
                }
                <span class="cov7" title="48">ti.NIC = nic

                if (ti.NACp &lt; 7) &amp;&amp; (ti.NACp &lt; ti.NIC) </span><span class="cov5" title="16">{
                        ti.NACp = ti.NIC // initialize to NIC, since NIC is sent with every position report, and not all emitters report NACp.
                }</span>
        }

        <span class="cov7" title="48">if newTi.NACp != nil </span><span class="cov7" title="48">{
                ti.NACp = *newTi.NACp
        }</span>

        <span class="cov7" title="48">if newTi.Emitter_category != nil </span><span class="cov0" title="0">{
                ti.Emitter_category = uint8(*newTi.Emitter_category) // validate dump1090 on live traffic
        }</span>

        <span class="cov7" title="48">if newTi.Squawk != nil </span><span class="cov0" title="0">{
                ti.Squawk = int(*newTi.Squawk) // only provided by Mode S messages, so we don't do this in parseUAT.
        }</span>
        // Set the target type. DF=18 messages are sent by ground station, so we look at CA
        // (repurposed to Control Field in DF18) to determine if it's ADS-R or TIS-B.
        <span class="cov7" title="48">if newTi.DF == 17 </span><span class="cov7" title="48">{
                ti.TargetType = TARGET_TYPE_ADSB
                ti.Addr_type = 0
        }</span> else<span class="cov0" title="0"> if newTi.DF == 18 </span><span class="cov0" title="0">{
                if newTi.CA == 6 </span><span class="cov0" title="0">{
                        ti.TargetType = TARGET_TYPE_ADSR
                        ti.Addr_type = 2
                }</span> else<span class="cov0" title="0"> if newTi.CA == 2 </span><span class="cov0" title="0">{ // 2 = TIS-B with ICAO address, 5 = TIS-B without ICAO address
                        ti.TargetType = TARGET_TYPE_TISB
                        ti.Addr_type = 2
                }</span> else<span class="cov0" title="0"> if newTi.CA == 5 </span><span class="cov0" title="0">{
                        ti.TargetType = TARGET_TYPE_TISB
                        ti.Addr_type = 3
                }</span>
        }

        <span class="cov7" title="48">if newTi.OnGround != nil </span><span class="cov7" title="48">{ // DF=11 messages don't report "on ground" status so we need to check for valid values.
                ti.OnGround = bool(*newTi.OnGround)
        }</span>

        <span class="cov7" title="48">if (newTi.Tail != nil) &amp;&amp; ((newTi.DF == 17) || (newTi.DF == 18) || (newTi.DF == 20) || (newTi.DF == 21)) </span><span class="cov7" title="48">{ // DF=17 or DF=18, Type Code 1-4 , DF=20 Altitude Reply (often with Ident in Comm-B) DF=21 Identity Reply
                ti.Tail = *newTi.Tail
                ti.Tail = strings.Trim(ti.Tail, " ") // remove extraneous spaces
        }</span>

        // This is a hack to show the source of the traffic on moving maps.

        <span class="cov7" title="48">if globalSettings.DisplayTrafficSource </span><span class="cov0" title="0">{
                type_code := " "
                switch ti.TargetType </span>{
                case TARGET_TYPE_ADSB:<span class="cov0" title="0">
                        type_code = "a"</span>
                case TARGET_TYPE_ADSR:<span class="cov0" title="0">
                        type_code = "r"</span>
                case TARGET_TYPE_TISB:<span class="cov0" title="0">
                        type_code = "t"</span>
                }

                <span class="cov0" title="0">if len(ti.Tail) == 0 </span><span class="cov0" title="0">{
                        ti.Tail = "e" + type_code
                }</span> else<span class="cov0" title="0"> if len(ti.Tail) &lt; 7 &amp;&amp; ti.Tail[0] != 'e' &amp;&amp; ti.Tail[0] != 'u' </span><span class="cov0" title="0">{
                        ti.Tail = "e" + type_code + ti.Tail
                }</span> else<span class="cov0" title="0"> if len(ti.Tail) == 7 &amp;&amp; ti.Tail[0] != 'e' &amp;&amp; ti.Tail[0] != 'u' </span><span class="cov0" title="0">{
                        ti.Tail = "e" + type_code + ti.Tail[1:]
                }</span> else<span class="cov0" title="0"> if len(ti.Tail) &gt; 1 </span><span class="cov0" title="0">{ // bounds checking
                        ti.Tail = "e" + type_code + ti.Tail[2:]

                }</span>
        }

        <span class="cov7" title="48">if newTi.DF == 17 || newTi.DF == 18 </span><span class="cov7" title="48">{
                ti.Last_source = TRAFFIC_SOURCE_1090ES // only update traffic source on ADS-B messages. Prevents source on UAT ADS-B targets with Mode S transponders from "flickering" every time we get an altitude or DF11 update.
        }</span>
        <span class="cov7" title="48">ti.Timestamp = newTi.Timestamp // only update "last seen" data on position updates

        /*
                s_out, err := json.Marshal(ti)
                if err != nil {
                        log.Printf("Error generating output: %s\n", err.Error())
                } else {
                        log.Printf("%X (DF%d) =&gt; %s\n", ti.Icao_addr, newTi.DF, string(s_out))
                }
        */
        postProcessTraffic(&amp;ti)
        traffic[ti.Icao_addr] = ti // Update information on this ICAO code.
        registerTrafficUpdate(ti)
        seenTraffic[ti.Icao_addr] = true // Mark as seen.
        //log.Printf("%v\n",traffic)
        trafficMutex.Unlock()</span>
}

func trafficInfoExtrapolator() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                time.Sleep(1 * time.Second)
                trafficMutex.Lock()
                for key, ti := range traffic </span><span class="cov0" title="0">{
                        if ti.Age &lt; 2 || !ti.Position_valid || !ti.Speed_valid </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">extrapolateTraffic(&amp;ti)
                        //log.Printf("Extrapolating " + ti.Tail + " oldPos: %f,%f,%d, newPos: %f,%f,%d", ti.Lat_fix, ti.Lng_fix, ti.Alt_fix, ti.Lat, ti.Lng, ti.Alt)
                        traffic[key] = ti</span>
                }
                <span class="cov0" title="0">trafficMutex.Unlock()</span>
        }

}

func extrapolateTraffic(ti *TrafficInfo) <span class="cov3" title="5">{
        if !ti.ExtrapolatedPosition </span><span class="cov3" title="5">{
                ti.Lat_fix = ti.Lat
                ti.Lng_fix = ti.Lng
                ti.Alt_fix = ti.Alt
                ti.Last_extrapolation = ti.Last_seen // to make computation below simpler
        }</span>

        <span class="cov3" title="5">seconds := stratuxClock.Since(ti.Last_extrapolation).Seconds()
        travelDist := float64(ti.Speed) * (seconds / 60 / 60) // speed is knots=nm per hour. /60/60 = nm per second

        // Estimate alt
        ti.Alt = int32(float64(ti.Alt) + (float64(ti.Vvel) * (seconds / 60)))
        // Estimate position
        lat, lng := calcLocationForBearingDistance(float64(ti.Lat), float64(ti.Lng), float64(ti.Track), travelDist)
        ti.Lat = float32(lat)
        ti.Lng = float32(lng)
        // Estimate track
        ti.Track += float32(seconds) * ti.TurnRate
        for ti.Track &lt; 0 </span><span class="cov0" title="0">{
                ti.Track += 360
        }</span>
        <span class="cov3" title="5">for ti.Track &gt; 360 </span><span class="cov0" title="0">{
                ti.Track -= 360
        }</span>
        // ti.Track = ti.Track % 360

        <span class="cov3" title="5">ti.ExtrapolatedPosition = true
        ti.Last_extrapolation = stratuxClock.Time</span>

        // TODO: should we call registerTrafficUpdate() to send this traffic to the web interface?
        // Pro: web interface also shows interpolated position
        // Con: it doesn't show the really received position with the age any more (i.e. age gets older but position updates)
}

/*
updateDemoTraffic creates / updates a simulated traffic target for demonstration / debugging
purpose. Target will circle clockwise around the current GPS position (if valid) or around
KOSH, once every five minutes.

Inputs are ICAO 24-bit hex code, tail number (8 chars max), relative altitude in feet,
groundspeed in knots, and bearing offset from 0 deg initial position.

Traffic on headings 150-240 (bearings 060-150) is intentionally suppressed from updating to allow
for testing of EFB and webUI response. Additionally, the "on ground" flag is set for headings 240-270,
and speed invalid flag is set for headings 135-150 to allow testing of response to those conditions.
*/
func updateDemoTraffic(icao uint32, tail string, relAlt float32, gs float64, offset int32) <span class="cov0" title="0">{
        var ti TrafficInfo
        trafficMutex.Lock()
        defer trafficMutex.Unlock()

        // Retrieve previous information on this ICAO code.
        if val, ok := traffic[icao]; ok </span><span class="cov0" title="0">{ // if we've already seen it, copy it in to do updates
                ti = val
                //log.Printf("Existing target %X imported for ES update\n", icao)
        }</span> else<span class="cov0" title="0"> {
                //log.Printf("New target %X created for ES update\n",newTi.Icao_addr)
                ti.Last_seen = stratuxClock.Time // need to initialize to current stratuxClock so it doesn't get cut before we have a chance to populate a position message
                ti.Icao_addr = icao
                ti.ExtrapolatedPosition = false
        }</span>
        <span class="cov0" title="0">hdg := float64((int32(stratuxClock.Milliseconds/1000)+offset)%720) / 2
        // gs := float64(220) // knots
        radius := gs * 0.2 / (2 * math.Pi)
        x := radius * math.Cos(hdg*math.Pi/180.0)
        y := radius * math.Sin(hdg*math.Pi/180.0)
        // default traffic location is Oshkosh if GPS not detected
        lat := 43.99
        lng := -88.56
        if isGPSValid() </span><span class="cov0" title="0">{
                lat = float64(mySituation.GPSLatitude)
                lng = float64(mySituation.GPSLongitude)
        }</span>
        <span class="cov0" title="0">traffRelLat := y / 60
        traffRelLng := -x / (60 * math.Cos(lat*math.Pi/180.0))

        ti.Icao_addr = icao
        ti.OnGround = false
        ti.Addr_type = uint8(icao % 4) // 0 == ADS-B; 1 == reserved; 2 == TIS-B with ICAO address; 3 == TIS-B without ICAO address; 6 == ADS-R
        if ti.Addr_type == 1 </span><span class="cov0" title="0">{         // reassign "reserved value" to ADS-R
                ti.Addr_type = 6
        }</span>

        <span class="cov0" title="0">if ti.Addr_type == 0 </span><span class="cov0" title="0">{
                ti.TargetType = TARGET_TYPE_ADSB
        }</span> else<span class="cov0" title="0"> if ti.Addr_type == 3 </span><span class="cov0" title="0">{
                ti.TargetType = TARGET_TYPE_TISB
        }</span> else<span class="cov0" title="0"> if ti.Addr_type == 6 </span><span class="cov0" title="0">{
                ti.TargetType = TARGET_TYPE_ADSR
        }</span> else<span class="cov0" title="0"> if ti.Addr_type == 2 </span><span class="cov0" title="0">{
                ti.TargetType = TARGET_TYPE_TISB_S
                if (ti.NIC &gt;= 7) &amp;&amp; (ti.Emitter_category &gt; 0) </span><span class="cov0" title="0">{ // If NIC is sufficiently high and emitter type is transmitted, we'll assume it's ADS-R.
                        ti.TargetType = TARGET_TYPE_ADSR
                }</span>
        }

        <span class="cov0" title="0">ti.Emitter_category = 1
        ti.Lat = float32(lat + traffRelLat)
        ti.Lng = float32(lng + traffRelLng)

        ti.Distance, ti.Bearing = common.Distance(float64(lat), float64(lng), float64(ti.Lat), float64(ti.Lng))
        ti.BearingDist_valid = true

        ti.Position_valid = true
        ti.ExtrapolatedPosition = false
        ti.Alt = int32(mySituation.GPSAltitudeMSL + relAlt)
        ti.Track = float32(hdg)
        ti.Speed = uint16(gs)
        if hdg &gt;= 240 &amp;&amp; hdg &lt; 270 </span><span class="cov0" title="0">{
                ti.OnGround = true
        }</span>
        <span class="cov0" title="0">if hdg &gt; 135 &amp;&amp; hdg &lt; 150 </span><span class="cov0" title="0">{
                ti.Speed_valid = false
        }</span> else<span class="cov0" title="0"> {
                ti.Speed_valid = true
        }</span>
        <span class="cov0" title="0">ti.Vvel = 0
        ti.Tail = tail // "DEMO1234"
        ti.Timestamp = time.Now()
        ti.Last_seen = stratuxClock.Time
        ti.Last_alt = stratuxClock.Time
        ti.Last_speed = stratuxClock.Time
        ti.NACp = 8
        ti.NIC = 8

        //ti.Age = math.Floor(ti.Age) + hdg / 1000
        ti.Last_source = 1
        if icao%5 == 1 </span><span class="cov0" title="0">{ // make some of the traffic look like it came from UAT
                ti.Last_source = 2
        }</span>

        <span class="cov0" title="0">if hdg &lt; 150 || hdg &gt; 240 </span><span class="cov0" title="0">{
                // now insert this into the traffic map...
                postProcessTraffic(&amp;ti)
                traffic[ti.Icao_addr] = ti
                registerTrafficUpdate(ti)
                seenTraffic[ti.Icao_addr] = true
        }</span>
}

/*
        icao2reg() : Converts 24-bit Mode S addresses to N-numbers and C-numbers.

                        Input: uint32 representing the Mode S address. Valid range for
                                translation is 0xA00001 - 0xADF7C7, inclusive.

                                Values outside the range A000001-AFFFFFF or C00001-C3FFFF
                                are flagged as foreign.

                                Values between ADF7C8 - AFFFFF are allocated to the United States,
                                but are not used for aicraft on the civil registry. These could be
                                military, other public aircraft, or future use.

                                Values between C0CDF9 - C3FFFF are allocated to Canada,
                                but are not used for aicraft on the civil registry. These could be
                                military, other public aircraft, or future use.

                                Values between 7C0000 - 7FFFFF are allocated to Australia.


                        Output:
                                string: String containing the decoded tail number (if decoding succeeded),
                                        "NON-NA" (for non-US / non Canada allocation), and "US-MIL" or "CA-MIL" for non-civil US / Canada allocation.

                                bool: True if the Mode S address successfully translated to an
                                        N number. False for all other conditions.
*/

func icao2reg(icao_addr uint32) (string, bool) <span class="cov6" title="29">{
        // Initialize local variables
        base34alphabet := string("ABCDEFGHJKLMNPQRSTUVWXYZ0123456789")
        nationalOffset := uint32(0xA00001) // default is US
        tail := ""
        nation := ""

        // Determine nationality
        if (icao_addr &gt;= 0xA00001) &amp;&amp; (icao_addr &lt;= 0xAFFFFF) </span><span class="cov6" title="21">{
                nation = "US"
        }</span> else<span class="cov4" title="8"> if (icao_addr &gt;= 0xC00001) &amp;&amp; (icao_addr &lt;= 0xC3FFFF) </span><span class="cov3" title="4">{
                nation = "CA"
        }</span> else<span class="cov3" title="4"> if (icao_addr &gt;= 0x7C0000) &amp;&amp; (icao_addr &lt;= 0x7FFFFF) </span><span class="cov2" title="3">{
                nation = "AU"
        }</span> else<span class="cov1" title="1"> {
                //TODO: future national decoding.
                return "OTHER", false
        }</span>

        <span class="cov6" title="28">if nation == "CA" </span><span class="cov3" title="4">{ // Canada decoding
                // First, discard addresses that are not assigned to aircraft on the civil registry
                if icao_addr &gt; 0xC0CDF8 </span><span class="cov2" title="2">{
                        //fmt.Printf("%X is a Canada aircraft, but not a CF-, CG-, or CI- registration.\n", icao_addr)
                        return "CA-MIL", false
                }</span>

                <span class="cov2" title="2">nationalOffset := uint32(0xC00001)
                serial := int32(icao_addr - nationalOffset)

                // Fifth letter
                e := serial % 26

                // Fourth letter
                d := (serial / 26) % 26

                // Third letter
                c := (serial / 676) % 26 // 676 == 26*26

                // Second letter
                b := (serial / 17576) % 26 // 17576 == 26*26*26

                b_str := "FGI"

                //fmt.Printf("B = %d, C = %d, D = %d, E = %d\n",b,c,d,e)
                tail = fmt.Sprintf("C-%c%c%c%c", b_str[b], c+65, d+65, e+65)</span>
        }

        <span class="cov6" title="26">if nation == "AU" </span><span class="cov2" title="3">{ // Australia decoding

                nationalOffset := uint32(0x7C0000)
                offset := (icao_addr - nationalOffset)
                i1 := offset / 1296
                offset2 := offset % 1296
                i2 := offset2 / 36
                offset3 := offset2 % 36
                i3 := offset3

                var a_char, b_char, c_char string

                a_char = fmt.Sprintf("%c", i1+65)
                b_char = fmt.Sprintf("%c", i2+65)
                c_char = fmt.Sprintf("%c", i3+65)

                if i1 &lt; 0 || i1 &gt; 25 || i2 &lt; 0 || i2 &gt; 25 || i3 &lt; 0 || i3 &gt; 25 </span><span class="cov0" title="0">{
                        return "OTHER", false
                }</span>

                <span class="cov2" title="3">tail = "VH-" + a_char + b_char + c_char</span>
        }

        <span class="cov6" title="26">if nation == "US" </span><span class="cov6" title="21">{ // FAA decoding
                // First, discard addresses that are not assigned to aircraft on the civil registry
                if icao_addr &gt; 0xADF7C7 </span><span class="cov2" title="2">{
                        //fmt.Printf("%X is a US aircraft, but not on the civil registry.\n", icao_addr)
                        return "US-MIL", false
                }</span>

                <span class="cov6" title="19">serial := int32(icao_addr - nationalOffset)
                // First digit
                a := (serial / 101711) + 1

                // Second digit
                a_remainder := serial % 101711
                b := ((a_remainder + 9510) / 10111) - 1

                // Third digit
                b_remainder := (a_remainder + 9510) % 10111
                c := ((b_remainder + 350) / 951) - 1

                // This next bit is more convoluted. First, figure out if we're using the "short" method of
                // decoding the last two digits (two letters, one letter and one blank, or two blanks).
                // This will be the case if digit "B" or "C" are calculated as negative, or if c_remainder
                // is less than 601.

                c_remainder := (b_remainder + 350) % 951
                var d, e int32

                if (b &gt;= 0) &amp;&amp; (c &gt;= 0) &amp;&amp; (c_remainder &gt; 600) </span><span class="cov5" title="10">{ // alphanumeric decoding method
                        d = 24 + (c_remainder-601)/35
                        e = (c_remainder - 601) % 35

                }</span> else<span class="cov4" title="9"> { // two-letter decoding method
                        if (b &lt; 0) || (c &lt; 0) </span><span class="cov1" title="1">{
                                c_remainder -= 350 // otherwise "  " == 350, "A " == 351, "AA" == 352, etc.
                        }</span>

                        <span class="cov4" title="9">d = (c_remainder - 1) / 25
                        e = (c_remainder - 1) % 25

                        if e &lt; 0 </span><span class="cov1" title="1">{
                                d -= 1
                                e += 25
                        }</span>
                }

                <span class="cov6" title="19">a_char := fmt.Sprintf("%d", a)
                var b_char, c_char, d_char, e_char string

                if b &gt;= 0 </span><span class="cov6" title="18">{
                        b_char = fmt.Sprintf("%d", b)
                }</span>

                <span class="cov6" title="19">if b &gt;= 0 &amp;&amp; c &gt;= 0 </span><span class="cov6" title="18">{
                        c_char = fmt.Sprintf("%d", c)
                }</span>

                <span class="cov6" title="19">if d &gt; -1 </span><span class="cov6" title="18">{
                        d_char = string(base34alphabet[d])
                        if e &gt; 0 </span><span class="cov6" title="18">{
                                e_char = string(base34alphabet[e-1])
                        }</span>
                }

                <span class="cov6" title="19">tail = "N" + a_char + b_char + c_char + d_char + e_char</span>

        }

        <span class="cov6" title="24">return tail, true</span>
}

func initTraffic(isTraceReplayMode bool) <span class="cov1" title="1">{
        traffic = make(map[uint32]TrafficInfo)
        seenTraffic = make(map[uint32]bool)
        trafficMutex = &amp;sync.Mutex{}
        if !isTraceReplayMode </span><span class="cov0" title="0">{
                go esListen()
                go ognListen()
                go aprsListen()
                go aisListen()
        }</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
        Copyright (c) 2015-2016 Christopher Young
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        uibroadcast.go: Helper functions for managementinterface - notification channels for update "subscriptions"
         (used for weather and traffic websockets).
*/

package main

import (
        "encoding/json"
        "sync"
        "time"

        "golang.org/x/net/websocket"
)

type uibroadcaster struct {
        sockets    []*websocket.Conn
        sockets_mu *sync.Mutex
        messages   chan []byte
}

func NewUIBroadcaster() *uibroadcaster <span class="cov0" title="0">{
        ret := &amp;uibroadcaster{
                sockets:    make([]*websocket.Conn, 0),
                sockets_mu: &amp;sync.Mutex{},
                messages:   make(chan []byte, 1024),
        }
        go ret.writer()
        return ret
}</span>

func (u *uibroadcaster) Send(msg []byte) <span class="cov10" title="50">{
        if u != nil &amp;&amp; u.messages != nil </span><span class="cov0" title="0">{
                u.messages &lt;- msg
        }</span>
}

func (u *uibroadcaster) SendJSON(i interface{}) <span class="cov10" title="50">{
        j, _ := json.Marshal(&amp;i)
        u.Send(j)
}</span>

func (u *uibroadcaster) AddSocket(sock *websocket.Conn) <span class="cov0" title="0">{
        u.sockets_mu.Lock()
        u.sockets = append(u.sockets, sock)
        u.sockets_mu.Unlock()
}</span>

func (u *uibroadcaster) writer() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                msg := &lt;-u.messages
                // Send to all.
                p := make([]*websocket.Conn, 0) // Keep a list of the writeable sockets.
                u.sockets_mu.Lock()
                for _, sock := range u.sockets </span><span class="cov0" title="0">{
                        err := sock.SetWriteDeadline(time.Now().Add(time.Second))
                        _, err2 := sock.Write(msg)
                        if err == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                                p = append(p, sock)
                        }</span>
                }
                <span class="cov0" title="0">u.sockets = p // Save the list of writeable sockets.
                u.sockets_mu.Unlock()</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
        Copyright (c) 2018 Thorsten Biermann
        Copyright (c) 2013 Adrian Batzill
        Distributable under the terms of The "BSD New" License
        that can be found in the LICENSE file, herein included
        as part of this header.

        xplane.go: Routines for generating X-Plane data feed

        Seems to be mostly undocumented, so instead of reverse engineering x-plane, we use this:
        https://www.foreflight.com/support/network-gps/
        Seems to be very similar, but the XATT message is cut short. It seems to work with most software though?
*/

package main

import (
        "fmt"
        "regexp"
)

func convertKnotsToXPlaneSpeed(knots float32) float32 <span class="cov9" title="10">{
        return knots / 1.94384 // meters per second
}</span>

func createXPlaneGpsMsg(latDeg float32, lonDeg float32, altMslFt float32, trackDeg float32, speedKt float32) []byte <span class="cov6" title="4">{
        // example: XGPS1,-122.298432,47.450756,420.9961,349.7547,57.9145
        return []byte(fmt.Sprintf("XGPSStratux,%.6f,%.6f,%.4f,%.4f,%.4f", lonDeg, latDeg, convertFeetToMeters(altMslFt), trackDeg, convertKnotsToXPlaneSpeed(speedKt)))
}</span>

func createXPlaneAttitudeMsg(headingDeg float32, pitchDeg float32, rollDeg float32) []byte <span class="cov6" title="5">{
        // example: XATT1,345.1,-1.1,-12.5,0.1374,0.0954,-0.0444,-17.0,-1.2,-65.0,-0.01,1.63,0.02
        // TODO find out what the remaining parameters are for
        return []byte(fmt.Sprintf("XATTStratux,%.1f,%.1f,%.1f,0,0,0,0,0,0,0,0,0", headingDeg, pitchDeg, rollDeg)) // this one makes Garmin Pilot (Android) happy, and is similar to what XPlane does
        //return []byte(fmt.Sprintf("XATTStratux,%.1f,%.1f,%.1f")) // this one is what the Foreflight spec says
}</span>

func createXPlaneTrafficMsg(targetId uint32, latDeg float32, lonDeg float32, altFt int32, hSpeedKt uint32, vSpeedFpm int32, onGround bool, trackDeg uint32, callSign string) []byte <span class="cov10" title="12">{
        // example: XTRA1,1,47.435484,-122.304048,351,1,0,62,0,N172SP

        // prepare airborne/ground information
        airborneValue := uint8(0)
        if onGround </span><span class="cov1" title="1">{
                airborneValue = 0
        }</span> else<span class="cov9" title="11"> {
                airborneValue = 1
        }</span>

        // prepare callsign (remove all non-alphanumeric characters)
        <span class="cov10" title="12">regEx, _ := regexp.Compile("[^a-zA-Z0-9]+")
        cleanCallSign := regEx.ReplaceAllString(callSign, "")

        return []byte(fmt.Sprintf("XTRAFFICStratux,%d,%.6f,%.6f,%d,%d,%d,%d,%d,%s", targetId, latDeg, lonDeg, altFt, vSpeedFpm, airborneValue, trackDeg, hSpeedKt, cleanCallSign))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
